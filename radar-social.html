<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Radar Social</title>
    
    <!-- PWA Meta Tags -->
    <meta name="description" content="Encuentra y conecta con personas cerca de ti usando radar geolocalizado">
    <meta name="theme-color" content="#0d1117">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Radar Social">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icon-192.png">
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #0d1117;
            color: #e6edf3;
            overflow-x: hidden;
            position: fixed;
            width: 100%;
            height: 100vh;
        }

        #root {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 24px;
            background: linear-gradient(180deg, rgba(13, 17, 23, 0.98) 0%, rgba(13, 17, 23, 0.92) 100%);
            backdrop-filter: blur(20px);
            position: relative;
            z-index: 100;
        }

        .header-icon {
            width: 28px;
            height: 28px;
            cursor: pointer;
            color: #c9d1d9;
            transition: all 0.2s ease;
            opacity: 0.9;
        }

        .header-title {
            font-size: 22px;
            font-weight: 600;
            letter-spacing: -0.3px;
            color: #f0f6fc;
        }

        .main-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: visible;
            padding: 20px;
            padding-bottom: 140px; /* Space for slider and thought input */
            background: radial-gradient(ellipse at center, rgba(22, 27, 34, 0.5) 0%, #0d1117 70%);
        }

        .radar-container {
            position: relative;
            width: min(85vw, 400px);
            height: min(85vw, 400px);
            margin: -20px auto 0; /* Move radar up slightly */
            overflow: visible;
        }

        .radar-container::before {
            content: '';
            position: absolute;
            inset: -14px;
            border-radius: 50%;
            background: linear-gradient(145deg, rgba(48, 58, 70, 0.8) 0%, rgba(28, 35, 45, 0.9) 100%);
            box-shadow: 
                inset 0 3px 8px rgba(255, 255, 255, 0.12),
                inset 0 -4px 8px rgba(0, 0, 0, 0.7),
                0 8px 32px rgba(0, 0, 0, 0.7),
                0 0 0 1px rgba(56, 189, 98, 0.15),
                0 0 20px rgba(56, 189, 98, 0.08);
            z-index: -1;
        }

        .radar-bg {
            position: absolute;
            inset: 0;
            border-radius: 50%;
            background: radial-gradient(circle at 45% 45%, 
                rgba(18, 38, 26, 1) 0%,
                rgba(12, 28, 18, 1) 40%,
                rgba(8, 18, 12, 1) 70%,
                rgba(13, 17, 23, 1) 100%
            );
            border: 1px solid rgba(48, 54, 61, 0.6);
            box-shadow: 
                0 0 0 1px rgba(22, 27, 34, 0.8),
                0 8px 32px rgba(0, 0, 0, 0.6),
                inset 0 0 80px rgba(0, 0, 0, 0.5),
                inset 0 1px 1px rgba(255, 255, 255, 0.02);
            overflow: visible;
        }

        .radar-content-rotatable {
            position: absolute;
            inset: 0;
            border-radius: 50%;
            transition: transform 0.3s ease;
        }

        .radar-grid {
            position: absolute;
            inset: 0;
            border-radius: 50%;
            overflow: hidden;
        }

        .radar-circle {
            position: absolute;
            border-radius: 50%;
            border: 1px solid rgba(56, 189, 98, 0.08);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .distance-label {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(139, 148, 158, 0.5);
            font-size: 11px;
            font-weight: 600;
            pointer-events: none;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
        }

        .radar-line {
            position: absolute;
            width: 1px;
            height: 100%;
            background: rgba(56, 189, 98, 0.06);
            top: 0;
            left: 50%;
            transform-origin: center;
        }

        .radar-sweep {
            position: absolute;
            width: 200%;
            height: 200%;
            top: -50%;
            left: -50%;
            background: conic-gradient(
                from 0deg,
                rgba(56, 189, 98, 0.05) 0deg,
                rgba(56, 189, 98, 0.15) 20deg,
                rgba(56, 189, 98, 0.25) 40deg,
                transparent 60deg,
                transparent 360deg
            );
            animation: radarSweep 6s linear infinite;
            pointer-events: none;
            border-radius: 50%;
            transform-origin: center;
        }

        @keyframes radarSweep {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Horizontal Range Slider - Integrated Design */
        .range-slider-container {
            position: fixed;
            left: 50%;
            bottom: 125px;
            transform: translateX(-50%);
            z-index: 50;
            width: 300px;
            padding: 12px 0;
        }

        .range-slider-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding: 0 4px;
        }

        .range-slider-title {
            font-size: 11px;
            font-weight: 600;
            color: rgba(139, 148, 158, 0.7);
            text-transform: uppercase;
            letter-spacing: 0.8px;
        }

        .range-slider-value {
            font-size: 18px;
            font-weight: 700;
            color: #38bd62;
            letter-spacing: -0.5px;
            text-shadow: 0 0 8px rgba(56, 189, 98, 0.4);
        }

        .range-slider-track {
            position: relative;
            width: 100%;
            height: 4px;
            background: rgba(48, 54, 61, 0.4);
            border-radius: 2px;
            overflow: visible;
            cursor: pointer;
        }

        .range-slider-progress {
            position: absolute;
            height: 100%;
            background: linear-gradient(90deg, rgba(56, 189, 98, 0.6) 0%, #38bd62 100%);
            border-radius: 2px;
            transition: width 0.2s ease;
            box-shadow: 0 0 12px rgba(56, 189, 98, 0.5);
        }

        .range-slider-thumb {
            position: absolute;
            top: 50%;
            width: 18px;
            height: 18px;
            background: linear-gradient(145deg, #38bd62 0%, #2ea556 100%);
            border: 3px solid #0d1117;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            cursor: grab;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 
                0 2px 8px rgba(0, 0, 0, 0.4),
                0 0 16px rgba(56, 189, 98, 0.6);
        }

        .range-slider-thumb:active {
            cursor: grabbing;
            transform: translate(-50%, -50%) scale(1.2);
            box-shadow: 
                0 3px 12px rgba(0, 0, 0, 0.5),
                0 0 20px rgba(56, 189, 98, 0.8);
        }

        .range-slider-marks {
            display: flex;
            justify-content: space-between;
            margin-top: 6px;
            padding: 0 4px;
        }

        .range-slider-mark {
            font-size: 9px;
            color: rgba(139, 148, 158, 0.4);
            font-weight: 500;
        }

        .avatar-container {
            position: absolute;
            cursor: pointer;
            z-index: 10;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        .avatar-container:active {
            transform: scale(0.94);
        }

        .avatar-wrapper {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            transform: translate(-50%, -50%);
            transform-origin: center center;
        }

        .avatar-ring {
            border-radius: 50%;
            padding: 2.5px;
            position: relative;
            flex-shrink: 0;
        }

        .avatar-ring.has-story {
            background: linear-gradient(135deg, #f59e0b 0%, #f97316 35%, #ec4899 70%, #a855f7 100%);
        }

        .avatar-ring.no-story {
            background: rgba(71, 85, 105, 0.5);
        }

        .avatar-ring.new-message {
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            animation: messagePulse 1.5s ease-in-out infinite;
        }

        @keyframes messagePulse {
            0%, 100% { 
                opacity: 1;
                box-shadow: 0 0 16px rgba(251, 191, 36, 0.4);
            }
            50% { 
                opacity: 0.75;
                box-shadow: 0 0 24px rgba(251, 191, 36, 0.6);
            }
        }

        .avatar-img-wrapper {
            border-radius: 50%;
            background: #0d1117;
            border: 2.5px solid #0d1117;
            overflow: hidden;
            position: relative;
        }

        .avatar-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .avatar-thought {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(22, 27, 34, 0.95);
            color: #e6edf3;
            padding: 5px 11px;
            border-radius: 9px;
            font-size: 12px;
            font-weight: 500;
            white-space: nowrap;
            border: 1px solid rgba(48, 54, 61, 0.6);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            max-width: 110px;
            overflow: hidden;
            text-overflow: ellipsis;
            letter-spacing: -0.1px;
            margin-bottom: 4px;
        }

        .avatar-name {
            font-size: 14px;
            font-weight: 600;
            color: #f0f6fc;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.9);
            letter-spacing: -0.2px;
            margin-top: 3px;
        }

        .avatar-distance {
            font-size: 12px;
            color: #8b949e;
            font-weight: 500;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.9);
            margin-top: 1px;
        }

        .message-badge {
            position: absolute;
            top: -2px;
            right: -2px;
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, #f59e0b 0%, #dc2626 100%);
            border-radius: 50%;
            border: 2px solid #0d1117;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 700;
            color: #fff;
            box-shadow: 0 2px 8px rgba(245, 158, 11, 0.5);
            animation: messageBadgePulse 2s ease-in-out infinite;
        }

        @keyframes messageBadgePulse {
            0%, 100% { 
                transform: scale(1);
            }
            50% { 
                transform: scale(1.1);
            }
        }

        .radar-info {
            position: absolute;
            top: -75px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 5;
            white-space: nowrap;
        }

        .radar-info-title {
            font-size: 11px;
            font-weight: 500;
            color: #8b949e;
            letter-spacing: -0.1px;
        }

        .precision-badge {
            display: inline-block;
            margin-top: 4px;
            padding: 2px 8px;
            background: rgba(56, 189, 98, 0.15);
            border: 1px solid rgba(56, 189, 98, 0.3);
            border-radius: 8px;
            font-size: 9px;
            font-weight: 600;
            color: #38bd62;
            letter-spacing: 0.3px;
            text-transform: uppercase;
            transition: all 0.3s ease;
        }

        .precision-badge.ultrasonic-active {
            background: rgba(255, 193, 7, 0.2);
            border-color: rgba(255, 193, 7, 0.5);
            color: #ffc107;
            animation: ultrasonic-pulse 1.5s ease-in-out infinite;
        }

        @keyframes ultrasonic-pulse {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(255, 193, 7, 0.4);
            }
            50% {
                box-shadow: 0 0 0 4px rgba(255, 193, 7, 0);
            }
        }

        .radar-info-count {
            font-size: 32px;
            font-weight: 800;
            color: #2d3640;
            letter-spacing: -1px;
            text-shadow: 
                0 1px 0 rgba(255, 255, 255, 0.2),
                0 2px 4px rgba(0, 0, 0, 0.8),
                0 0 20px rgba(88, 166, 255, 0.4),
                inset 0 -2px 4px rgba(0, 0, 0, 0.3);
            background: linear-gradient(180deg, #3d4856 0%, #252b35 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            filter: drop-shadow(0 2px 6px rgba(88, 166, 255, 0.3));
            margin-bottom: 2px;
        }

        .compass-label {
            position: absolute;
            font-size: 32px;
            font-weight: 800;
            color: rgba(139, 148, 158, 0.10);
            user-select: none;
            pointer-events: none;
            font-family: 'Inter', sans-serif;
            letter-spacing: 1px;
            text-shadow: 0 0 20px rgba(139, 148, 158, 0.05);
        }

        .compass-n {
            top: 10%;
            left: 50%;
            transform: translateX(-50%);
        }

        .compass-s {
            bottom: 10%;
            left: 50%;
            transform: translateX(-50%);
        }

        .compass-e {
            right: 10%;
            top: 50%;
            transform: translateY(-50%);
        }

        .compass-o {
            left: 10%;
            top: 50%;
            transform: translateY(-50%);
        }

        /* Center avatar (current user) - Fixed in center, smaller and aesthetic */
        .center-avatar-fixed {
            position: absolute !important;
            left: 50% !important;
            top: 50% !important;
            transform: translate(-50%, -50%) !important;
            z-index: 100 !important;
            opacity: 1 !important;
            pointer-events: auto !important;
        }
        
        .center-avatar-fixed .avatar-wrapper {
            transform: none !important;
        }
        
        .center-avatar .avatar-ring {
            width: 50px;
            height: 50px;
            padding: 2px;
            box-shadow: 
                0 0 0 2px rgba(56, 189, 98, 0.15),
                0 0 20px rgba(56, 189, 98, 0.3),
                0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .center-avatar .avatar-img-wrapper {
            width: 46px;
            height: 46px;
            border: 2px solid #0d1117;
        }

        .direction-indicator {
            position: absolute;
            top: -8px;
            left: 50%;
            margin-left: -6px;
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 12px solid #38bd62;
            filter: drop-shadow(0 0 6px rgba(56, 189, 98, 0.6));
            transition: transform 0.1s ease-out;
            z-index: 10;
            pointer-events: none;
        }

        /* Regular avatars */
        .regular-avatar .avatar-ring {
            width: 58px;
            height: 58px;
            padding: 2px;
        }

        .regular-avatar .avatar-img-wrapper {
            width: 54px;
            height: 54px;
            border: 2px solid #0d1117;
        }

        .bottom-bar {
            background: linear-gradient(180deg, rgba(13, 17, 23, 0) 0%, rgba(13, 17, 23, 0.98) 15%, rgba(13, 17, 23, 1) 100%);
            padding: 16px 20px 28px;
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .thought-input-container {
            flex: 1;
            position: relative;
            display: flex;
            align-items: center;
        }

        .thought-input {
            flex: 1;
            background: rgba(22, 27, 34, 0.7);
            border: 1px solid rgba(48, 54, 61, 0.4);
            border-radius: 25px;
            padding: 13px 50px 13px 20px;
            color: #e6edf3;
            font-size: 15px;
            font-family: 'Inter', sans-serif;
            outline: none;
            transition: all 0.2s ease;
            font-weight: 400;
            letter-spacing: -0.2px;
            width: 100%;
        }
        
        .send-button {
            position: absolute;
            right: 6px;
            width: 38px;
            height: 38px;
            border-radius: 50%;
            background: rgba(56, 189, 98, 0.15);
            border: 1px solid rgba(56, 189, 98, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            opacity: 0.7;
        }
        
        .send-button:hover {
            opacity: 1;
            background: rgba(56, 189, 98, 0.25);
            transform: scale(1.05);
        }
        
        .send-button:active {
            transform: scale(0.95);
        }
        
        .send-button svg {
            width: 18px;
            height: 18px;
            color: #38bd62;
        }
        }

        .thought-input::placeholder {
            color: #6e7681;
        }

        .thought-input:focus {
            border-color: rgba(48, 54, 61, 0.7);
            background: rgba(22, 27, 34, 0.85);
        }

        .location-permission {
            position: fixed;
            inset: 0;
            background: rgba(13, 17, 23, 0.97);
            backdrop-filter: blur(20px);
            z-index: 400;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 30px;
        }

        .permission-card {
            background: rgba(22, 27, 34, 0.95);
            border: 1px solid rgba(48, 54, 61, 0.6);
            border-radius: 18px;
            padding: 34px 26px;
            text-align: center;
            max-width: 350px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .permission-icon {
            width: 68px;
            height: 68px;
            margin: 0 auto 22px;
            color: #58a6ff;
            opacity: 0.9;
        }

        .permission-card h2 {
            font-size: 21px;
            color: #f0f6fc;
            margin-bottom: 11px;
            font-weight: 600;
            letter-spacing: -0.3px;
        }

        .permission-card p {
            color: #8b949e;
            line-height: 1.6;
            margin-bottom: 26px;
            font-size: 14px;
            font-weight: 400;
        }

        .permission-btn {
            width: 100%;
            padding: 15px;
            border-radius: 11px;
            background: rgba(88, 166, 255, 0.14);
            color: #58a6ff;
            font-size: 15px;
            font-weight: 600;
            font-family: 'Inter', sans-serif;
            border: 1px solid rgba(88, 166, 255, 0.18);
            cursor: pointer;
            transition: all 0.2s ease;
            letter-spacing: -0.2px;
        }

        .chat-overlay {
            position: fixed;
            inset: 0;
            background: #0d1117;
            z-index: 200;
            display: flex;
            flex-direction: column;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }

        .chat-overlay.active {
            transform: translateX(0);
        }

        .chat-header {
            display: flex;
            align-items: center;
            gap: 14px;
            padding: 16px 20px;
            background: rgba(22, 27, 34, 0.95);
            border-bottom: 1px solid rgba(48, 54, 61, 0.5);
        }

        .chat-header svg {
            width: 26px;
            height: 26px;
            color: #8b949e;
            cursor: pointer;
        }

        .chat-user-info {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .chat-user-avatar {
            width: 42px;
            height: 42px;
            border-radius: 50%;
            object-fit: cover;
        }

        .chat-user-details h3 {
            font-size: 16px;
            font-weight: 600;
            color: #f0f6fc;
            margin-bottom: 2px;
        }

        .chat-user-details p {
            font-size: 13px;
            color: #8b949e;
        }

        .chat-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .chat-thought-display {
            background: rgba(22, 27, 34, 0.7);
            border: 1px solid rgba(48, 54, 61, 0.4);
            padding: 10px 16px;
            margin: 12px 16px;
            border-radius: 10px;
            color: #8b949e;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .chat-info {
            background: rgba(22, 27, 34, 0.6);
            border: 1px solid rgba(48, 54, 61, 0.3);
            padding: 12px 16px;
            border-radius: 10px;
            color: #8b949e;
            font-size: 13px;
            text-align: center;
            line-height: 1.5;
        }

        .message {
            max-width: 75%;
            padding: 11px 15px;
            border-radius: 16px;
            font-size: 15px;
            line-height: 1.4;
            word-wrap: break-word;
        }

        .message.sent {
            background: rgba(88, 166, 255, 0.18);
            color: #e6edf3;
            align-self: flex-end;
            border: 1px solid rgba(88, 166, 255, 0.2);
        }

        .message.received {
            background: rgba(22, 27, 34, 0.9);
            color: #e6edf3;
            align-self: flex-start;
            border: 1px solid rgba(48, 54, 61, 0.5);
        }

        .chat-input-container {
            padding: 14px 16px 20px;
            background: linear-gradient(180deg, rgba(13, 17, 23, 0) 0%, rgba(13, 17, 23, 0.98) 15%, rgba(13, 17, 23, 1) 100%);
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .chat-input {
            flex: 1;
            background: rgba(22, 27, 34, 0.7);
            border: 1px solid rgba(48, 54, 61, 0.4);
            border-radius: 20px;
            padding: 11px 16px;
            color: #e6edf3;
            font-size: 15px;
            font-family: 'Inter', sans-serif;
            outline: none;
            resize: none;
            min-height: 42px;
            max-height: 100px;
        }

        .chat-input::placeholder {
            color: #6e7681;
        }

        .chat-send-btn {
            width: 46px;
            height: 46px;
            border-radius: 50%;
            background: rgba(88, 166, 255, 0.14);
            border: 1px solid rgba(88, 166, 255, 0.18);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .chat-send-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .chat-send-btn:not(:disabled):active {
            transform: scale(0.95);
            background: rgba(88, 166, 255, 0.2);
        }

        .chat-send-btn svg {
            color: #58a6ff;
        }

        /* Sidebar */
        .sidebar {
            position: fixed;
            left: 0;
            top: 0;
            bottom: 0;
            width: 280px;
            background: rgba(22, 27, 34, 0.98);
            backdrop-filter: blur(20px);
            border-right: 1px solid rgba(48, 54, 61, 0.5);
            z-index: 300;
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        .sidebar.active {
            transform: translateX(0);
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid rgba(48, 54, 61, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .sidebar-header h2 {
            font-size: 20px;
            font-weight: 600;
            color: #f0f6fc;
        }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px 0;
        }

        .sidebar-item {
            padding: 14px 20px;
            display: flex;
            align-items: center;
            gap: 14px;
            color: #c9d1d9;
            cursor: pointer;
            transition: all 0.2s ease;
            border-left: 3px solid transparent;
        }

        .sidebar-item:hover {
            background: rgba(48, 54, 61, 0.3);
            border-left-color: #58a6ff;
        }

        .sidebar-item svg {
            width: 22px;
            height: 22px;
            color: #8b949e;
        }

        /* Profile */
        .profile-overlay {
            position: fixed;
            inset: 0;
            background: #0d1117;
            z-index: 250;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        .profile-overlay.active {
            transform: translateX(0);
        }

        .profile-header {
            padding: 16px 20px;
            background: rgba(22, 27, 34, 0.95);
            border-bottom: 1px solid rgba(48, 54, 61, 0.5);
            display: flex;
            align-items: center;
            gap: 14px;
        }

        .profile-content {
            flex: 1;
            overflow-y: auto;
            padding: 24px 20px;
        }

        .profile-avatar-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 28px;
        }

        .profile-avatar-large {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            border: 3px solid rgba(88, 166, 255, 0.3);
            object-fit: cover;
            margin-bottom: 16px;
        }

        .profile-name {
            font-size: 24px;
            font-weight: 600;
            color: #f0f6fc;
            margin-bottom: 4px;
        }

        .profile-bio {
            color: #8b949e;
            text-align: center;
            font-size: 14px;
        }

        .profile-section {
            margin-bottom: 24px;
        }

        .profile-section-title {
            font-size: 13px;
            font-weight: 600;
            color: #8b949e;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
        }

        .profile-field {
            background: rgba(22, 27, 34, 0.6);
            border: 1px solid rgba(48, 54, 61, 0.4);
            border-radius: 10px;
            padding: 12px 16px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .profile-field-label {
            color: #8b949e;
            font-size: 14px;
        }

        .profile-field-value {
            color: #f0f6fc;
            font-size: 14px;
            font-weight: 500;
        }

        /* Circular Story Viewer */
        .story-viewer {
            position: fixed;
            inset: 0;
            background: rgba(13, 17, 23, 0.98);
            z-index: 400;
            display: flex;
            align-items: center;
            justify-content: center;
            transform: scale(0);
            opacity: 0;
            transition: all 0.3s ease;
        }

        .story-viewer.active {
            transform: scale(1);
            opacity: 1;
        }

        .story-circle {
            width: min(90vw, 400px);
            height: min(90vw, 400px);
            border-radius: 50%;
            overflow: hidden;
            position: relative;
            border: 3px solid rgba(88, 166, 255, 0.3);
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.8);
        }

        .story-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .story-close {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(22, 27, 34, 0.9);
            border: 1px solid rgba(48, 54, 61, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 10;
        }

        .story-close svg {
            width: 20px;
            height: 20px;
            color: #c9d1d9;
        }

        .story-user-info {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 10;
        }

        .story-user-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid #fff;
        }

        .story-user-name {
            font-size: 16px;
            font-weight: 600;
            color: #fff;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.8);
        }

        .overlay-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            z-index: 250;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .overlay-backdrop.active {
            opacity: 1;
            pointer-events: all;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        // Initialize Firebase
        const firebaseConfig = {
            apiKey: "AIzaSyAhcfX0M5oqX7rZ6WdCZaHfxHKcxySxQl8",
            authDomain: "radar-social-5a61f.firebaseapp.com",
            projectId: "radar-social-5a61f",
            storageBucket: "radar-social-5a61f.firebasestorage.app",
            messagingSenderId: "1010787643000",
            appId: "1:1010787643000:web:e9dc6a1c175d875b90478d",
            measurementId: "G-NXM0HPCWMY"
        };
        
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();

        // ==========================================
        // KALMAN FILTER CLASS - Suaviza GPS
        // ==========================================
        class KalmanFilter {
            constructor(processNoise = 0.001, measurementNoise = 0.1) {
                this.x = 0;  // Estado estimado
                this.P = 1;  // Error de estimaci√≥n
                this.Q = processNoise;  // Ruido del proceso
                this.R = measurementNoise;  // Ruido de medici√≥n
            }
            
            update(measurement) {
                // Predicci√≥n
                this.P = this.P + this.Q;
                
                // Actualizaci√≥n (correcci√≥n)
                const K = this.P / (this.P + this.R);  // Ganancia de Kalman
                this.x = this.x + K * (measurement - this.x);
                this.P = (1 - K) * this.P;
                
                return this.x;
            }
            
            reset(value) {
                this.x = value;
                this.P = 1;
            }
        }

        function RadarSocialApp() {
            const [locationPermission, setLocationPermission] = useState(false);
            const [radius, setRadius] = useState(50);
            const [thought, setThought] = useState('');
            const [currentUser, setCurrentUser] = useState(null);
            const [userLocation, setUserLocation] = useState(null);
            const [users, setUsers] = useState([]); // Start empty - will load from Firebase
            const [isDraggingDial, setIsDraggingDial] = useState(false);
            const [selectedUser, setSelectedUser] = useState(null);
            const [chats, setChats] = useState({});
            const [messages, setMessages] = useState({});
            const [messageInput, setMessageInput] = useState('');
            const [audioContext, setAudioContext] = useState(null);
            const [showSidebar, setShowSidebar] = useState(false);
            const [showProfile, setShowProfile] = useState(false);
            const [viewingStory, setViewingStory] = useState(null);
            const [deviceHeading, setDeviceHeading] = useState(0); // Phone compass direction
            const [lastKnownPositions, setLastKnownPositions] = useState({}); // For GPS smoothing
            
            // SENSOR FUSION - Estados para sensores
            const [sensorData, setSensorData] = useState({
                acceleration: { x: 0, y: 0, z: 0 },
                rotation: { alpha: 0, beta: 0, gamma: 0 },
                heading: 0,
                isMoving: false,
                lastMotionTime: 0
            });
            const [locationAccuracy, setLocationAccuracy] = useState(20); // metros
            
            // ULTRASONIC SYSTEM - Estados para audio ultras√≥nico
            const [ultrasonicActive, setUltrasonicActive] = useState(false);
            const [ultrasonicDetections, setUltrasonicDetections] = useState({}); // { userId: distance }
            const ultrasonicContext = useRef(null);
            const ultrasonicAnalyser = useRef(null);
            const detectionInterval = useRef(null);
            
            // Kalman Filters para latitud y longitud
            const kalmanLat = useRef(new KalmanFilter(0.001, 0.1));
            const kalmanLon = useRef(new KalmanFilter(0.001, 0.1));
            const lastDeadReckoningPos = useRef(null);
            const lastDeadReckoningTime = useRef(Date.now());

            // Calculate distance between two GPS coordinates (Haversine formula)
            const calculateDistance = (lat1, lon1, lat2, lon2) => {
                const R = 6371e3; // Earth's radius in meters
                const œÜ1 = lat1 * Math.PI / 180;
                const œÜ2 = lat2 * Math.PI / 180;
                const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
                const ŒîŒª = (lon2 - lon1) * Math.PI / 180;

                const a = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
                          Math.cos(œÜ1) * Math.cos(œÜ2) *
                          Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

                return R * c; // Distance in meters
            };

            // Calculate angle/bearing from point 1 to point 2
            const calculateBearing = (lat1, lon1, lat2, lon2) => {
                const œÜ1 = lat1 * Math.PI / 180;
                const œÜ2 = lat2 * Math.PI / 180;
                const ŒîŒª = (lon2 - lon1) * Math.PI / 180;

                const y = Math.sin(ŒîŒª) * Math.cos(œÜ2);
                const x = Math.cos(œÜ1) * Math.sin(œÜ2) -
                          Math.sin(œÜ1) * Math.cos(œÜ2) * Math.cos(ŒîŒª);
                const Œ∏ = Math.atan2(y, x);

                return (Œ∏ * 180 / Math.PI + 360) % 360; // Bearing in degrees
            };

            // ==========================================
            // SENSOR FUSION - Dead Reckoning
            // ==========================================
            const applyDeadReckoning = (lastPos, acceleration, heading, deltaTime) => {
                if (!lastPos || !sensorData.isMoving) return lastPos;
                
                // Calcular velocidad aproximada desde aceleraci√≥n
                // v = a * t (aproximaci√≥n simple)
                const speed = Math.sqrt(
                    acceleration.x ** 2 + 
                    acceleration.y ** 2
                ) * deltaTime; // metros
                
                // Convertir heading a radianes
                const headingRad = heading * Math.PI / 180;
                
                // Calcular desplazamiento en metros
                const dx = speed * Math.sin(headingRad);
                const dy = speed * Math.cos(headingRad);
                
                // Convertir metros a grados (aproximado)
                const dLat = dy / 111320; // 1 grado lat ‚âà 111.32 km
                const dLon = dx / (111320 * Math.cos(lastPos.latitude * Math.PI / 180));
                
                return {
                    latitude: lastPos.latitude + dLat,
                    longitude: lastPos.longitude + dLon
                };
            };

            // ==========================================
            // SENSOR FUSION - Combina GPS + Sensores
            // ==========================================
            const applySensorFusion = (rawGPS, accuracy) => {
                // 1. Aplicar Kalman Filter al GPS
                const filteredLat = kalmanLat.current.update(rawGPS.latitude);
                const filteredLon = kalmanLon.current.update(rawGPS.longitude);
                
                // 2. Si el usuario est√° en movimiento, aplicar Dead Reckoning
                if (sensorData.isMoving && lastDeadReckoningPos.current) {
                    const now = Date.now();
                    const deltaTime = (now - lastDeadReckoningTime.current) / 1000; // segundos
                    
                    const predictedPos = applyDeadReckoning(
                        lastDeadReckoningPos.current,
                        sensorData.acceleration,
                        sensorData.heading,
                        deltaTime
                    );
                    
                    // 3. Combinar GPS filtrado con predicci√≥n
                    // Dar m√°s peso al GPS si la precisi√≥n es buena
                    const gpsWeight = Math.max(0.3, Math.min(0.9, 1 - (accuracy / 50)));
                    const drWeight = 1 - gpsWeight;
                    
                    const fusedLat = (filteredLat * gpsWeight) + (predictedPos.latitude * drWeight);
                    const fusedLon = (filteredLon * gpsWeight) + (predictedPos.longitude * drWeight);
                    
                    lastDeadReckoningTime.current = now;
                    lastDeadReckoningPos.current = { latitude: fusedLat, longitude: fusedLon };
                    
                    // Precisi√≥n mejorada (2-5m t√≠picamente)
                    const improvedAccuracy = Math.min(accuracy * 0.3, 5);
                    setLocationAccuracy(improvedAccuracy);
                    
                    console.log(`üß† Sensor Fusion: GPS(${accuracy.toFixed(1)}m) ‚Üí Fused(${improvedAccuracy.toFixed(1)}m)`);
                    
                    return {
                        latitude: fusedLat,
                        longitude: fusedLon,
                        accuracy: improvedAccuracy
                    };
                } else {
                    // Usuario quieto, solo usar GPS filtrado
                    lastDeadReckoningPos.current = { latitude: filteredLat, longitude: filteredLon };
                    lastDeadReckoningTime.current = Date.now();
                    
                    const improvedAccuracy = Math.min(accuracy * 0.5, 8);
                    setLocationAccuracy(improvedAccuracy);
                    
                    console.log(`üìç Kalman Filter: GPS(${accuracy.toFixed(1)}m) ‚Üí Filtered(${improvedAccuracy.toFixed(1)}m)`);
                    
                    return {
                        latitude: filteredLat,
                        longitude: filteredLon,
                        accuracy: improvedAccuracy
                    };
                }
            };

            // ==========================================
            // ULTRASONIC SYSTEM - Audio Ultras√≥nico
            // ==========================================
            
            // Emitir se√±al ultras√≥nica con ID de usuario codificado
            const emitUltrasonicSignal = (userId) => {
                if (!audioContext) return;
                
                try {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    // Frecuencia base: 19.5 kHz (inaudible para humanos)
                    const baseFreq = 19500;
                    
                    // Codificar userId en la frecuencia (simple FSK)
                    // √öltimo d√≠gito del hash del userId determina offset
                    const userHash = userId.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
                    const freqOffset = (userHash % 10) * 50; // 0-500 Hz offset
                    
                    oscillator.frequency.value = baseFreq + freqOffset;
                    oscillator.type = 'sine';
                    
                    // Volumen moderado
                    gainNode.gain.value = 0.3;
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    // Burst corto de 150ms
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.15);
                    
                    console.log(`üîä Emitiendo ultrasonido: ${(baseFreq + freqOffset).toFixed(0)} Hz`);
                } catch (error) {
                    console.error('Error emitting ultrasonic:', error);
                }
            };
            
            // Iniciar detector de ultrasonido
            const startUltrasonicDetector = async () => {
                if (ultrasonicActive) return;
                
                try {
                    // Solicitar permiso de micr√≥fono
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            sampleRate: 48000 // Alta frecuencia de muestreo para captar 19.5 kHz
                        }
                    });
                    
                    // Crear contexto de audio para an√°lisis
                    const ctx = new (window.AudioContext || window.webkitAudioContext)();
                    ultrasonicContext.current = ctx;
                    
                    const analyser = ctx.createAnalyser();
                    analyser.fftSize = 4096; // Alta resoluci√≥n
                    analyser.smoothingTimeConstant = 0.3;
                    ultrasonicAnalyser.current = analyser;
                    
                    const source = ctx.createMediaStreamSource(stream);
                    source.connect(analyser);
                    
                    setUltrasonicActive(true);
                    console.log('‚úÖ Detector ultras√≥nico activado');
                    
                    // Iniciar detecci√≥n continua
                    detectUltrasonicSignals();
                } catch (error) {
                    console.error('Error starting ultrasonic detector:', error);
                    console.log('‚ö†Ô∏è Micr√≥fono no disponible - precisi√≥n <5m desactivada');
                }
            };
            
            // Detener detector de ultrasonido
            const stopUltrasonicDetector = () => {
                if (detectionInterval.current) {
                    clearInterval(detectionInterval.current);
                    detectionInterval.current = null;
                }
                
                if (ultrasonicContext.current) {
                    ultrasonicContext.current.close();
                    ultrasonicContext.current = null;
                }
                
                setUltrasonicActive(false);
                setUltrasonicDetections({});
                console.log('‚ùå Detector ultras√≥nico desactivado');
            };
            
            // Detectar se√±ales ultras√≥nicas
            const detectUltrasonicSignals = () => {
                if (!ultrasonicAnalyser.current) return;
                
                const analyser = ultrasonicAnalyser.current;
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                
                detectionInterval.current = setInterval(() => {
                    analyser.getByteFrequencyData(dataArray);
                    
                    // Buscar picos en rango 19-20 kHz
                    // frequencyBinCount / 2 = Nyquist frequency (24 kHz at 48kHz sample rate)
                    const nyquist = ultrasonicContext.current.sampleRate / 2;
                    const binWidth = nyquist / bufferLength;
                    
                    const minFreq = 19000;
                    const maxFreq = 20000;
                    const minBin = Math.floor(minFreq / binWidth);
                    const maxBin = Math.floor(maxFreq / binWidth);
                    
                    let maxAmplitude = 0;
                    let peakFrequency = 0;
                    
                    for (let i = minBin; i < maxBin && i < bufferLength; i++) {
                        if (dataArray[i] > maxAmplitude) {
                            maxAmplitude = dataArray[i];
                            peakFrequency = i * binWidth;
                        }
                    }
                    
                    // Threshold: detectar se√±al si amplitud > 100
                    if (maxAmplitude > 100) {
                        // Calcular distancia aproximada por intensidad de se√±al
                        // Ley del cuadrado inverso simplificada
                        // distance ‚âà 5 * (1 - amplitude/255)
                        const normalizedAmplitude = maxAmplitude / 255;
                        const estimatedDistance = Math.max(0.1, 5 * (1 - normalizedAmplitude));
                        
                        console.log(`üéØ Ultrasonido detectado: ${peakFrequency.toFixed(0)} Hz, Amp:${maxAmplitude}, ~${estimatedDistance.toFixed(2)}m`);
                        
                        // Guardar detecci√≥n
                        setUltrasonicDetections(prev => ({
                            ...prev,
                            'nearby': estimatedDistance,
                            lastUpdate: Date.now()
                        }));
                    }
                }, 200); // Detectar cada 200ms
            };
            
            // Combinar distancia GPS con distancia ultras√≥nica
            const getFinalDistance = (gpsDistance, userId) => {
                // Si hay detecci√≥n ultras√≥nica reciente (< 1 segundo) y distancia GPS < 5m
                const hasRecentDetection = ultrasonicDetections.lastUpdate && 
                                         (Date.now() - ultrasonicDetections.lastUpdate) < 1000;
                
                if (gpsDistance < 5 && hasRecentDetection && ultrasonicDetections.nearby) {
                    const ultrasonicDist = ultrasonicDetections.nearby;
                    // Promedio ponderado: 70% ultras√≥nico, 30% GPS
                    const finalDist = (ultrasonicDist * 0.7) + (gpsDistance * 0.3);
                    return Math.max(0.1, finalDist); // M√≠nimo 10cm
                }
                return gpsDistance;
            };

            useEffect(() => {
                // Initialize audio context
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                setAudioContext(ctx);
                
                // Load real user from Firebase
                const unsubscribe = auth.onAuthStateChanged(async (firebaseUser) => {
                    if (firebaseUser) {
                        console.log('Firebase User loaded:', firebaseUser);
                        console.log('Photo URL:', firebaseUser.photoURL);
                        
                        // Get user's current location with HIGH PRECISION
                        if ('geolocation' in navigator) {
                            let lastUpdateTime = 0;
                            let usersUnsubscribe = null;
                            
                            // Use watchPosition for continuous updates
                            let previousLocation = null;
                            
                            const watchId = navigator.geolocation.watchPosition(
                                async (position) => {
                                    const { latitude, longitude, accuracy } = position.coords;
                                    const currentTime = Date.now();
                                    
                                    // ==========================================
                                    // APLICAR SENSOR FUSION üß†
                                    // ==========================================
                                    const fusedLocation = applySensorFusion(
                                        { latitude, longitude },
                                        accuracy
                                    );
                                    
                                    // Check if movement is significant (more than 3 meters)
                                    const shouldUpdate = !previousLocation || 
                                                       calculateDistance(
                                                           previousLocation.latitude,
                                                           previousLocation.longitude,
                                                           fusedLocation.latitude,
                                                           fusedLocation.longitude
                                                       ) >= 3;
                                    
                                    if (shouldUpdate) {
                                        console.log(`üìç GPS Raw: ${latitude.toFixed(6)}, ${longitude.toFixed(6)} (¬±${accuracy.toFixed(1)}m)`);
                                        console.log(`üéØ Fused: ${fusedLocation.latitude.toFixed(6)}, ${fusedLocation.longitude.toFixed(6)} (¬±${fusedLocation.accuracy.toFixed(1)}m)`);
                                        
                                        // Update local state with FUSED location
                                        setUserLocation({ 
                                            latitude: fusedLocation.latitude, 
                                            longitude: fusedLocation.longitude 
                                        });
                                        previousLocation = { 
                                            latitude: fusedLocation.latitude, 
                                            longitude: fusedLocation.longitude 
                                        };
                                    } else {
                                        console.log(`üìç Movement ignored (< 3m)`);
                                    }
                                    
                                    // Update Firebase every 3 seconds (throttle to avoid excessive writes)
                                    if (currentTime - lastUpdateTime >= 3000 && shouldUpdate) {
                                        lastUpdateTime = currentTime;
                                        
                                        try {
                                            // First time setup
                                            if (!usersUnsubscribe) {
                                                // Get user data from Firestore
                                                const userDoc = await db.collection('users').doc(firebaseUser.uid).get();
                                                
                                                let thought = '';
                                                let thoughtTimestamp = null;
                                                if (userDoc.exists) {
                                                    const userData = userDoc.data();
                                                    thoughtTimestamp = userData.thoughtTimestamp;
                                                    
                                                    // Check if thought is expired (24 hours)
                                                    if (userData.thought && thoughtTimestamp) {
                                                        const now = Date.now();
                                                        const thoughtTime = thoughtTimestamp.toMillis ? thoughtTimestamp.toMillis() : thoughtTimestamp;
                                                        const hoursPassed = (now - thoughtTime) / (1000 * 60 * 60);
                                                        
                                                        if (hoursPassed < 24) {
                                                            thought = userData.thought;
                                                        } else {
                                                            // Clear expired thought
                                                            await db.collection('users').doc(firebaseUser.uid).update({
                                                                thought: '',
                                                                thoughtTimestamp: null
                                                            });
                                                        }
                                                    }
                                                }
                                                
                                                // Create current user object
                                                const realUser = {
                                                    id: firebaseUser.uid,
                                                    name: firebaseUser.displayName || 'Usuario',
                                                    age: 25,
                                                    photo: firebaseUser.photoURL || 'https://ui-avatars.com/api/?name=' + encodeURIComponent(firebaseUser.displayName || 'User') + '&background=38bd62&color=fff&size=150',
                                                    thought: thought,
                                                    hasStory: false,
                                                    distance: 0,
                                                    angle: 0,
                                                    hasNewMessage: false,
                                                    email: firebaseUser.email,
                                                    latitude: latitude,
                                                    longitude: longitude
                                                };
                                                
                                                console.log('Real user created:', realUser);
                                                setCurrentUser(realUser);
                                                setThought(realUser.thought);
                                                
                                                // Listen to all users in real-time
                                                usersUnsubscribe = db.collection('users')
                                                    .where('isOnline', '==', true)
                                                    .onSnapshot((snapshot) => {
                                                        const otherUsers = [];
                                                        
                                                        // Get current location from state
                                                        const currentLat = latitude;
                                                        const currentLon = longitude;
                                                        
                                                        snapshot.forEach((doc) => {
                                                            const userData = doc.data();
                                                            
                                                            // Skip current user
                                                            if (userData.uid === firebaseUser.uid) return;
                                                            
                                                            // Calculate distance and angle from current user
                                                            if (userData.location) {
                                                                const userLat = userData.location.latitude;
                                                                const userLon = userData.location.longitude;
                                                                
                                                                const distance = Math.round(
                                                                    calculateDistance(currentLat, currentLon, userLat, userLon)
                                                                );
                                                                
                                                                const angle = Math.round(
                                                                    calculateBearing(currentLat, currentLon, userLat, userLon)
                                                                );
                                                                
                                                                // Check if thought is expired (24 hours)
                                                                let displayThought = '';
                                                                if (userData.thought && userData.thoughtTimestamp) {
                                                                    const now = Date.now();
                                                                    const thoughtTime = userData.thoughtTimestamp.toMillis ? userData.thoughtTimestamp.toMillis() : userData.thoughtTimestamp;
                                                                    const hoursPassed = (now - thoughtTime) / (1000 * 60 * 60);
                                                                    
                                                                    if (hoursPassed < 24) {
                                                                        displayThought = userData.thought;
                                                                    }
                                                                }
                                                                
                                                                otherUsers.push({
                                                                    id: userData.uid,
                                                                    name: userData.displayName || 'Usuario',
                                                                    age: 25,
                                                                    photo: userData.photoURL || 'https://ui-avatars.com/api/?name=' + encodeURIComponent(userData.displayName || 'User') + '&background=38bd62&color=fff&size=150',
                                                                    thought: displayThought,
                                                                    hasStory: false,
                                                                    distance: distance,
                                                                    angle: angle,
                                                                    hasNewMessage: false,
                                                                    latitude: userLat,
                                                                    longitude: userLon
                                                                });
                                                            }
                                                        });
                                                        
                                                        // Update users list (current user + others)
                                                        setUsers([realUser, ...otherUsers]);
                                                        console.log('Users updated:', otherUsers.length, 'users found');
                                                    });
                                            }
                                            
                                            // Update user in Firestore with FUSED location
                                            await db.collection('users').doc(firebaseUser.uid).set({
                                                uid: firebaseUser.uid,
                                                displayName: firebaseUser.displayName,
                                                email: firebaseUser.email,
                                                photoURL: firebaseUser.photoURL,
                                                location: new firebase.firestore.GeoPoint(fusedLocation.latitude, fusedLocation.longitude),
                                                isOnline: true,
                                                lastSeen: firebase.firestore.FieldValue.serverTimestamp(),
                                                accuracy: fusedLocation.accuracy
                                            }, { merge: true });
                                            
                                            // Update current user location in state
                                            setCurrentUser(prev => prev ? ({
                                                ...prev,
                                                latitude: fusedLocation.latitude,
                                                longitude: fusedLocation.longitude
                                            }) : prev);
                                            
                                        } catch (error) {
                                            console.error('Error updating location:', error);
                                        }
                                    }
                                },
                                (error) => {
                                    console.error('Location error:', error);
                                    
                                    // Instead of alert, we could show a non-intrusive notification
                                    // For now, just log it
                                    let errorMessage = 'No se pudo obtener tu ubicaci√≥n.';
                                    
                                    switch(error.code) {
                                        case error.PERMISSION_DENIED:
                                            errorMessage = 'Permiso de ubicaci√≥n denegado.';
                                            break;
                                        case error.POSITION_UNAVAILABLE:
                                            errorMessage = 'Ubicaci√≥n no disponible.';
                                            break;
                                        case error.TIMEOUT:
                                            errorMessage = 'Tiempo de espera agotado.';
                                            break;
                                    }
                                    
                                    console.warn('‚ö†Ô∏è', errorMessage);
                                },
                                {
                                    enableHighAccuracy: true,  // ‚úÖ Alta precisi√≥n GPS
                                    timeout: 10000,            // 10 segundos timeout
                                    maximumAge: 0              // No usar cach√©
                                }
                            );
                            
                            // Cleanup on unmount
                            return () => {
                                navigator.geolocation.clearWatch(watchId);
                                if (usersUnsubscribe) usersUnsubscribe();
                                // Mark user as offline
                                db.collection('users').doc(firebaseUser.uid).update({
                                    isOnline: false,
                                    lastSeen: firebase.firestore.FieldValue.serverTimestamp()
                                }).catch(err => console.error('Error marking offline:', err));
                            };
                            
                        } else {
                            console.error('‚ùå Tu dispositivo no soporta geolocalizaci√≥n');
                            // Redirect to error page or show elegant message
                            window.location.href = 'auth.html';
                        }
                    } else {
                        // No user logged in, redirect to auth
                        console.log('No user logged in, redirecting...');
                        window.location.href = 'auth.html';
                    }
                });
                
                return () => unsubscribe();
            }, []);

            // Listen to device orientation (compass)
            useEffect(() => {
                let hasRequested = false;
                
                const handleOrientation = (event) => {
                    // alpha: rotation around z-axis (compass heading)
                    // iOS uses webkitCompassHeading, Android uses alpha
                    let heading = 0;
                    
                    if (event.webkitCompassHeading !== undefined) {
                        // iOS - direct compass heading
                        heading = event.webkitCompassHeading;
                    } else if (event.alpha !== null) {
                        // Android - calculate from alpha
                        heading = 360 - event.alpha;
                    }
                    
                    setDeviceHeading(heading);
                };
                
                const requestOrientationPermission = async () => {
                    if (hasRequested) return;
                    hasRequested = true;
                    
                    // Request permission on iOS 13+
                    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                        try {
                            const permissionState = await DeviceOrientationEvent.requestPermission();
                            if (permissionState === 'granted') {
                                window.addEventListener('deviceorientation', handleOrientation, true);
                                console.log('‚úÖ Br√∫jula activada (iOS)');
                            } else {
                                console.log('‚ùå Permiso de br√∫jula denegado');
                            }
                        } catch (error) {
                            console.error('Error requesting orientation permission:', error);
                        }
                    } else if (window.DeviceOrientationEvent) {
                        // Non-iOS or older iOS - no permission needed
                        window.addEventListener('deviceorientation', handleOrientation, true);
                        console.log('‚úÖ Br√∫jula activada');
                    } else {
                        console.log('‚ùå Br√∫jula no soportada');
                    }
                };
                
                // On iOS, we need a user gesture to request permission
                // Add a one-time click listener to the document
                const handleFirstClick = () => {
                    requestOrientationPermission();
                    document.removeEventListener('click', handleFirstClick);
                };
                
                // For iOS: wait for first click
                if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                    document.addEventListener('click', handleFirstClick);
                } else {
                    // For Android: start immediately
                    requestOrientationPermission();
                }
                
                return () => {
                    window.removeEventListener('deviceorientation', handleOrientation, true);
                    document.removeEventListener('click', handleFirstClick);
                };
            }, []);

            // ==========================================
            // SENSOR FUSION - Listen to Motion Sensors
            // ==========================================
            useEffect(() => {
                let motionTimeout;
                
                const handleMotion = (event) => {
                    const accel = event.accelerationIncludingGravity || event.acceleration;
                    
                    if (accel) {
                        // Calcular magnitud de aceleraci√≥n
                        const magnitude = Math.sqrt(
                            (accel.x || 0) ** 2 + 
                            (accel.y || 0) ** 2 + 
                            (accel.z || 0) ** 2
                        );
                        
                        // Detectar movimiento (threshold: 11 m/s¬≤ para filtrar gravedad)
                        const isMoving = magnitude > 11; // M√°s de 1.1g = movimiento
                        
                        // Obtener rotaci√≥n
                        const rotation = event.rotationRate || { alpha: 0, beta: 0, gamma: 0 };
                        
                        setSensorData(prev => ({
                            ...prev,
                            acceleration: {
                                x: accel.x || 0,
                                y: accel.y || 0,
                                z: accel.z || 0
                            },
                            rotation: {
                                alpha: rotation.alpha || 0,
                                beta: rotation.beta || 0,
                                gamma: rotation.gamma || 0
                            },
                            isMoving: isMoving,
                            lastMotionTime: Date.now()
                        }));
                        
                        // Auto-desactivar "isMoving" despu√©s de 2 segundos sin movimiento
                        clearTimeout(motionTimeout);
                        if (isMoving) {
                            motionTimeout = setTimeout(() => {
                                setSensorData(prev => ({ ...prev, isMoving: false }));
                            }, 2000);
                        }
                    }
                };
                
                // Request permission on iOS 13+
                const requestMotionPermission = async () => {
                    if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                        try {
                            const permissionState = await DeviceMotionEvent.requestPermission();
                            if (permissionState === 'granted') {
                                window.addEventListener('devicemotion', handleMotion, true);
                                console.log('‚úÖ Motion sensors activated');
                            }
                        } catch (error) {
                            console.error('Error requesting motion permission:', error);
                        }
                    } else if (window.DeviceMotionEvent) {
                        window.addEventListener('devicemotion', handleMotion, true);
                        console.log('‚úÖ Motion sensors activated');
                    }
                };
                
                // Try to activate on first user interaction
                const activateOnClick = () => {
                    requestMotionPermission();
                    document.removeEventListener('click', activateOnClick);
                };
                
                document.addEventListener('click', activateOnClick);
                
                return () => {
                    window.removeEventListener('devicemotion', handleMotion, true);
                    document.removeEventListener('click', activateOnClick);
                    clearTimeout(motionTimeout);
                };
            }, []);

            // Update heading when deviceHeading changes
            useEffect(() => {
                setSensorData(prev => ({ ...prev, heading: deviceHeading }));
            }, [deviceHeading]);

            // ==========================================
            // ULTRASONIC AUTO-ACTIVATION
            // ==========================================
            useEffect(() => {
                if (!currentUser || users.length === 0) return;
                
                // Verificar si hay usuarios a menos de 5 metros
                const nearbyUsers = users.filter(u => 
                    u.id !== currentUser.id && u.distance > 0 && u.distance < 5
                );
                
                if (nearbyUsers.length > 0 && !ultrasonicActive) {
                    // Activar sistema ultras√≥nico
                    console.log(`üîä ${nearbyUsers.length} usuario(s) a <5m, activando ultrasonido...`);
                    startUltrasonicDetector();
                } else if (nearbyUsers.length === 0 && ultrasonicActive) {
                    // Desactivar si no hay nadie cerca
                    console.log('‚ùå No hay usuarios a <5m, desactivando ultrasonido...');
                    stopUltrasonicDetector();
                }
            }, [users, currentUser]);

            // ==========================================
            // ULTRASONIC EMISSION - Emitir se√±al peri√≥dicamente
            // ==========================================
            useEffect(() => {
                if (!ultrasonicActive || !currentUser) return;
                
                // Emitir se√±al cada 1 segundo
                const emitInterval = setInterval(() => {
                    emitUltrasonicSignal(currentUser.id);
                }, 1000);
                
                // Emitir inmediatamente al activarse
                emitUltrasonicSignal(currentUser.id);
                
                return () => clearInterval(emitInterval);
            }, [ultrasonicActive, currentUser]);

            // ==========================================
            // CLEANUP - Detener ultrasonido al desmontar
            // ==========================================
            useEffect(() => {
                return () => {
                    if (ultrasonicActive) {
                        console.log('üßπ Cleanup: Deteniendo sistema ultras√≥nico');
                        stopUltrasonicDetector();
                    }
                };
            }, []);

            // Recalculate distances when user location changes
            useEffect(() => {
                if (!userLocation || !currentUser) return;
                
                // Update distances and angles for all users based on new location
                setUsers(prevUsers => {
                    return prevUsers.map(user => {
                        if (user.id === currentUser.id) {
                            // Current user - just update location
                            return {
                                ...user,
                                latitude: userLocation.latitude,
                                longitude: userLocation.longitude
                            };
                        } else if (user.latitude && user.longitude) {
                            // Other users - recalculate distance and angle
                            const gpsDistance = calculateDistance(
                                userLocation.latitude,
                                userLocation.longitude,
                                user.latitude,
                                user.longitude
                            );
                            
                            // Aplicar Hybrid Precision: GPS + Ultrasonido si est√° cerca
                            const finalDistance = getFinalDistance(gpsDistance, user.id);
                            
                            const angle = Math.round(
                                calculateBearing(
                                    userLocation.latitude,
                                    userLocation.longitude,
                                    user.latitude,
                                    user.longitude
                                )
                            );
                            
                            return {
                                ...user,
                                distance: Math.round(finalDistance * 10) / 10, // 1 decimal de precisi√≥n
                                angle
                            };
                        }
                        return user;
                    });
                });
            }, [userLocation, currentUser]);

            // Calculate direction to point towards closest user with message
            const getDirectionToTarget = () => {
                if (!currentUser) return 0;
                const usersWithMessages = users.filter(u => u.hasNewMessage && u.id !== currentUser.id && u.distance <= radius);
                if (usersWithMessages.length === 0) return 0;
                
                // Get closest user with message
                const closestUser = usersWithMessages.reduce((prev, current) => 
                    prev.distance < current.distance ? prev : current
                );
                
                // The indicator should point to the target's actual world position
                // Since the avatar rotates with deviceHeading to stay upright,
                // and we want the indicator to point to the absolute direction,
                // we just return the target's angle (no adjustment needed)
                return closestUser.angle;
            };

            // Play radar beep with volume based on proximity
            const playRadarBeep = (distance, hasMessage) => {
                if (!audioContext || !hasMessage) return;
                
                // Calculate volume based on how close the person is to current radius
                // If person is at edge of radar or outside: quiet
                // If person is well within radar: louder
                const proximityRatio = distance / radius;
                let volume = 0;
                
                if (proximityRatio <= 1) {
                    // Person is within radar range
                    // Volume increases as they get closer to center
                    volume = Math.max(0.1, (1 - proximityRatio) * 0.6);
                } else {
                    // Person is outside radar range
                    volume = 0;
                }
                
                // Create beep sound (like Dragon Ball scouter)
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 800; // High pitch beep
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.15);
            };

            // Continuous radar beep for users with messages
            useEffect(() => {
                if (!audioContext || !locationPermission) return;
                
                let sweepAngle = 0;
                const sweepSpeed = 360 / 6000; // 360 degrees in 6 seconds (matches CSS animation)
                const lastBeepTime = {}; // Track last beep time for each user
                const BRIGHTEST_OFFSET = 40; // The brightest part of the sweep is at +40 degrees from sweep origin
                
                const checkSweepInterval = setInterval(() => {
                    sweepAngle = (sweepAngle + (sweepSpeed * 50)) % 360; // Update every 50ms
                    
                    users.forEach(user => {
                        if (currentUser && user.hasNewMessage && user.id !== currentUser.id && user.distance <= radius) {
                            const userAngle = user.angle;
                            
                            // Calculate where the brightest part of the sweep is
                            const brightestPartAngle = (sweepAngle + BRIGHTEST_OFFSET) % 360;
                            
                            // Check if the brightest part is passing over this user
                            const angleDiff = Math.abs(brightestPartAngle - userAngle);
                            const normalizedDiff = Math.min(angleDiff, 360 - angleDiff);
                            
                            // Very tight detection window (5 degrees) for precise beeping at brightest point
                            if (normalizedDiff < 5) {
                                // Only beep if we haven't beeped for this user in the last 5.8 seconds
                                const now = Date.now();
                                if (!lastBeepTime[user.id] || now - lastBeepTime[user.id] > 5800) {
                                    playRadarBeep(user.distance, true);
                                    lastBeepTime[user.id] = now;
                                }
                            }
                        }
                    });
                }, 50); // Check every 50ms for smooth detection
                
                return () => clearInterval(checkSweepInterval);
            }, [users, radius, audioContext, locationPermission, currentUser]);

            const handleSliderMouseDown = (e) => {
                e.preventDefault();
                setIsDraggingDial(true);
                handleSliderMove(e);
            };

            const handleSliderMove = (e) => {
                const slider = document.querySelector('.range-slider-track');
                if (!slider) return;
                
                const rect = slider.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                
                // Calculate position relative to slider
                let position = (clientX - rect.left) / rect.width;
                position = Math.max(0, Math.min(1, position)); // Clamp 0-1
                
                // Map 0-1 to 5-50 meters
                const newRadius = Math.round(5 + position * 45);
                setRadius(newRadius);
            };

            const handleSliderMouseMove = (e) => {
                if (!isDraggingDial) return;
                handleSliderMove(e);
            };

            const handleSliderMouseUp = () => {
                setIsDraggingDial(false);
            };

            useEffect(() => {
                if (isDraggingDial) {
                    window.addEventListener('mousemove', handleSliderMouseMove);
                    window.addEventListener('mouseup', handleSliderMouseUp);
                    window.addEventListener('touchmove', handleSliderMouseMove);
                    window.addEventListener('touchend', handleSliderMouseUp);
                    
                    return () => {
                        window.removeEventListener('mousemove', handleSliderMouseMove);
                        window.removeEventListener('mouseup', handleSliderMouseUp);
                        window.removeEventListener('touchmove', handleSliderMouseMove);
                        window.removeEventListener('touchend', handleSliderMouseUp);
                    };
                }
            }, [isDraggingDial]);

            const requestLocation = () => {
                setLocationPermission(true);
            };

            const updateThought = async () => {
                if (currentUser && thought.trim()) {
                    const thoughtData = {
                        text: thought.trim(),
                        timestamp: Date.now()
                    };
                    
                    // Update local state immediately for instant feedback
                    const updatedCurrentUser = { 
                        ...currentUser, 
                        thought: thoughtData.text, 
                        thoughtTimestamp: thoughtData.timestamp 
                    };
                    
                    setCurrentUser(updatedCurrentUser);
                    setUsers(prevUsers => prevUsers.map(u => 
                        u.id === currentUser.id ? updatedCurrentUser : u
                    ));
                    
                    // Clear input immediately
                    setThought('');
                    
                    // Save to Firebase if user is authenticated
                    const user = auth.currentUser;
                    if (user) {
                        try {
                            await db.collection('users').doc(user.uid).set({
                                thought: thoughtData.text,
                                thoughtTimestamp: firebase.firestore.FieldValue.serverTimestamp()
                            }, { merge: true });
                            
                            console.log('‚úÖ Pensamiento publicado:', thoughtData.text);
                        } catch (error) {
                            console.error('Error updating thought:', error);
                        }
                    }
                }
            };
            
            // Check if thought is expired (24 hours)
            const isThoughtExpired = (timestamp) => {
                if (!timestamp) return true;
                const now = Date.now();
                const thoughtTime = timestamp.toMillis ? timestamp.toMillis() : timestamp;
                const hoursPassed = (now - thoughtTime) / (1000 * 60 * 60);
                return hoursPassed >= 24;
            };

            const handleAvatarClick = (user) => {
                if (currentUser && user.id !== currentUser.id) {
                    if (user.hasStory) {
                        setViewingStory(user);
                    } else {
                        setSelectedUser(user);
                        // Mark message as read
                        setUsers(users.map(u => 
                            u.id === user.id ? { ...u, hasNewMessage: false } : u
                        ));
                    }
                }
            };

            const sendMessage = () => {
                if (!messageInput.trim() || !selectedUser) return;

                const chatKey = `${currentUser.id}-${selectedUser.id}`;
                const newMessage = {
                    id: Date.now(),
                    sender: currentUser.id,
                    content: messageInput,
                    timestamp: new Date()
                };

                setMessages(prev => ({
                    ...prev,
                    [chatKey]: [...(prev[chatKey] || []), newMessage]
                }));

                if (!chats[chatKey]) {
                    setChats(prev => ({ ...prev, [chatKey]: true }));
                }

                setMessageInput('');
            };

            if (!locationPermission) {
                return (
                    <div className="location-permission">
                        <div className="permission-card">
                            <svg className="permission-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
                            </svg>
                            <h2>Ubicaci√≥n Requerida</h2>
                            <p>Radar Social necesita acceso a tu ubicaci√≥n para mostrarte personas cercanas y conectar con ellas.</p>
                            <button className="permission-btn" onClick={requestLocation}>
                                Permitir Ubicaci√≥n
                            </button>
                        </div>
                    </div>
                );
            }

            return (
                <>
                    <div className="header">
                        <svg className="header-icon" onClick={() => setShowSidebar(true)} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 12h16M4 18h16" />
                        </svg>
                        <div style={{ width: 28 }}></div>
                        <svg className="header-icon" onClick={() => setShowProfile(true)} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
                        </svg>
                    </div>

                    <div className="main-container">
                        <div className="radar-container">
                            {/* People Counter */}
                            <div className="radar-info">
                                <div className="radar-info-count">
                                    {currentUser ? users.filter(u => u.id !== currentUser.id && u.distance <= radius).length : 0}
                                </div>
                                <div className="radar-info-title">Personas cerca de ti</div>
                                <div className={`precision-badge ${ultrasonicActive && ultrasonicDetections.nearby ? 'ultrasonic-active' : ''}`}>
                                    {ultrasonicActive && ultrasonicDetections.nearby ? 'üîä' : (sensorData.isMoving ? 'üß†' : 'üìç')} 
                                    {' '}¬±{ultrasonicActive && ultrasonicDetections.nearby ? 
                                        (ultrasonicDetections.nearby < 1 ? '0.5' : ultrasonicDetections.nearby.toFixed(1)) : 
                                        locationAccuracy.toFixed(1)
                                    }m
                                </div>
                            </div>

                            <div className="radar-bg">
                                <div className="radar-grid">
                                    {(() => {
                                        // Generate circles based on current radius
                                        const circles = [];
                                        const numCircles = 5;
                                        const interval = radius / numCircles;
                                        
                                        for (let i = 1; i <= numCircles; i++) {
                                            const meters = Math.round(interval * i);
                                            const percent = (i / numCircles) * 100;
                                            
                                            circles.push(
                                                <div key={`circle-${i}`}>
                                                    <div
                                                        className="radar-circle"
                                                        style={{
                                                            width: `${percent}%`,
                                                            height: `${percent}%`,
                                                            transition: 'all 0.4s ease'
                                                        }}
                                                    />
                                                    <div 
                                                        className="distance-label"
                                                        style={{
                                                            top: `${50 - (percent / 2)}%`,
                                                            left: '50%',
                                                            transition: 'all 0.4s ease'
                                                        }}
                                                    >
                                                        {meters}m
                                                    </div>
                                                </div>
                                            );
                                        }
                                        return circles;
                                    })()}
                                    {[0, 45, 90, 135].map(angle => (
                                        <div
                                            key={angle}
                                            className="radar-line"
                                            style={{ transform: `translateX(-50%) rotate(${angle}deg)` }}
                                        />
                                    ))}
                                    
                                    <div className="radar-sweep"></div>
                                </div>

                                {users
                                    .filter(user => currentUser && (user.id === currentUser.id || user.distance <= radius))
                                    .map(user => {
                                        const isCenter = currentUser && user.id === currentUser.id;
                                        
                                        // Calculate position based on distance, angle, and current zoom (radius)
                                        let x = 0, y = 0;
                                        if (!isCenter) {
                                            // IMPROVED POSITIONING ALGORITHM
                                            // Dead zone: minimum 15% (prevents overlap with center avatar)
                                            // Max zone: 45% (uses more radar space)
                                            // Formula: maps distance to 15%-45% range
                                            
                                            const MIN_PERCENTAGE = 15; // Dead zone around center
                                            const MAX_PERCENTAGE = 45; // Max usable area
                                            
                                            // Linear mapping: 0m ‚Üí 15%, radius ‚Üí 45%
                                            let percentage = MIN_PERCENTAGE + (user.distance / radius) * (MAX_PERCENTAGE - MIN_PERCENTAGE);
                                            percentage = Math.min(percentage, MAX_PERCENTAGE);
                                            
                                            const angleRad = (user.angle - 90) * (Math.PI / 180);
                                            x = percentage * Math.cos(angleRad);
                                            y = percentage * Math.sin(angleRad);
                                        }
                                        
                                        // Avatar sizing
                                        // Center avatar: fixed medium size
                                        // Other users: fixed small size (consistent regardless of zoom)
                                        let scale = 1.0;
                                        if (!isCenter) {
                                            // Fixed small size for all other avatars (like when radius is at 50m)
                                            scale = 0.6;
                                        }
                                        // Center avatar stays at normal size (scale = 1.0)
                                        // Center avatar is always fixed size (no scaling)
                                        
                                        return (
                                            <div
                                                key={user.id}
                                                className={`avatar-container ${isCenter ? 'center-avatar-fixed' : ''}`}
                                                style={isCenter ? {} : {
                                                    left: `calc(50% + ${x}%)`,
                                                    top: `calc(50% + ${y}%)`,
                                                    transform: `scale(${scale})`,
                                                    opacity: user.distance <= radius ? 1 : 0,
                                                    zIndex: 10 - Math.floor(user.distance / 10),
                                                    transition: 'left 2s ease-out, top 2s ease-out, transform 0.4s ease, opacity 0.4s ease'
                                                }}
                                                onClick={() => handleAvatarClick(user)}
                                            >
                                                <div className={`avatar-wrapper ${isCenter ? 'center-avatar' : 'regular-avatar'}`}>
                                                    {user.thought && (
                                                        <div className="avatar-thought">{user.thought}</div>
                                                    )}
                                                    <div 
                                                        className={`avatar-ring ${
                                                            user.hasNewMessage ? 'new-message' : 
                                                            user.hasStory ? 'has-story' : 'no-story'
                                                        }`}
                                                        style={isCenter ? { transform: `rotate(${deviceHeading}deg)` } : {}}
                                                    >
                                                        <div className="avatar-img-wrapper" style={isCenter ? { transform: `rotate(${-deviceHeading}deg)` } : {}}>
                                                            <img src={user.photo} alt={user.name} className="avatar-img" />
                                                        </div>
                                                        {isCenter && (
                                                            <div className="direction-indicator" />
                                                        )}
                                                        {user.hasNewMessage && (
                                                            <div className="message-badge">1</div>
                                                        )}
                                                    </div>
                                                    {!isCenter && (
                                                        <>
                                                            <div className="avatar-name">{user.name}</div>
                                                            <div className="avatar-distance">
                                                                {user.distance < 1 && ultrasonicActive ? 
                                                                    `${user.distance.toFixed(1)} m üîä` : 
                                                                    `${Math.round(user.distance)} m`
                                                                }
                                                            </div>
                                                        </>
                                                    )}
                                                </div>
                                            </div>
                                        );
                                    })}

                                {/* Compass Cardinal Directions - Fixed decorative */}
                                <div className="compass-label compass-n">N</div>
                                <div className="compass-label compass-s">S</div>
                                <div className="compass-label compass-e">E</div>
                                <div className="compass-label compass-o">O</div>
                            </div>

                            {/* Horizontal Range Slider */}
                            <div className="range-slider-container">
                                <div className="range-slider-label">
                                    <div className="range-slider-title">Radio de B√∫squeda</div>
                                    <div className="range-slider-value">{radius}m</div>
                                </div>
                                
                                <div 
                                    className="range-slider-track"
                                    onMouseDown={handleSliderMouseDown}
                                    onTouchStart={handleSliderMouseDown}
                                >
                                    <div 
                                        className="range-slider-progress"
                                        style={{ width: `${((radius - 5) / 45) * 100}%` }}
                                    />
                                    <div 
                                        className="range-slider-thumb"
                                        style={{ left: `${((radius - 5) / 45) * 100}%` }}
                                    />
                                </div>
                                
                                <div className="range-slider-marks">
                                    <div className="range-slider-mark">5m</div>
                                    <div className="range-slider-mark">15m</div>
                                    <div className="range-slider-mark">30m</div>
                                    <div className="range-slider-mark">50m</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div className="bottom-bar">
                        <div className="thought-input-container">
                            <input
                                type="text"
                                className="thought-input"
                                placeholder="Escribe un pensamiento..."
                                value={thought}
                                onChange={(e) => setThought(e.target.value.slice(0, 50))}
                                onKeyPress={(e) => {
                                    if (e.key === 'Enter') {
                                        updateThought();
                                    }
                                }}
                                maxLength={50}
                            />
                            <div className="send-button" onClick={updateThought}>
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" />
                                </svg>
                            </div>
                        </div>
                    </div>

                    {selectedUser && (
                        <div className={`chat-overlay ${selectedUser ? 'active' : ''}`}>
                            <div className="chat-header">
                                <svg onClick={() => setSelectedUser(null)} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2.5} d="M15 19l-7-7 7-7" />
                                </svg>
                                <div className="chat-user-info">
                                    <img src={selectedUser.photo} alt={selectedUser.name} className="chat-user-avatar" />
                                    <div className="chat-user-details">
                                        <h3>{selectedUser.name}</h3>
                                        <p>{selectedUser.distance} m de distancia</p>
                                    </div>
                                </div>
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <circle cx="12" cy="12" r="1.5"/>
                                    <circle cx="12" cy="5" r="1.5"/>
                                    <circle cx="12" cy="19" r="1.5"/>
                                </svg>
                            </div>

                            {selectedUser.thought && (
                                <div className="chat-thought-display">
                                    <span style={{ fontSize: '17px' }}>‚ö°</span>
                                    {selectedUser.thought}
                                </div>
                            )}

                            <div className="chat-content">
                                <div className="chat-messages">
                                    {!chats[`${currentUser.id}-${selectedUser.id}`] && (
                                        <div className="chat-info">
                                            Esta persona te encontr√≥ en un radio de {radius} m y te envi√≥ un mensaje.
                                        </div>
                                    )}

                                    {messages[`${currentUser.id}-${selectedUser.id}`]?.map(msg => (
                                        <div
                                            key={msg.id}
                                            className={`message ${msg.sender === currentUser.id ? 'sent' : 'received'}`}
                                        >
                                            {msg.content}
                                        </div>
                                    ))}
                                </div>

                                {!chats[`${currentUser.id}-${selectedUser.id}`] && (
                                    <div className="chat-info" style={{ margin: '0 16px 12px' }}>
                                        Si respondes, se abrir√° un chat con esta persona.
                                    </div>
                                )}

                                <div className="chat-input-container">
                                    <div className="btn-round" style={{ width: '46px', height: '46px' }}>
                                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
                                        </svg>
                                    </div>
                                    <textarea
                                        className="chat-input"
                                        placeholder="Escribe tu respuesta..."
                                        value={messageInput}
                                        onChange={(e) => setMessageInput(e.target.value)}
                                        rows="1"
                                    />
                                    <button
                                        className="chat-send-btn"
                                        onClick={sendMessage}
                                        disabled={!messageInput.trim()}
                                    >
                                        <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" />
                                        </svg>
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Backdrop for sidebar */}
                    <div className={`overlay-backdrop ${showSidebar ? 'active' : ''}`} onClick={() => setShowSidebar(false)}></div>

                    {/* Sidebar */}
                    <div className={`sidebar ${showSidebar ? 'active' : ''}`}>
                        <div className="sidebar-header">
                            <h2>Men√∫</h2>
                            <svg onClick={() => setShowSidebar(false)} style={{ cursor: 'pointer', width: '24px', height: '24px', color: '#8b949e' }} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2.5} d="M6 18L18 6M6 6l12 12" />
                            </svg>
                        </div>
                        <div className="sidebar-content">
                            <div className="sidebar-item" onClick={() => { setShowSidebar(false); setShowProfile(true); }}>
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
                                </svg>
                                <span>Mi Perfil</span>
                            </div>
                            <div className="sidebar-item">
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z" />
                                </svg>
                                <span>Amigos</span>
                            </div>
                            <div className="sidebar-item">
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
                                </svg>
                                <span>Mensajes</span>
                            </div>
                            <div className="sidebar-item">
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                                </svg>
                                <span>Configuraci√≥n</span>
                            </div>
                            <div className="sidebar-item">
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                                </svg>
                                <span>Ayuda</span>
                            </div>
                        </div>
                    </div>

                    {/* Profile */}
                    <div className={`profile-overlay ${showProfile ? 'active' : ''}`}>
                        <div className="profile-header">
                            <svg onClick={() => setShowProfile(false)} style={{ cursor: 'pointer', width: '26px', height: '26px', color: '#8b949e' }} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2.5} d="M15 19l-7-7 7-7" />
                            </svg>
                            <h2 style={{ fontSize: '18px', fontWeight: 600, color: '#f0f6fc' }}>Mi Perfil</h2>
                        </div>
                        <div className="profile-content">
                            <div className="profile-avatar-section">
                                <img src={currentUser?.photo || 'https://i.pravatar.cc/150?img=33'} alt="Profile" className="profile-avatar-large" />
                                <div className="profile-name">{currentUser?.name || 'Usuario'}</div>
                                <div className="profile-bio">{currentUser?.thought || 'Sin estado'}</div>
                            </div>
                            
                            <div className="profile-section">
                                <div className="profile-section-title">Informaci√≥n Personal</div>
                                <div className="profile-field">
                                    <span className="profile-field-label">Nombre</span>
                                    <span className="profile-field-value">{currentUser?.name || 'Usuario'}</span>
                                </div>
                                {currentUser?.email && (
                                    <div className="profile-field">
                                        <span className="profile-field-label">Email</span>
                                        <span className="profile-field-value">{currentUser.email}</span>
                                    </div>
                                )}
                                <div className="profile-field">
                                    <span className="profile-field-label">Edad</span>
                                    <span className="profile-field-value">{currentUser?.age || 25} a√±os</span>
                                </div>
                                <div className="profile-field">
                                    <span className="profile-field-label">Ubicaci√≥n</span>
                                    <span className="profile-field-value">Panam√°, PA</span>
                                </div>
                            </div>

                            <div className="profile-section">
                                <div className="profile-section-title">Estad√≠sticas</div>
                                <div className="profile-field">
                                    <span className="profile-field-label">Conexiones</span>
                                    <span className="profile-field-value">{users.length - 1} personas cercanas</span>
                                </div>
                                <div className="profile-field">
                                    <span className="profile-field-label">Chats activos</span>
                                    <span className="profile-field-value">{Object.keys(chats).length}</span>
                                </div>
                                <div className="profile-field">
                                    <span className="profile-field-label">Estados compartidos</span>
                                    <span className="profile-field-value">3 hoy</span>
                                </div>
                            </div>

                            <div className="profile-section">
                                <button 
                                    onClick={async () => {
                                        if (confirm('¬øCerrar sesi√≥n? Dejar√°s de aparecer en el radar.')) {
                                            try {
                                                await auth.signOut();
                                                window.location.href = 'auth.html';
                                            } catch (error) {
                                                console.error('Error signing out:', error);
                                            }
                                        }
                                    }}
                                    style={{
                                        width: '100%',
                                        padding: '14px',
                                        background: 'rgba(239, 68, 68, 0.1)',
                                        border: '1px solid rgba(239, 68, 68, 0.3)',
                                        borderRadius: '12px',
                                        color: '#ef4444',
                                        fontSize: '15px',
                                        fontWeight: 600,
                                        cursor: 'pointer',
                                        transition: 'all 0.2s ease',
                                        display: 'flex',
                                        alignItems: 'center',
                                        justifyContent: 'center',
                                        gap: '8px'
                                    }}
                                    onMouseOver={(e) => {
                                        e.target.style.background = 'rgba(239, 68, 68, 0.15)';
                                        e.target.style.borderColor = 'rgba(239, 68, 68, 0.4)';
                                    }}
                                    onMouseOut={(e) => {
                                        e.target.style.background = 'rgba(239, 68, 68, 0.1)';
                                        e.target.style.borderColor = 'rgba(239, 68, 68, 0.3)';
                                    }}
                                >
                                    <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" />
                                    </svg>
                                    Cerrar Sesi√≥n
                                </button>
                            </div>
                        </div>
                    </div>

                    {/* Story Viewer */}
                    {viewingStory && (
                        <div className={`story-viewer ${viewingStory ? 'active' : ''}`}>
                            <div className="story-circle">
                                <div className="story-close" onClick={() => setViewingStory(null)}>
                                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2.5} d="M6 18L18 6M6 6l12 12" />
                                    </svg>
                                </div>
                                <div className="story-user-info">
                                    <img src={viewingStory.photo} alt={viewingStory.name} className="story-user-avatar" />
                                    <span className="story-user-name">{viewingStory.name}</span>
                                </div>
                                <img 
                                    src={viewingStory.photo} 
                                    alt={`${viewingStory.name}'s story`} 
                                    className="story-image"
                                />
                            </div>
                        </div>
                    )}
                </>
            );
        }

        ReactDOM.render(<RadarSocialApp />, document.getElementById('root'));

        // Register Service Worker for PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/service-worker.js')
                    .then(registration => {
                        console.log('Service Worker registrado:', registration);
                    })
                    .catch(error => {
                        console.log('Error al registrar Service Worker:', error);
                    });
            });
        }
    </script>
</body>
</html>
