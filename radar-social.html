<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Radar Social</title>
    
    <!-- PWA Meta Tags -->
    <meta name="description" content="Encuentra y conecta con personas cerca de ti usando radar geolocalizado">
    <meta name="theme-color" content="#0d1117">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Radar Social">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icon-192.png">
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-storage-compat.js"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #0d1117;
            color: #e6edf3;
            overflow-x: hidden;
            position: fixed;
            width: 100%;
            height: 100vh;
        }

        #root {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            background: linear-gradient(180deg, rgba(22, 27, 34, 0.98) 0%, rgba(17, 21, 27, 0.95) 100%);
            backdrop-filter: blur(20px);
            position: relative;
            z-index: 100;
            border-bottom: 1px solid rgba(48, 54, 61, 0.3);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .header-left {
            position: relative;
        }

        .online-badge-menu {
            position: fixed;
            top: 65px;
            left: 20px;
            padding: 4px 10px;
            background: rgba(34, 197, 94, 0.15);
            border: 1px solid rgba(34, 197, 94, 0.4);
            border-radius: 8px;
            font-size: 8px;
            font-weight: 700;
            color: #22c55e;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            display: flex;
            align-items: center;
            gap: 4px;
            backdrop-filter: blur(12px);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            z-index: 99;
        }

        .online-badge-dot {
            width: 5px;
            height: 5px;
            background: #22c55e;
            border-radius: 50%;
            animation: badgePulse 2s ease-in-out infinite;
        }

        @keyframes badgePulse {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7);
                opacity: 1;
            }
            50% {
                box-shadow: 0 0 0 3px rgba(34, 197, 94, 0);
                opacity: 0.7;
            }
        }

        .header-icon {
            width: 28px;
            height: 28px;
            cursor: pointer;
            color: #c9d1d9;
            transition: all 0.2s ease;
            opacity: 0.9;
        }

        .header-icon:hover {
            opacity: 1;
            color: #f0f6fc;
        }

        .header-title {
            font-size: 22px;
            font-weight: 600;
            letter-spacing: -0.3px;
            color: #f0f6fc;
        }

        .main-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: visible;
            padding: 20px;
            padding-bottom: 140px; /* Space for slider and thought input */
            background: radial-gradient(ellipse at center, rgba(22, 27, 34, 0.5) 0%, #0d1117 70%);
        }

        .radar-container {
            position: relative;
            width: min(85vw, 400px);
            height: min(85vw, 400px);
            margin: -20px auto 0; /* Move radar up slightly */
            overflow: visible;
        }

        .radar-container::before {
            content: '';
            position: absolute;
            inset: -14px;
            border-radius: 50%;
            background: linear-gradient(145deg, rgba(48, 58, 70, 0.8) 0%, rgba(28, 35, 45, 0.9) 100%);
            box-shadow: 
                inset 0 3px 8px rgba(255, 255, 255, 0.12),
                inset 0 -4px 8px rgba(0, 0, 0, 0.7),
                0 8px 32px rgba(0, 0, 0, 0.7),
                0 0 0 1px rgba(56, 189, 98, 0.15),
                0 0 20px rgba(56, 189, 98, 0.08);
            z-index: -1;
        }

        .radar-bg {
            position: absolute;
            inset: 0;
            border-radius: 50%;
            background: radial-gradient(circle at 45% 45%, 
                rgba(18, 38, 26, 1) 0%,
                rgba(12, 28, 18, 1) 40%,
                rgba(8, 18, 12, 1) 70%,
                rgba(13, 17, 23, 1) 100%
            );
            border: 1px solid rgba(48, 54, 61, 0.6);
            box-shadow: 
                0 0 0 1px rgba(22, 27, 34, 0.8),
                0 8px 32px rgba(0, 0, 0, 0.6),
                inset 0 0 80px rgba(0, 0, 0, 0.5),
                inset 0 1px 1px rgba(255, 255, 255, 0.02);
            overflow: visible;
        }

        .radar-content-rotatable {
            position: absolute;
            inset: 0;
            border-radius: 50%;
            transition: transform 0.3s ease;
        }

        .radar-grid {
            position: absolute;
            inset: 0;
            border-radius: 50%;
            overflow: hidden;
        }

        .radar-circle {
            position: absolute;
            border-radius: 50%;
            border: 1px solid rgba(56, 189, 98, 0.08);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .distance-label {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(139, 148, 158, 0.5);
            font-size: 11px;
            font-weight: 600;
            pointer-events: none;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
        }

        .radar-line {
            position: absolute;
            width: 1px;
            height: 100%;
            background: rgba(56, 189, 98, 0.06);
            top: 0;
            left: 50%;
            transform-origin: center;
        }

        .radar-sweep {
            position: absolute;
            width: 200%;
            height: 200%;
            top: -50%;
            left: -50%;
            background: conic-gradient(
                from 0deg,
                rgba(56, 189, 98, 0.05) 0deg,
                rgba(56, 189, 98, 0.15) 20deg,
                rgba(56, 189, 98, 0.25) 40deg,
                transparent 60deg,
                transparent 360deg
            );
            animation: radarSweep 6s linear infinite;
            pointer-events: none;
            border-radius: 50%;
            transform-origin: center;
        }

        @keyframes radarSweep {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Horizontal Range Slider - Integrated Design */
        .range-slider-container {
            position: fixed;
            left: 50%;
            bottom: 125px;
            transform: translateX(-50%);
            z-index: 50;
            width: 300px;
            padding: 12px 0;
        }

        .range-slider-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding: 0 4px;
        }

        .range-slider-title {
            font-size: 11px;
            font-weight: 600;
            color: rgba(139, 148, 158, 0.7);
            text-transform: uppercase;
            letter-spacing: 0.8px;
        }

        .range-slider-value {
            font-size: 18px;
            font-weight: 700;
            color: #38bd62;
            letter-spacing: -0.5px;
            text-shadow: 0 0 8px rgba(56, 189, 98, 0.4);
        }

        .range-slider-track {
            position: relative;
            width: 100%;
            height: 4px;
            background: rgba(48, 54, 61, 0.4);
            border-radius: 2px;
            overflow: visible;
            cursor: pointer;
        }

        .range-slider-progress {
            position: absolute;
            height: 100%;
            background: linear-gradient(90deg, rgba(56, 189, 98, 0.6) 0%, #38bd62 100%);
            border-radius: 2px;
            transition: width 0.2s ease;
            box-shadow: 0 0 12px rgba(56, 189, 98, 0.5);
        }

        .range-slider-thumb {
            position: absolute;
            top: 50%;
            width: 18px;
            height: 18px;
            background: linear-gradient(145deg, #38bd62 0%, #2ea556 100%);
            border: 3px solid #0d1117;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            cursor: grab;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 
                0 2px 8px rgba(0, 0, 0, 0.4),
                0 0 16px rgba(56, 189, 98, 0.6);
        }

        .range-slider-thumb:active {
            cursor: grabbing;
            transform: translate(-50%, -50%) scale(1.2);
            box-shadow: 
                0 3px 12px rgba(0, 0, 0, 0.5),
                0 0 20px rgba(56, 189, 98, 0.8);
        }

        .range-slider-marks {
            display: flex;
            justify-content: space-between;
            margin-top: 6px;
            padding: 0 4px;
        }

        .range-slider-mark {
            font-size: 9px;
            color: rgba(139, 148, 158, 0.4);
            font-weight: 500;
        }

        .avatar-container {
            position: absolute;
            cursor: pointer;
            z-index: 10;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        .avatar-container:active {
            transform: scale(0.94);
        }

        .avatar-wrapper {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            transform: translate(-50%, -50%);
            transform-origin: center center;
        }

        .avatar-ring {
            border-radius: 50%;
            padding: 2.5px;
            position: relative;
            flex-shrink: 0;
        }

        .avatar-ring.has-story {
            background: linear-gradient(135deg, #f59e0b 0%, #f97316 35%, #ec4899 70%, #a855f7 100%);
        }

        .avatar-ring.no-story {
            background: rgba(71, 85, 105, 0.5);
        }

        .avatar-ring.new-message {
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            animation: messagePulse 1.5s ease-in-out infinite;
        }

        @keyframes messagePulse {
            0%, 100% { 
                opacity: 1;
                box-shadow: 0 0 16px rgba(251, 191, 36, 0.4);
            }
            50% { 
                opacity: 0.75;
                box-shadow: 0 0 24px rgba(251, 191, 36, 0.6);
            }
        }

        .avatar-img-wrapper {
            border-radius: 50%;
            background: #0d1117;
            border: 2.5px solid #0d1117;
            overflow: hidden;
            position: relative;
        }

        .avatar-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .avatar-thought {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(22, 27, 34, 0.95);
            color: #e6edf3;
            padding: 5px 11px;
            border-radius: 9px;
            font-size: 12px;
            font-weight: 500;
            white-space: nowrap;
            border: 1px solid rgba(48, 54, 61, 0.6);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            max-width: 110px;
            overflow: hidden;
            text-overflow: ellipsis;
            letter-spacing: -0.1px;
            margin-bottom: 4px;
        }

        .avatar-name {
            font-size: 14px;
            font-weight: 600;
            color: #f0f6fc;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.9);
            letter-spacing: -0.2px;
            margin-top: 3px;
        }

        .avatar-distance {
            font-size: 12px;
            color: #8b949e;
            font-weight: 500;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.9);
            margin-top: 1px;
        }

        .message-badge {
            position: absolute;
            top: -2px;
            right: -2px;
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, #f59e0b 0%, #dc2626 100%);
            border-radius: 50%;
            border: 2px solid #0d1117;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 700;
            color: #fff;
            box-shadow: 0 2px 8px rgba(245, 158, 11, 0.5);
            animation: messageBadgePulse 2s ease-in-out infinite;
        }

        @keyframes messageBadgePulse {
            0%, 100% { 
                transform: scale(1);
            }
            50% { 
                transform: scale(1.1);
            }
        }

        .radar-info {
            position: absolute;
            top: -75px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 5;
            white-space: nowrap;
        }

        .radar-info-title {
            font-size: 11px;
            font-weight: 500;
            color: #8b949e;
            letter-spacing: -0.1px;
        }

        .precision-badge {
            display: inline-block;
            margin-top: 4px;
            padding: 2px 8px;
            background: rgba(56, 189, 98, 0.15);
            border: 1px solid rgba(56, 189, 98, 0.3);
            border-radius: 8px;
            font-size: 9px;
            font-weight: 600;
            color: #38bd62;
            letter-spacing: 0.3px;
            text-transform: uppercase;
            transition: all 0.3s ease;
        }

        .tech-badges-container {
            position: fixed !important;
            top: 80px !important;
            right: 16px !important;
            z-index: 100 !important;
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: flex-end;
        }

        .tech-badge {
            padding: 6px 12px !important;
            font-size: 10px !important;
            backdrop-filter: blur(12px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3) !important;
            display: flex !important;
            align-items: center;
            gap: 6px;
            background: rgba(56, 189, 98, 0.15);
            border: 1px solid rgba(56, 189, 98, 0.3);
            border-radius: 8px;
            font-weight: 600;
            color: #38bd62;
            letter-spacing: 0.3px;
            text-transform: uppercase;
            transition: all 0.3s ease;
        }

        .tech-badge.online {
            background: rgba(34, 197, 94, 0.15);
            border-color: rgba(34, 197, 94, 0.4);
            color: #22c55e;
        }

        .tech-badge.precision {
            background: rgba(56, 189, 98, 0.15);
            border-color: rgba(56, 189, 98, 0.3);
            color: #38bd62;
        }

        .tech-badge-dot {
            width: 6px;
            height: 6px;
            background: currentColor;
            border-radius: 50%;
            animation: badgePulse 2s ease-in-out infinite;
        }

        @keyframes badgePulse {
            0%, 100% {
                box-shadow: 0 0 0 0 currentColor;
                opacity: 1;
            }
            50% {
                box-shadow: 0 0 0 4px transparent;
                opacity: 0.7;
            }
        }

        .precision-badge-corner {
            position: fixed !important;
            top: 80px !important;
            right: 16px !important;
            z-index: 100 !important;
            margin: 0 !important;
            padding: 6px 12px !important;
            font-size: 10px !important;
            backdrop-filter: blur(12px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3) !important;
            display: block !important;
        }

        .precision-badge.ultrasonic-active {
            background: rgba(255, 193, 7, 0.2);
            border-color: rgba(255, 193, 7, 0.5);
            color: #ffc107;
            animation: ultrasonic-pulse 1.5s ease-in-out infinite;
        }

        @keyframes ultrasonic-pulse {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(255, 193, 7, 0.4);
            }
            50% {
                box-shadow: 0 0 0 4px rgba(255, 193, 7, 0);
            }
        }

        .radar-info-count {
            font-size: 32px;
            font-weight: 800;
            color: #2d3640;
            letter-spacing: -1px;
            text-shadow: 
                0 1px 0 rgba(255, 255, 255, 0.2),
                0 2px 4px rgba(0, 0, 0, 0.8),
                0 0 20px rgba(88, 166, 255, 0.4),
                inset 0 -2px 4px rgba(0, 0, 0, 0.3);
            background: linear-gradient(180deg, #3d4856 0%, #252b35 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            filter: drop-shadow(0 2px 6px rgba(88, 166, 255, 0.3));
            margin-bottom: 2px;
        }

        .compass-label {
            position: absolute;
            font-size: 32px;
            font-weight: 800;
            color: rgba(139, 148, 158, 0.10);
            user-select: none;
            pointer-events: none;
            font-family: 'Inter', sans-serif;
            letter-spacing: 1px;
            text-shadow: 0 0 20px rgba(139, 148, 158, 0.05);
        }

        .compass-n {
            top: 10%;
            left: 50%;
            transform: translateX(-50%);
        }

        .compass-s {
            bottom: 10%;
            left: 50%;
            transform: translateX(-50%);
        }

        .compass-e {
            right: 10%;
            top: 50%;
            transform: translateY(-50%);
        }

        .compass-o {
            left: 10%;
            top: 50%;
            transform: translateY(-50%);
        }

        /* Center avatar (current user) - Fixed in center, smaller and aesthetic */
        .center-avatar-fixed {
            position: absolute !important;
            left: 50% !important;
            top: 50% !important;
            transform: translate(-50%, -50%) !important;
            z-index: 100 !important;
            opacity: 1 !important;
            pointer-events: auto !important;
        }
        
        .center-avatar-fixed .avatar-wrapper {
            transform: none !important;
        }
        
        .center-avatar .avatar-ring {
            width: 50px;
            height: 50px;
            padding: 2px;
            box-shadow: 
                0 0 0 2px rgba(56, 189, 98, 0.15),
                0 0 20px rgba(56, 189, 98, 0.3),
                0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .center-avatar .avatar-img-wrapper {
            width: 46px;
            height: 46px;
            border: 2px solid #0d1117;
        }

        .direction-indicator {
            position: absolute;
            top: -8px;
            left: 50%;
            margin-left: -6px;
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 12px solid #38bd62;
            filter: drop-shadow(0 0 6px rgba(56, 189, 98, 0.6));
            transition: transform 0.1s ease-out;
            z-index: 10;
            pointer-events: none;
        }

        /* Regular avatars */
        .regular-avatar .avatar-ring {
            width: 58px;
            height: 58px;
            padding: 2px;
        }

        .regular-avatar .avatar-img-wrapper {
            width: 54px;
            height: 54px;
            border: 2px solid #0d1117;
        }

        .bottom-bar {
            background: linear-gradient(180deg, rgba(13, 17, 23, 0) 0%, rgba(13, 17, 23, 0.98) 15%, rgba(13, 17, 23, 1) 100%);
            padding: 16px 20px 28px;
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .thought-input-container {
            flex: 1;
            position: relative;
            display: flex;
            align-items: center;
        }

        .thought-input {
            flex: 1;
            background: rgba(22, 27, 34, 0.7);
            border: 1px solid rgba(48, 54, 61, 0.4);
            border-radius: 25px;
            padding: 13px 50px 13px 20px;
            color: #e6edf3;
            font-size: 15px;
            font-family: 'Inter', sans-serif;
            outline: none;
            transition: all 0.2s ease;
            font-weight: 400;
            letter-spacing: -0.2px;
            width: 100%;
        }
        
        .send-button {
            position: absolute;
            right: 6px;
            width: 38px;
            height: 38px;
            border-radius: 50%;
            background: rgba(56, 189, 98, 0.15);
            border: 1px solid rgba(56, 189, 98, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            opacity: 0.7;
        }
        
        .send-button:hover {
            opacity: 1;
            background: rgba(56, 189, 98, 0.25);
            transform: scale(1.05);
        }
        
        .send-button:active {
            transform: scale(0.95);
        }
        
        .send-button svg {
            width: 18px;
            height: 18px;
            color: #38bd62;
        }
        }

        .thought-input::placeholder {
            color: #6e7681;
        }

        .thought-input:focus {
            border-color: rgba(48, 54, 61, 0.7);
            background: rgba(22, 27, 34, 0.85);
        }

        .location-permission {
            position: fixed;
            inset: 0;
            background: rgba(13, 17, 23, 0.97);
            backdrop-filter: blur(20px);
            z-index: 400;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 30px;
        }

        .permission-card {
            background: rgba(22, 27, 34, 0.95);
            border: 1px solid rgba(48, 54, 61, 0.6);
            border-radius: 18px;
            padding: 34px 26px;
            text-align: center;
            max-width: 350px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .permission-icon {
            width: 68px;
            height: 68px;
            margin: 0 auto 22px;
            color: #58a6ff;
            opacity: 0.9;
        }

        .permission-card h2 {
            font-size: 21px;
            color: #f0f6fc;
            margin-bottom: 11px;
            font-weight: 600;
            letter-spacing: -0.3px;
        }

        .permission-card p {
            color: #8b949e;
            line-height: 1.6;
            margin-bottom: 26px;
            font-size: 14px;
            font-weight: 400;
        }

        .permission-btn {
            width: 100%;
            padding: 15px;
            border-radius: 11px;
            background: rgba(88, 166, 255, 0.14);
            color: #58a6ff;
            font-size: 15px;
            font-weight: 600;
            font-family: 'Inter', sans-serif;
            border: 1px solid rgba(88, 166, 255, 0.18);
            cursor: pointer;
            transition: all 0.2s ease;
            letter-spacing: -0.2px;
        }

        .chat-overlay {
            position: fixed;
            inset: 0;
            background: #0d1117;
            z-index: 200;
            display: flex;
            flex-direction: column;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }

        .chat-overlay.active {
            transform: translateX(0);
        }

        .inbox-overlay {
            position: fixed;
            inset: 0;
            background: #0d1117;
            z-index: 200;
            display: flex;
            flex-direction: column;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }

        .inbox-overlay.active {
            transform: translateX(0);
        }

        .inbox-header {
            display: flex;
            align-items: center;
            gap: 14px;
            padding: 16px 20px;
            background: rgba(22, 27, 34, 0.95);
            border-bottom: 1px solid rgba(48, 54, 61, 0.5);
        }

        .inbox-header svg {
            width: 26px;
            height: 26px;
            color: #8b949e;
            cursor: pointer;
        }

        .inbox-header h2 {
            flex: 1;
            font-size: 18px;
            font-weight: 600;
            color: #f0f6fc;
            margin: 0;
        }

        .inbox-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }

        .inbox-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px 12px;
            background: rgba(22, 27, 34, 0.5);
            border-radius: 12px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }

        .inbox-item:hover {
            background: rgba(22, 27, 34, 0.8);
            border-color: rgba(56, 189, 98, 0.3);
        }

        .inbox-item.unread {
            background: rgba(56, 189, 98, 0.08);
            border-color: rgba(56, 189, 98, 0.3);
        }

        .inbox-avatar {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            border: 2px solid rgba(71, 85, 105, 0.5);
            flex-shrink: 0;
        }

        .inbox-item.unread .inbox-avatar {
            border-color: #fbbf24;
        }

        .inbox-info {
            flex: 1;
            min-width: 0;
        }

        .inbox-name {
            font-size: 15px;
            font-weight: 600;
            color: #f0f6fc;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .inbox-preview {
            font-size: 13px;
            color: #8b949e;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .inbox-item.unread .inbox-preview {
            color: #c9d1d9;
            font-weight: 500;
        }

        .inbox-meta {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 4px;
        }

        .inbox-distance {
            font-size: 11px;
            color: #6e7681;
        }

        .inbox-unread-badge {
            background: #ef4444;
            color: #fff;
            font-size: 10px;
            font-weight: 700;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .inbox-empty {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #6e7681;
            padding: 40px 20px;
        }

        .inbox-empty svg {
            width: 64px;
            height: 64px;
            margin-bottom: 16px;
            opacity: 0.4;
        }

        .inbox-empty p {
            font-size: 15px;
            margin: 0;
        }

        /* ========================================
           TECH SETTINGS OVERLAY
           ======================================== */
        .tech-settings-overlay {
            position: fixed;
            inset: 0;
            background: #0d1117;
            z-index: 200;
            display: flex;
            flex-direction: column;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }

        .tech-settings-overlay.active {
            transform: translateX(0);
        }

        .tech-settings-header {
            display: flex;
            align-items: center;
            gap: 14px;
            padding: 16px 20px;
            background: rgba(22, 27, 34, 0.95);
            border-bottom: 1px solid rgba(48, 54, 61, 0.5);
        }

        .tech-settings-header svg {
            width: 26px;
            height: 26px;
            color: #8b949e;
            cursor: pointer;
        }

        .tech-settings-header h2 {
            flex: 1;
            font-size: 18px;
            font-weight: 600;
            color: #f0f6fc;
            margin: 0;
        }

        .tech-settings-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .tech-mode-selector {
            margin-bottom: 30px;
        }

        .tech-mode-selector h3 {
            font-size: 14px;
            font-weight: 600;
            color: #f0f6fc;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .tech-mode-options {
            display: flex;
            gap: 12px;
        }

        .tech-mode-option {
            flex: 1;
            padding: 12px;
            background: rgba(22, 27, 34, 0.5);
            border: 2px solid rgba(48, 54, 61, 0.5);
            border-radius: 12px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tech-mode-option:hover {
            background: rgba(22, 27, 34, 0.8);
            border-color: rgba(56, 189, 98, 0.3);
        }

        .tech-mode-option.active {
            background: rgba(56, 189, 98, 0.15);
            border-color: rgba(56, 189, 98, 0.6);
        }

        .tech-mode-option .icon {
            font-size: 24px;
            margin-bottom: 6px;
        }

        .tech-mode-option .label {
            font-size: 12px;
            font-weight: 600;
            color: #c9d1d9;
        }

        .tech-mode-option.active .label {
            color: #38bd62;
        }

        .tech-mode-option .description {
            font-size: 10px;
            color: #8b949e;
            margin-top: 4px;
        }

        .tech-list {
            margin-top: 20px;
        }

        .tech-list h3 {
            font-size: 14px;
            font-weight: 600;
            color: #f0f6fc;
            margin-bottom: 16px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .tech-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px;
            background: rgba(22, 27, 34, 0.5);
            border: 1px solid rgba(48, 54, 61, 0.5);
            border-radius: 12px;
            margin-bottom: 12px;
            transition: all 0.2s ease;
        }

        .tech-item:hover {
            background: rgba(22, 27, 34, 0.8);
        }

        .tech-item.disabled {
            opacity: 0.5;
            pointer-events: none;
        }

        .tech-item-info {
            flex: 1;
        }

        .tech-item-name {
            font-size: 15px;
            font-weight: 600;
            color: #f0f6fc;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tech-item-icon {
            font-size: 18px;
        }

        .tech-item-description {
            font-size: 12px;
            color: #8b949e;
            line-height: 1.4;
        }

        .tech-toggle {
            position: relative;
            width: 50px;
            height: 28px;
            background: rgba(139, 148, 158, 0.3);
            border-radius: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .tech-toggle.active {
            background: rgba(56, 189, 98, 0.5);
        }

        .tech-toggle::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 22px;
            height: 22px;
            background: #8b949e;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .tech-toggle.active::after {
            left: 25px;
            background: #38bd62;
        }

        .tech-info-note {
            margin-top: 30px;
            padding: 16px;
            background: rgba(56, 139, 253, 0.1);
            border: 1px solid rgba(56, 139, 253, 0.3);
            border-radius: 12px;
        }

        .tech-info-note h4 {
            font-size: 13px;
            font-weight: 600;
            color: #58a6ff;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .tech-info-note p {
            font-size: 12px;
            color: #8b949e;
            line-height: 1.5;
            margin: 0;
        }

        .chat-header {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 16px;
            background: #1f2c33;
            border-bottom: none;
        }

        .chat-header svg {
            width: 24px;
            height: 24px;
            color: #aebac1;
            cursor: pointer;
        }

        .chat-user-info {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .chat-user-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
        }

        .chat-user-details h3 {
            font-size: 16px;
            font-weight: 400;
            color: #e9edef;
            margin-bottom: 0px;
        }

        .chat-user-details p {
            font-size: 13px;
            color: #8696a0;
        }

        .chat-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .chat-thought-display {
            background: rgba(22, 27, 34, 0.7);
            border: 1px solid rgba(48, 54, 61, 0.4);
            padding: 10px 16px;
            margin: 12px 16px;
            border-radius: 10px;
            color: #8b949e;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            /* Fondo tipo WhatsApp */
            background: #0b141a;
            background-image: 
                repeating-linear-gradient(
                    45deg,
                    transparent,
                    transparent 10px,
                    rgba(255, 255, 255, 0.02) 10px,
                    rgba(255, 255, 255, 0.02) 20px
                );
        }

        .chat-info {
            background: rgba(22, 27, 34, 0.6);
            border: 1px solid rgba(48, 54, 61, 0.3);
            padding: 12px 16px;
            border-radius: 10px;
            color: #8b949e;
            font-size: 13px;
            text-align: center;
            line-height: 1.5;
        }

        .message {
            max-width: 75%;
            padding: 6px 7px 8px 9px;
            border-radius: 8px;
            font-size: 14.2px;
            line-height: 19px;
            word-wrap: break-word;
            position: relative;
            box-shadow: 0 1px 0.5px rgba(0, 0, 0, 0.13);
            margin-bottom: 2px;
        }

        .message.sent {
            background: #005c4b;
            color: #e9edef;
            align-self: flex-end;
            border-radius: 8px 8px 0 8px;
        }

        .message.received {
            background: #1f2c33;
            color: #e9edef;
            align-self: flex-start;
            border-radius: 0 8px 8px 8px;
        }
        
        /* Timestamp en mensaje */
        .message-time {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.5);
            margin-left: 8px;
            float: right;
            margin-top: 4px;
        }
        
        /* Checkmarks para mensajes enviados */
        .message-status {
            display: inline-block;
            margin-left: 4px;
            font-size: 16px;
            color: #53bdeb;
            vertical-align: middle;
        }

        .chat-input-container {
            padding: 5px 8px 5px 8px;
            background: #1f2c33;
            display: flex;
            gap: 6px;
            align-items: center;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
        }

        .chat-input {
            flex: 1;
            background: #2a3942;
            border: none;
            border-radius: 20px;
            padding: 10px 12px;
            color: #e9edef;
            font-size: 15px;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            outline: none;
            resize: none;
            min-height: 40px;
            max-height: 100px;
        }

        .chat-input::placeholder {
            color: #8696a0;
        }

        .chat-send-btn {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: #00a884;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .chat-send-btn:disabled {
            background: #182229;
            cursor: not-allowed;
        }

        .chat-send-btn:not(:disabled):active {
            transform: scale(0.95);
            background: #06cf9c;
        }

        .chat-send-btn svg {
            color: #0b141a;
        }
        
        .chat-send-btn:disabled svg {
            color: #8696a0;
        }
        
        /* Botón redondo (emoji, adjuntar, etc) */
        .btn-round {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: transparent;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background 0.2s ease;
            flex-shrink: 0;
            color: #8696a0;
        }
        
        .btn-round:active {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .btn-round svg {
            width: 26px;
            height: 26px;
        }

        /* Sidebar */
        .sidebar {
            position: fixed;
            left: 0;
            top: 0;
            bottom: 0;
            width: 280px;
            background: rgba(22, 27, 34, 0.98);
            backdrop-filter: blur(20px);
            border-right: 1px solid rgba(48, 54, 61, 0.5);
            z-index: 300;
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        .sidebar.active {
            transform: translateX(0);
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid rgba(48, 54, 61, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .sidebar-header h2 {
            font-size: 20px;
            font-weight: 600;
            color: #f0f6fc;
        }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px 0;
        }

        .sidebar-item {
            padding: 14px 20px;
            display: flex;
            align-items: center;
            gap: 14px;
            color: #c9d1d9;
            cursor: pointer;
            transition: all 0.2s ease;
            border-left: 3px solid transparent;
        }

        .sidebar-item:hover {
            background: rgba(48, 54, 61, 0.3);
            border-left-color: #58a6ff;
        }

        .sidebar-item svg {
            width: 22px;
            height: 22px;
            color: #8b949e;
        }

        /* Profile */
        .profile-overlay {
            position: fixed;
            inset: 0;
            background: #0d1117;
            z-index: 250;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        .profile-overlay.active {
            transform: translateX(0);
        }

        .profile-header {
            padding: 16px 20px;
            background: rgba(22, 27, 34, 0.95);
            border-bottom: 1px solid rgba(48, 54, 61, 0.5);
            display: flex;
            align-items: center;
            gap: 14px;
        }

        .profile-content {
            flex: 1;
            overflow-y: auto;
            padding: 24px 20px;
        }

        .profile-avatar-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 28px;
        }

        .profile-avatar-large {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            border: 3px solid rgba(88, 166, 255, 0.3);
            object-fit: cover;
            margin-bottom: 16px;
        }

        .profile-name {
            font-size: 24px;
            font-weight: 600;
            color: #f0f6fc;
            margin-bottom: 4px;
        }

        .profile-bio {
            color: #8b949e;
            text-align: center;
            font-size: 14px;
        }

        .profile-section {
            margin-bottom: 24px;
        }

        .profile-section-title {
            font-size: 13px;
            font-weight: 600;
            color: #8b949e;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
        }

        .profile-field {
            background: rgba(22, 27, 34, 0.6);
            border: 1px solid rgba(48, 54, 61, 0.4);
            border-radius: 10px;
            padding: 12px 16px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .profile-field-label {
            color: #8b949e;
            font-size: 14px;
        }

        .profile-field-value {
            color: #f0f6fc;
            font-size: 14px;
            font-weight: 500;
        }

        /* Circular Story Viewer */
        .story-viewer {
            position: fixed;
            inset: 0;
            background: rgba(13, 17, 23, 0.98);
            z-index: 400;
            display: flex;
            align-items: center;
            justify-content: center;
            transform: scale(0);
            opacity: 0;
            transition: all 0.3s ease;
        }

        .story-viewer.active {
            transform: scale(1);
            opacity: 1;
        }

        .story-circle {
            width: min(90vw, 400px);
            height: min(90vw, 400px);
            border-radius: 50%;
            overflow: hidden;
            position: relative;
            border: 3px solid rgba(88, 166, 255, 0.3);
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.8);
        }

        .story-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .story-close {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(22, 27, 34, 0.9);
            border: 1px solid rgba(48, 54, 61, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 10;
        }

        .story-close svg {
            width: 20px;
            height: 20px;
            color: #c9d1d9;
        }

        .story-user-info {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 10;
        }

        .story-user-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid #fff;
        }

        .story-user-name {
            font-size: 16px;
            font-weight: 600;
            color: #fff;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.8);
        }

        .overlay-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            z-index: 250;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .overlay-backdrop.active {
            opacity: 1;
            pointer-events: all;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Initialize Firebase
        const firebaseConfig = {
            apiKey: "AIzaSyAhcfX0M5oqX7rZ6WdCZaHfxHKcxySxQl8",
            authDomain: "radar-social-5a61f.firebaseapp.com",
            projectId: "radar-social-5a61f",
            storageBucket: "radar-social-5a61f.firebasestorage.app",
            messagingSenderId: "1010787643000",
            appId: "1:1010787643000:web:e9dc6a1c175d875b90478d",
            measurementId: "G-NXM0HPCWMY"
        };
        
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();
        const storage = firebase.storage();

        // ==========================================
        // KALMAN FILTER CLASS - Suaviza GPS
        // ==========================================
        class KalmanFilter {
            constructor(processNoise = 0.001, measurementNoise = 0.1) {
                this.x = 0;  // Estado estimado
                this.P = 1;  // Error de estimación
                this.Q = processNoise;  // Ruido del proceso
                this.R = measurementNoise;  // Ruido de medición
            }
            
            update(measurement) {
                // Predicción
                this.P = this.P + this.Q;
                
                // Actualización (corrección)
                const K = this.P / (this.P + this.R);  // Ganancia de Kalman
                this.x = this.x + K * (measurement - this.x);
                this.P = (1 - K) * this.P;
                
                return this.x;
            }
            
            reset(value) {
                this.x = value;
                this.P = 1;
            }
        }

        function RadarSocialApp() {
            const [locationPermission, setLocationPermission] = useState(false);
            const [radius, setRadius] = useState(50);
            const [thought, setThought] = useState('');
            const [currentUser, setCurrentUser] = useState(null);
            const [userLocation, setUserLocation] = useState(null);
            const [users, setUsers] = useState([]); // Start empty - will load from Firebase
            const [isDraggingDial, setIsDraggingDial] = useState(false);
            const [selectedUser, setSelectedUser] = useState(null);
            const [chats, setChats] = useState({});
            const [messages, setMessages] = useState({});
            const [messageInput, setMessageInput] = useState('');
            const [selectedImage, setSelectedImage] = useState(null);
            const [audioContext, setAudioContext] = useState(null);
            const [showSidebar, setShowSidebar] = useState(false);
            const [showProfile, setShowProfile] = useState(false);
            const [showInbox, setShowInbox] = useState(false);
            const [showTechSettings, setShowTechSettings] = useState(false);
            
            // Estados para control de tecnologías
            const [techSettings, setTechSettings] = useState({
                mode: 'auto', // 'auto', 'manual'
                gps: true,
                kalman: true,
                deadReckoning: true,
                ultrasonic: true
            });
            const [viewingStory, setViewingStory] = useState(null);
            const [deviceHeading, setDeviceHeading] = useState(0); // Phone compass direction
            const [lastKnownPositions, setLastKnownPositions] = useState({}); // For GPS smoothing
            
            // SENSOR FUSION - Estados para sensores
            const [sensorData, setSensorData] = useState({
                acceleration: { x: 0, y: 0, z: 0 },
                rotation: { alpha: 0, beta: 0, gamma: 0 },
                heading: 0,
                isMoving: false,
                lastMotionTime: 0
            });
            const [locationAccuracy, setLocationAccuracy] = useState(20); // metros
            
            // ULTRASONIC SYSTEM - Estados para audio ultrasónico
            const [ultrasonicActive, setUltrasonicActive] = useState(false);
            const [ultrasonicDetections, setUltrasonicDetections] = useState({}); // { userId: distance }
            const ultrasonicContext = useRef(null);
            const ultrasonicAnalyser = useRef(null);
            const detectionInterval = useRef(null);
            const chatMessagesRef = useRef(null);
            
            // Kalman Filters para latitud y longitud
            const kalmanLat = useRef(new KalmanFilter(0.001, 0.1));
            const kalmanLon = useRef(new KalmanFilter(0.001, 0.1));
            const lastDeadReckoningPos = useRef(null);
            const lastDeadReckoningTime = useRef(Date.now());

            // Calculate distance between two GPS coordinates (Haversine formula)
            const calculateDistance = (lat1, lon1, lat2, lon2) => {
                const R = 6371e3; // Earth's radius in meters
                const φ1 = lat1 * Math.PI / 180;
                const φ2 = lat2 * Math.PI / 180;
                const Δφ = (lat2 - lat1) * Math.PI / 180;
                const Δλ = (lon2 - lon1) * Math.PI / 180;

                const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
                          Math.cos(φ1) * Math.cos(φ2) *
                          Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

                return R * c; // Distance in meters
            };

            // Calculate angle/bearing from point 1 to point 2
            const calculateBearing = (lat1, lon1, lat2, lon2) => {
                const φ1 = lat1 * Math.PI / 180;
                const φ2 = lat2 * Math.PI / 180;
                const Δλ = (lon2 - lon1) * Math.PI / 180;

                const y = Math.sin(Δλ) * Math.cos(φ2);
                const x = Math.cos(φ1) * Math.sin(φ2) -
                          Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);
                const θ = Math.atan2(y, x);

                return (θ * 180 / Math.PI + 360) % 360; // Bearing in degrees
            };

            // ==========================================
            // SENSOR FUSION - Dead Reckoning
            // ==========================================
            const applyDeadReckoning = (lastPos, acceleration, heading, deltaTime) => {
                if (!lastPos || !sensorData.isMoving) return lastPos;
                
                // Calcular velocidad aproximada desde aceleración
                // v = a * t (aproximación simple)
                const speed = Math.sqrt(
                    acceleration.x ** 2 + 
                    acceleration.y ** 2
                ) * deltaTime; // metros
                
                // Convertir heading a radianes
                const headingRad = heading * Math.PI / 180;
                
                // Calcular desplazamiento en metros
                const dx = speed * Math.sin(headingRad);
                const dy = speed * Math.cos(headingRad);
                
                // Convertir metros a grados (aproximado)
                const dLat = dy / 111320; // 1 grado lat ≈ 111.32 km
                const dLon = dx / (111320 * Math.cos(lastPos.latitude * Math.PI / 180));
                
                return {
                    latitude: lastPos.latitude + dLat,
                    longitude: lastPos.longitude + dLon
                };
            };

            // ==========================================
            // SENSOR FUSION - Combina GPS + Sensores
            // ==========================================
            const applySensorFusion = (rawGPS, accuracy) => {
                // 1. Aplicar Kalman Filter al GPS
                const filteredLat = kalmanLat.current.update(rawGPS.latitude);
                const filteredLon = kalmanLon.current.update(rawGPS.longitude);
                
                // 2. Si el usuario está en movimiento, aplicar Dead Reckoning
                if (sensorData.isMoving && lastDeadReckoningPos.current) {
                    const now = Date.now();
                    const deltaTime = (now - lastDeadReckoningTime.current) / 1000; // segundos
                    
                    const predictedPos = applyDeadReckoning(
                        lastDeadReckoningPos.current,
                        sensorData.acceleration,
                        sensorData.heading,
                        deltaTime
                    );
                    
                    // 3. Combinar GPS filtrado con predicción
                    // Dar más peso al GPS si la precisión es buena
                    const gpsWeight = Math.max(0.3, Math.min(0.9, 1 - (accuracy / 50)));
                    const drWeight = 1 - gpsWeight;
                    
                    const fusedLat = (filteredLat * gpsWeight) + (predictedPos.latitude * drWeight);
                    const fusedLon = (filteredLon * gpsWeight) + (predictedPos.longitude * drWeight);
                    
                    lastDeadReckoningTime.current = now;
                    lastDeadReckoningPos.current = { latitude: fusedLat, longitude: fusedLon };
                    
                    // Precisión mejorada (2-5m típicamente)
                    const improvedAccuracy = Math.min(accuracy * 0.3, 5);
                    setLocationAccuracy(improvedAccuracy);
                    
                    console.log(`🧠 Sensor Fusion: GPS(${accuracy.toFixed(1)}m) → Fused(${improvedAccuracy.toFixed(1)}m)`);
                    
                    return {
                        latitude: fusedLat,
                        longitude: fusedLon,
                        accuracy: improvedAccuracy
                    };
                } else {
                    // Usuario quieto, solo usar GPS filtrado
                    lastDeadReckoningPos.current = { latitude: filteredLat, longitude: filteredLon };
                    lastDeadReckoningTime.current = Date.now();
                    
                    const improvedAccuracy = Math.min(accuracy * 0.5, 8);
                    setLocationAccuracy(improvedAccuracy);
                    
                    console.log(`📍 Kalman Filter: GPS(${accuracy.toFixed(1)}m) → Filtered(${improvedAccuracy.toFixed(1)}m)`);
                    
                    return {
                        latitude: filteredLat,
                        longitude: filteredLon,
                        accuracy: improvedAccuracy
                    };
                }
            };

            // ==========================================
            // ULTRASONIC SYSTEM - Audio Ultrasónico
            // ==========================================
            
            // Emitir señal ultrasónica con ID de usuario codificado
            const emitUltrasonicSignal = (userId) => {
                if (!audioContext) return;
                
                try {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    // Frecuencia base: 19.5 kHz (inaudible para humanos)
                    const baseFreq = 19500;
                    
                    // Codificar userId en la frecuencia (simple FSK)
                    // Último dígito del hash del userId determina offset
                    const userHash = userId.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
                    const freqOffset = (userHash % 10) * 50; // 0-500 Hz offset
                    
                    oscillator.frequency.value = baseFreq + freqOffset;
                    oscillator.type = 'sine';
                    
                    // Volumen moderado
                    gainNode.gain.value = 0.3;
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    // Burst corto de 150ms
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.15);
                    
                    console.log(`🔊 Emitiendo ultrasonido: ${(baseFreq + freqOffset).toFixed(0)} Hz`);
                } catch (error) {
                    console.error('Error emitting ultrasonic:', error);
                }
            };
            
            // Iniciar detector de ultrasonido
            const startUltrasonicDetector = async () => {
                if (ultrasonicActive) return;
                
                try {
                    // Solicitar permiso de micrófono
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            sampleRate: 48000 // Alta frecuencia de muestreo para captar 19.5 kHz
                        }
                    });
                    
                    // Crear contexto de audio para análisis
                    const ctx = new (window.AudioContext || window.webkitAudioContext)();
                    ultrasonicContext.current = ctx;
                    
                    const analyser = ctx.createAnalyser();
                    analyser.fftSize = 4096; // Alta resolución
                    analyser.smoothingTimeConstant = 0.3;
                    ultrasonicAnalyser.current = analyser;
                    
                    const source = ctx.createMediaStreamSource(stream);
                    source.connect(analyser);
                    
                    setUltrasonicActive(true);
                    console.log('✅ Detector ultrasónico activado');
                    
                    // Iniciar detección continua
                    detectUltrasonicSignals();
                } catch (error) {
                    console.error('Error starting ultrasonic detector:', error);
                    console.log('⚠️ Micrófono no disponible - precisión <5m desactivada');
                }
            };
            
            // Detener detector de ultrasonido
            const stopUltrasonicDetector = () => {
                if (detectionInterval.current) {
                    clearInterval(detectionInterval.current);
                    detectionInterval.current = null;
                }
                
                if (ultrasonicContext.current) {
                    ultrasonicContext.current.close();
                    ultrasonicContext.current = null;
                }
                
                setUltrasonicActive(false);
                setUltrasonicDetections({});
                console.log('❌ Detector ultrasónico desactivado');
            };
            
            // Detectar señales ultrasónicas
            const detectUltrasonicSignals = () => {
                if (!ultrasonicAnalyser.current) return;
                
                const analyser = ultrasonicAnalyser.current;
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                
                detectionInterval.current = setInterval(() => {
                    analyser.getByteFrequencyData(dataArray);
                    
                    // Buscar picos en rango 19-20 kHz
                    // frequencyBinCount / 2 = Nyquist frequency (24 kHz at 48kHz sample rate)
                    const nyquist = ultrasonicContext.current.sampleRate / 2;
                    const binWidth = nyquist / bufferLength;
                    
                    const minFreq = 19000;
                    const maxFreq = 20000;
                    const minBin = Math.floor(minFreq / binWidth);
                    const maxBin = Math.floor(maxFreq / binWidth);
                    
                    let maxAmplitude = 0;
                    let peakFrequency = 0;
                    
                    for (let i = minBin; i < maxBin && i < bufferLength; i++) {
                        if (dataArray[i] > maxAmplitude) {
                            maxAmplitude = dataArray[i];
                            peakFrequency = i * binWidth;
                        }
                    }
                    
                    // Threshold: detectar señal si amplitud > 100
                    if (maxAmplitude > 100) {
                        // Calcular distancia aproximada por intensidad de señal
                        // Ley del cuadrado inverso simplificada
                        // distance ≈ 5 * (1 - amplitude/255)
                        const normalizedAmplitude = maxAmplitude / 255;
                        const estimatedDistance = Math.max(0.1, 5 * (1 - normalizedAmplitude));
                        
                        console.log(`🎯 Ultrasonido detectado: ${peakFrequency.toFixed(0)} Hz, Amp:${maxAmplitude}, ~${estimatedDistance.toFixed(2)}m`);
                        
                        // Guardar detección
                        setUltrasonicDetections(prev => ({
                            ...prev,
                            'nearby': estimatedDistance,
                            lastUpdate: Date.now()
                        }));
                    }
                }, 200); // Detectar cada 200ms
            };
            
            // Combinar distancia GPS con distancia ultrasónica
            const getFinalDistance = (gpsDistance, userId) => {
                // Si hay detección ultrasónica reciente (< 1 segundo) y distancia GPS < 5m
                const hasRecentDetection = ultrasonicDetections.lastUpdate && 
                                         (Date.now() - ultrasonicDetections.lastUpdate) < 1000;
                
                if (gpsDistance < 5 && hasRecentDetection && ultrasonicDetections.nearby) {
                    const ultrasonicDist = ultrasonicDetections.nearby;
                    // Promedio ponderado: 70% ultrasónico, 30% GPS
                    const finalDist = (ultrasonicDist * 0.7) + (gpsDistance * 0.3);
                    return Math.max(0.1, finalDist); // Mínimo 10cm
                }
                return gpsDistance;
            };

            useEffect(() => {
                // VERSION CHECK
                console.log('🚀 RADAR SOCIAL v2.7 - Rediseño WhatsApp');
                console.log('🎨 NUEVO: Interfaz de chat estilo WhatsApp');
                console.log('✅ Burbujas verdes (enviados) / grises (recibidos)');
                console.log('✅ Timestamps en cada mensaje');
                console.log('✅ Checkmarks (✓✓) en mensajes enviados');
                console.log('✅ Fondo con patrón sutil');
                console.log('✅ Botón de enviar verde (#00a884)');
                console.log('✅ Header oscuro tipo WhatsApp');
                console.log('✅ FIX: Firebase Storage script agregado');
                console.log('✅ FIX: Mensajes duplicados eliminados');
                console.log('✅ FIX: Badge ONLINE reposicionado correctamente');
                console.log('📷 Envío de imágenes funcional');
                console.log('💚 Heartbeat cada 10s - Solo usuarios ONLINE activos');
                console.log('📬 Inbox de mensajes disponible');
                console.log('⚙️ PANEL TECNOLOGÍAS: Modo auto/manual disponible');
                
                // Initialize audio context
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                setAudioContext(ctx);
                
                // Load real user from Firebase
                const unsubscribe = auth.onAuthStateChanged(async (firebaseUser) => {
                    if (firebaseUser) {
                        console.log('Firebase User loaded:', firebaseUser);
                        console.log('Photo URL:', firebaseUser.photoURL);
                        
                        // Get user's current location with HIGH PRECISION
                        if ('geolocation' in navigator) {
                            let lastUpdateTime = 0;
                            let usersUnsubscribe = null;
                            
                            // Use watchPosition for continuous updates
                            let previousLocation = null;
                            
                            const watchId = navigator.geolocation.watchPosition(
                                async (position) => {
                                    const { latitude, longitude, accuracy } = position.coords;
                                    const currentTime = Date.now();
                                    
                                    // ==========================================
                                    // APLICAR SENSOR FUSION 🧠
                                    // ==========================================
                                    const fusedLocation = applySensorFusion(
                                        { latitude, longitude },
                                        accuracy
                                    );
                                    
                                    // Check if movement is significant (more than 3 meters)
                                    const shouldUpdate = !previousLocation || 
                                                       calculateDistance(
                                                           previousLocation.latitude,
                                                           previousLocation.longitude,
                                                           fusedLocation.latitude,
                                                           fusedLocation.longitude
                                                       ) >= 3;
                                    
                                    if (shouldUpdate) {
                                        console.log(`📍 GPS Raw: ${latitude.toFixed(6)}, ${longitude.toFixed(6)} (±${accuracy.toFixed(1)}m)`);
                                        console.log(`🎯 Fused: ${fusedLocation.latitude.toFixed(6)}, ${fusedLocation.longitude.toFixed(6)} (±${fusedLocation.accuracy.toFixed(1)}m)`);
                                        
                                        // Update local state with FUSED location
                                        setUserLocation({ 
                                            latitude: fusedLocation.latitude, 
                                            longitude: fusedLocation.longitude 
                                        });
                                        previousLocation = { 
                                            latitude: fusedLocation.latitude, 
                                            longitude: fusedLocation.longitude 
                                        };
                                    } else {
                                        console.log(`📍 Movement ignored (< 3m)`);
                                    }
                                    
                                    // Update Firebase every 3 seconds (throttle to avoid excessive writes)
                                    if (currentTime - lastUpdateTime >= 3000 && shouldUpdate) {
                                        lastUpdateTime = currentTime;
                                        
                                        try {
                                            // First time setup
                                            if (!usersUnsubscribe) {
                                                // Get user data from Firestore
                                                const userDoc = await db.collection('users').doc(firebaseUser.uid).get();
                                                
                                                let thought = '';
                                                let thoughtTimestamp = null;
                                                if (userDoc.exists) {
                                                    const userData = userDoc.data();
                                                    thoughtTimestamp = userData.thoughtTimestamp;
                                                    
                                                    // Check if thought is expired (24 hours)
                                                    if (userData.thought && thoughtTimestamp) {
                                                        const now = Date.now();
                                                        const thoughtTime = thoughtTimestamp.toMillis ? thoughtTimestamp.toMillis() : thoughtTimestamp;
                                                        const hoursPassed = (now - thoughtTime) / (1000 * 60 * 60);
                                                        
                                                        if (hoursPassed < 24) {
                                                            thought = userData.thought;
                                                        } else {
                                                            // Clear expired thought
                                                            await db.collection('users').doc(firebaseUser.uid).update({
                                                                thought: '',
                                                                thoughtTimestamp: null
                                                            });
                                                        }
                                                    }
                                                }
                                                
                                                // Create current user object
                                                const realUser = {
                                                    id: firebaseUser.uid,
                                                    name: firebaseUser.displayName || 'Usuario',
                                                    age: 25,
                                                    photo: firebaseUser.photoURL || 'https://ui-avatars.com/api/?name=' + encodeURIComponent(firebaseUser.displayName || 'User') + '&background=38bd62&color=fff&size=150',
                                                    thought: thought,
                                                    hasStory: false,
                                                    distance: 0,
                                                    angle: 0,
                                                    hasNewMessage: false,
                                                    email: firebaseUser.email,
                                                    latitude: latitude,
                                                    longitude: longitude
                                                };
                                                
                                                console.log('Real user created:', realUser);
                                                setCurrentUser(realUser);
                                                setThought(realUser.thought);
                                                
                                                // Listen to all users in real-time
                                                usersUnsubscribe = db.collection('users')
                                                    .where('isOnline', '==', true)
                                                    .onSnapshot((snapshot) => {
                                                        const otherUsers = [];
                                                        
                                                        // Get current location from state
                                                        const currentLat = latitude;
                                                        const currentLon = longitude;
                                                        
                                                        snapshot.forEach((doc) => {
                                                            const userData = doc.data();
                                                            
                                                            // Skip current user
                                                            if (userData.uid === firebaseUser.uid) return;
                                                            
                                                            // FILTRO ADICIONAL: Verificar que lastSeen sea reciente (últimos 30 segundos)
                                                            if (userData.lastSeen) {
                                                                const lastSeenTime = userData.lastSeen.toMillis ? userData.lastSeen.toMillis() : userData.lastSeen;
                                                                const now = Date.now();
                                                                const timeSinceLastSeen = now - lastSeenTime;
                                                                
                                                                // Si no ha actualizado en 30 segundos, ignorar
                                                                if (timeSinceLastSeen > 30000) {
                                                                    console.log(`⏰ Usuario ${userData.displayName} sin actividad (${Math.round(timeSinceLastSeen/1000)}s) - ignorando`);
                                                                    return;
                                                                }
                                                            }
                                                            
                                                            // Calculate distance and angle from current user
                                                            if (userData.location) {
                                                                const userLat = userData.location.latitude;
                                                                const userLon = userData.location.longitude;
                                                                
                                                                const distance = Math.round(
                                                                    calculateDistance(currentLat, currentLon, userLat, userLon)
                                                                );
                                                                
                                                                const angle = Math.round(
                                                                    calculateBearing(currentLat, currentLon, userLat, userLon)
                                                                );
                                                                
                                                                // Check if thought is expired (24 hours)
                                                                let displayThought = '';
                                                                if (userData.thought && userData.thoughtTimestamp) {
                                                                    const now = Date.now();
                                                                    const thoughtTime = userData.thoughtTimestamp.toMillis ? userData.thoughtTimestamp.toMillis() : userData.thoughtTimestamp;
                                                                    const hoursPassed = (now - thoughtTime) / (1000 * 60 * 60);
                                                                    
                                                                    if (hoursPassed < 24) {
                                                                        displayThought = userData.thought;
                                                                    }
                                                                }
                                                                
                                                                otherUsers.push({
                                                                    id: userData.uid,
                                                                    name: userData.displayName || 'Usuario',
                                                                    age: 25,
                                                                    photo: userData.photoURL || 'https://ui-avatars.com/api/?name=' + encodeURIComponent(userData.displayName || 'User') + '&background=38bd62&color=fff&size=150',
                                                                    thought: displayThought,
                                                                    hasStory: false,
                                                                    distance: distance,
                                                                    angle: angle,
                                                                    hasNewMessage: false, // Se actualizará por el listener de mensajes
                                                                    latitude: userLat,
                                                                    longitude: userLon
                                                                });
                                                            }
                                                        });
                                                        
                                                        // CRÍTICO: Preservar hasNewMessage de usuarios existentes
                                                        setUsers(prevUsers => {
                                                            const updatedUsers = [realUser, ...otherUsers.map(newUser => {
                                                                // Buscar si este usuario ya existe en el estado
                                                                const existingUser = prevUsers.find(u => u.id === newUser.id);
                                                                
                                                                // Si existe y tiene mensaje nuevo, PRESERVAR ese estado
                                                                if (existingUser && existingUser.hasNewMessage) {
                                                                    console.log(`💛 PRESERVANDO hasNewMessage=true para ${newUser.name}`);
                                                                    return {
                                                                        ...newUser,
                                                                        hasNewMessage: true  // PRESERVAR estado de mensaje
                                                                    };
                                                                }
                                                                
                                                                return newUser;
                                                            })];
                                                            
                                                            return updatedUsers;
                                                        });
                                                        
                                                        console.log(`👥 Usuarios actualizados: ${otherUsers.length} usuarios ONLINE activos`);
                                                        if (otherUsers.length > 0) {
                                                            console.log('Lista:', otherUsers.map(u => `${u.name} (${u.distance}m)`).join(', '));
                                                        }
                                                    });
                                            }
                                            
                                            // Update user in Firestore with FUSED location
                                            await db.collection('users').doc(firebaseUser.uid).set({
                                                uid: firebaseUser.uid,
                                                displayName: firebaseUser.displayName,
                                                email: firebaseUser.email,
                                                photoURL: firebaseUser.photoURL,
                                                location: new firebase.firestore.GeoPoint(fusedLocation.latitude, fusedLocation.longitude),
                                                isOnline: true,
                                                lastSeen: firebase.firestore.FieldValue.serverTimestamp(),
                                                accuracy: fusedLocation.accuracy
                                            }, { merge: true });
                                            
                                            // Update current user location in state
                                            setCurrentUser(prev => prev ? ({
                                                ...prev,
                                                latitude: fusedLocation.latitude,
                                                longitude: fusedLocation.longitude
                                            }) : prev);
                                            
                                        } catch (error) {
                                            console.error('Error updating location:', error);
                                        }
                                    }
                                },
                                (error) => {
                                    console.error('Location error:', error);
                                    
                                    // Instead of alert, we could show a non-intrusive notification
                                    // For now, just log it
                                    let errorMessage = 'No se pudo obtener tu ubicación.';
                                    
                                    switch(error.code) {
                                        case error.PERMISSION_DENIED:
                                            errorMessage = 'Permiso de ubicación denegado.';
                                            break;
                                        case error.POSITION_UNAVAILABLE:
                                            errorMessage = 'Ubicación no disponible.';
                                            break;
                                        case error.TIMEOUT:
                                            errorMessage = 'Tiempo de espera agotado.';
                                            break;
                                    }
                                    
                                    console.warn('⚠️', errorMessage);
                                },
                                {
                                    enableHighAccuracy: true,  // ✅ Alta precisión GPS
                                    timeout: 10000,            // 10 segundos timeout
                                    maximumAge: 0              // No usar caché
                                }
                            );
                            
                            // Cleanup on unmount
                            return () => {
                                navigator.geolocation.clearWatch(watchId);
                                if (usersUnsubscribe) usersUnsubscribe();
                                // Mark user as offline
                                db.collection('users').doc(firebaseUser.uid).update({
                                    isOnline: false,
                                    lastSeen: firebase.firestore.FieldValue.serverTimestamp()
                                }).catch(err => console.error('Error marking offline:', err));
                            };
                            
                        } else {
                            console.error('❌ Tu dispositivo no soporta geolocalización');
                            // Redirect to error page or show elegant message
                            window.location.href = 'auth.html';
                        }
                    } else {
                        // No user logged in, redirect to auth
                        console.log('No user logged in, redirecting...');
                        window.location.href = 'auth.html';
                    }
                });
                
                return () => unsubscribe();
            }, []);

            // Listen to device orientation (compass)
            useEffect(() => {
                let hasRequested = false;
                
                const handleOrientation = (event) => {
                    // alpha: rotation around z-axis (compass heading)
                    // iOS uses webkitCompassHeading, Android uses alpha
                    let heading = 0;
                    
                    if (event.webkitCompassHeading !== undefined) {
                        // iOS - direct compass heading
                        heading = event.webkitCompassHeading;
                    } else if (event.alpha !== null) {
                        // Android - calculate from alpha
                        heading = 360 - event.alpha;
                    }
                    
                    setDeviceHeading(heading);
                };
                
                const requestOrientationPermission = async () => {
                    if (hasRequested) return;
                    hasRequested = true;
                    
                    // Request permission on iOS 13+
                    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                        try {
                            const permissionState = await DeviceOrientationEvent.requestPermission();
                            if (permissionState === 'granted') {
                                window.addEventListener('deviceorientation', handleOrientation, true);
                                console.log('✅ Brújula activada (iOS)');
                            } else {
                                console.log('❌ Permiso de brújula denegado');
                            }
                        } catch (error) {
                            console.error('Error requesting orientation permission:', error);
                        }
                    } else if (window.DeviceOrientationEvent) {
                        // Non-iOS or older iOS - no permission needed
                        window.addEventListener('deviceorientation', handleOrientation, true);
                        console.log('✅ Brújula activada');
                    } else {
                        console.log('❌ Brújula no soportada');
                    }
                };
                
                // On iOS, we need a user gesture to request permission
                // Add a one-time click listener to the document
                const handleFirstClick = () => {
                    requestOrientationPermission();
                    document.removeEventListener('click', handleFirstClick);
                };
                
                // For iOS: wait for first click
                if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                    document.addEventListener('click', handleFirstClick);
                } else {
                    // For Android: start immediately
                    requestOrientationPermission();
                }
                
                return () => {
                    window.removeEventListener('deviceorientation', handleOrientation, true);
                    document.removeEventListener('click', handleFirstClick);
                };
            }, []);

            // ==========================================
            // SENSOR FUSION - Listen to Motion Sensors
            // ==========================================
            useEffect(() => {
                let motionTimeout;
                
                const handleMotion = (event) => {
                    const accel = event.accelerationIncludingGravity || event.acceleration;
                    
                    if (accel) {
                        // Calcular magnitud de aceleración
                        const magnitude = Math.sqrt(
                            (accel.x || 0) ** 2 + 
                            (accel.y || 0) ** 2 + 
                            (accel.z || 0) ** 2
                        );
                        
                        // Detectar movimiento (threshold: 11 m/s² para filtrar gravedad)
                        const isMoving = magnitude > 11; // Más de 1.1g = movimiento
                        
                        // Obtener rotación
                        const rotation = event.rotationRate || { alpha: 0, beta: 0, gamma: 0 };
                        
                        setSensorData(prev => ({
                            ...prev,
                            acceleration: {
                                x: accel.x || 0,
                                y: accel.y || 0,
                                z: accel.z || 0
                            },
                            rotation: {
                                alpha: rotation.alpha || 0,
                                beta: rotation.beta || 0,
                                gamma: rotation.gamma || 0
                            },
                            isMoving: isMoving,
                            lastMotionTime: Date.now()
                        }));
                        
                        // Auto-desactivar "isMoving" después de 2 segundos sin movimiento
                        clearTimeout(motionTimeout);
                        if (isMoving) {
                            motionTimeout = setTimeout(() => {
                                setSensorData(prev => ({ ...prev, isMoving: false }));
                            }, 2000);
                        }
                    }
                };
                
                // Request permission on iOS 13+
                const requestMotionPermission = async () => {
                    if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                        try {
                            const permissionState = await DeviceMotionEvent.requestPermission();
                            if (permissionState === 'granted') {
                                window.addEventListener('devicemotion', handleMotion, true);
                                console.log('✅ Motion sensors activated');
                            }
                        } catch (error) {
                            console.error('Error requesting motion permission:', error);
                        }
                    } else if (window.DeviceMotionEvent) {
                        window.addEventListener('devicemotion', handleMotion, true);
                        console.log('✅ Motion sensors activated');
                    }
                };
                
                // Try to activate on first user interaction
                const activateOnClick = () => {
                    requestMotionPermission();
                    document.removeEventListener('click', activateOnClick);
                };
                
                document.addEventListener('click', activateOnClick);
                
                return () => {
                    window.removeEventListener('devicemotion', handleMotion, true);
                    document.removeEventListener('click', activateOnClick);
                    clearTimeout(motionTimeout);
                };
            }, []);

            // Update heading when deviceHeading changes
            useEffect(() => {
                setSensorData(prev => ({ ...prev, heading: deviceHeading }));
            }, [deviceHeading]);

            // ==========================================
            // ULTRASONIC AUTO-ACTIVATION
            // ==========================================
            useEffect(() => {
                if (!currentUser || users.length === 0) return;
                
                // Verificar si hay usuarios a menos de 5 metros
                const nearbyUsers = users.filter(u => 
                    u.id !== currentUser.id && u.distance > 0 && u.distance < 5
                );
                
                if (nearbyUsers.length > 0 && !ultrasonicActive) {
                    // Activar sistema ultrasónico
                    console.log(`🔊 ${nearbyUsers.length} usuario(s) a <5m, activando ultrasonido...`);
                    startUltrasonicDetector();
                } else if (nearbyUsers.length === 0 && ultrasonicActive) {
                    // Desactivar si no hay nadie cerca
                    console.log('❌ No hay usuarios a <5m, desactivando ultrasonido...');
                    stopUltrasonicDetector();
                }
            }, [users, currentUser, ultrasonicActive]);

            // ==========================================
            // ULTRASONIC EMISSION - Emitir señal periódicamente
            // ==========================================
            useEffect(() => {
                if (!ultrasonicActive || !currentUser || !audioContext) return;
                
                // Emitir señal cada 1 segundo
                const emitInterval = setInterval(() => {
                    emitUltrasonicSignal(currentUser.id);
                }, 1000);
                
                // Emitir inmediatamente al activarse
                emitUltrasonicSignal(currentUser.id);
                
                return () => clearInterval(emitInterval);
            }, [ultrasonicActive, currentUser, audioContext]);

            // ==========================================
            // CLEANUP - Detener ultrasonido al desmontar
            // ==========================================
            useEffect(() => {
                return () => {
                    console.log('🧹 Cleanup: Deteniendo sistema ultrasónico');
                    stopUltrasonicDetector();
                };
            }, []);

            // ==========================================
            // APP VISIBILITY - Apagar audio cuando se sale de la app
            // ==========================================
            useEffect(() => {
                const handleVisibilityChange = () => {
                    if (document.hidden) {
                        // App en background - apagar todo el audio/micrófono
                        console.log('🔇 App en background - desactivando audio/micrófono');
                        
                        // Marcar usuario como OFFLINE
                        if (currentUser) {
                            db.collection('users').doc(currentUser.id).update({
                                isOnline: false,
                                lastSeen: firebase.firestore.FieldValue.serverTimestamp()
                            }).catch(err => console.error('Error marking offline:', err));
                        }
                        
                        // Detener ultrasonido
                        if (ultrasonicActive) {
                            stopUltrasonicDetector();
                        }
                        
                        // Suspender AudioContext
                        if (audioContext && audioContext.state === 'running') {
                            audioContext.suspend().then(() => {
                                console.log('🔇 AudioContext suspendido');
                            });
                        }
                    } else {
                        // App volvió a foreground - reactivar AudioContext
                        console.log('🔊 App en foreground - reactivando audio');
                        
                        // Marcar usuario como ONLINE
                        if (currentUser) {
                            db.collection('users').doc(currentUser.id).update({
                                isOnline: true,
                                lastSeen: firebase.firestore.FieldValue.serverTimestamp()
                            }).catch(err => console.error('Error marking online:', err));
                        }
                        
                        if (audioContext && audioContext.state === 'suspended') {
                            audioContext.resume().then(() => {
                                console.log('🔊 AudioContext reactivado');
                            });
                        }
                        
                        // Re-activar ultrasonido si hay usuarios cerca
                        const nearbyUsers = users.filter(u => 
                            currentUser && u.id !== currentUser.id && u.distance > 0 && u.distance < 5
                        );
                        if (nearbyUsers.length > 0 && !ultrasonicActive) {
                            console.log('🔊 Re-activando ultrasonido (usuarios cerca)');
                            startUltrasonicDetector();
                        }
                    }
                };
                
                const handlePageHide = () => {
                    console.log('🔇 Página cerrada/oculta - limpiando recursos');
                    
                    // Marcar usuario como OFFLINE inmediatamente
                    if (currentUser) {
                        db.collection('users').doc(currentUser.id).update({
                            isOnline: false,
                            lastSeen: firebase.firestore.FieldValue.serverTimestamp()
                        }).catch(err => console.error('Error marking offline:', err));
                    }
                    
                    // Detener ultrasonido completamente
                    if (ultrasonicActive) {
                        stopUltrasonicDetector();
                    }
                    
                    // Cerrar AudioContext
                    if (audioContext) {
                        audioContext.close();
                    }
                };
                
                // Listeners
                document.addEventListener('visibilitychange', handleVisibilityChange);
                window.addEventListener('pagehide', handlePageHide);
                window.addEventListener('beforeunload', handlePageHide);
                
                return () => {
                    document.removeEventListener('visibilitychange', handleVisibilityChange);
                    window.removeEventListener('pagehide', handlePageHide);
                    window.removeEventListener('beforeunload', handlePageHide);
                };
            }, [audioContext, ultrasonicActive, users, currentUser]);

            // ==========================================
            // HEARTBEAT - Mantener isOnline actualizado cada 10 segundos
            // ==========================================
            useEffect(() => {
                if (!currentUser) return;
                
                console.log('💓 Heartbeat iniciado - Actualizando presencia cada 10s');
                
                const heartbeatInterval = setInterval(() => {
                    // Solo actualizar si la app está visible
                    if (!document.hidden) {
                        db.collection('users').doc(currentUser.id).update({
                            isOnline: true,
                            lastSeen: firebase.firestore.FieldValue.serverTimestamp()
                        }).catch(err => console.error('Heartbeat error:', err));
                        
                        console.log('💓 Heartbeat: isOnline = true');
                    }
                }, 10000); // Cada 10 segundos
                
                return () => clearInterval(heartbeatInterval);
            }, [currentUser]);

            // ==========================================
            // BROWSER BACK BUTTON - Prevenir cierre de sesión, solo cerrar chat
            // ==========================================
            useEffect(() => {
                const handlePopState = (e) => {
                    if (selectedUser) {
                        // Si hay chat abierto, solo cerrarlo
                        e.preventDefault();
                        setSelectedUser(null);
                        // Volver a agregar estado al historial
                        window.history.pushState(null, '', window.location.href);
                    }
                };
                
                // Agregar estado inicial al historial
                window.history.pushState(null, '', window.location.href);
                
                // Escuchar el botón "atrás"
                window.addEventListener('popstate', handlePopState);
                
                return () => {
                    window.removeEventListener('popstate', handlePopState);
                };
            }, [selectedUser]);

            // ==========================================
            // REAL-TIME MESSAGES LISTENER
            // ==========================================
            useEffect(() => {
                if (!currentUser) return;
                
                // Escuchar TODOS los mensajes donde el usuario actual es el receptor
                // Sin orderBy para evitar necesidad de índice compuesto
                const unsubscribe = db.collection('messages')
                    .where('receiver', '==', currentUser.id)
                    .where('read', '==', false)
                    .onSnapshot(snapshot => {
                        snapshot.docChanges().forEach(change => {
                            if (change.type === 'added') {
                                const message = change.doc.data();
                                const senderId = message.sender;
                                const messageId = change.doc.id;
                                
                                console.log(`📩 Nuevo mensaje de ${senderId}:`, message.content);
                                
                                // Marcar al remitente como que tiene mensaje nuevo
                                setUsers(prevUsers => prevUsers.map(u => 
                                    u.id === senderId ? { ...u, hasNewMessage: true } : u
                                ));
                                
                                // Agregar mensaje al estado local SOLO si no existe ya
                                const chatKey = [currentUser.id, senderId].sort().join('-');
                                setMessages(prev => {
                                    const existingMessages = prev[chatKey] || [];
                                    
                                    // Verificar si el mensaje ya existe por ID
                                    const messageExists = existingMessages.some(msg => msg.id === messageId);
                                    
                                    if (messageExists) {
                                        console.log(`⚠️ Mensaje ${messageId} ya existe, ignorando duplicado`);
                                        return prev; // No agregar duplicado
                                    }
                                    
                                    // Agregar mensaje nuevo
                                    return {
                                        ...prev,
                                        [chatKey]: [...existingMessages, {
                                            id: messageId,
                                            sender: message.sender,
                                            receiver: message.receiver,
                                            content: message.content,
                                            timestamp: message.timestamp?.toDate() || new Date(),
                                            read: false
                                        }]
                                    };
                                });
                                
                                console.log(`✅ Avatar de ${senderId} marcado con hasNewMessage = true`);
                            }
                        });
                    }, error => {
                        console.error('❌ Error listening to messages:', error);
                        console.log('Índice necesario:', error.message);
                    });
                
                return () => unsubscribe();
            }, [currentUser]);

            // ==========================================
            // LOAD MESSAGE HISTORY - Cargar historial cuando se abre chat
            // ==========================================
            useEffect(() => {
                if (!currentUser || !selectedUser) return;
                
                const loadMessageHistory = async () => {
                    try {
                        const chatKey = [currentUser.id, selectedUser.id].sort().join('-');
                        
                        // Cargar mensajes que YO envié
                        const sentMessages = await db.collection('messages')
                            .where('sender', '==', currentUser.id)
                            .where('receiver', '==', selectedUser.id)
                            .orderBy('timestamp', 'asc')
                            .limit(50)
                            .get();
                        
                        // Cargar mensajes que ME enviaron
                        const receivedMessages = await db.collection('messages')
                            .where('sender', '==', selectedUser.id)
                            .where('receiver', '==', currentUser.id)
                            .orderBy('timestamp', 'asc')
                            .limit(50)
                            .get();
                        
                        // Combinar y ordenar todos los mensajes
                        const allMessages = [
                            ...sentMessages.docs.map(doc => ({
                                id: doc.id,
                                ...doc.data(),
                                timestamp: doc.data().timestamp?.toDate() || new Date()
                            })),
                            ...receivedMessages.docs.map(doc => ({
                                id: doc.id,
                                ...doc.data(),
                                timestamp: doc.data().timestamp?.toDate() || new Date()
                            }))
                        ].sort((a, b) => a.timestamp - b.timestamp);
                        
                        setMessages(prev => ({
                            ...prev,
                            [chatKey]: allMessages
                        }));
                        
                        console.log(`📜 ${allMessages.length} mensajes cargados con ${selectedUser.name}`);
                    } catch (error) {
                        console.error('Error loading message history:', error);
                    }
                };
                
                loadMessageHistory();
            }, [selectedUser, currentUser]);

            // ==========================================
            // AUTO-SCROLL - Ir al final de los mensajes automáticamente
            // ==========================================
            useEffect(() => {
                if (!selectedUser) return;
                
                // Scroll al final cuando se abre el chat o llegan nuevos mensajes
                const scrollToBottom = () => {
                    if (chatMessagesRef.current) {
                        chatMessagesRef.current.scrollTop = chatMessagesRef.current.scrollHeight;
                        console.log('📜 Auto-scroll al último mensaje');
                    }
                };
                
                // Usar setTimeout para asegurar que el DOM se actualice primero
                const timer = setTimeout(scrollToBottom, 100);
                
                return () => clearTimeout(timer);
            }, [selectedUser, messages]);

            // Recalculate distances when user location changes
            useEffect(() => {
                if (!userLocation || !currentUser) return;
                
                // Update distances and angles for all users based on new location
                setUsers(prevUsers => {
                    return prevUsers.map(user => {
                        if (user.id === currentUser.id) {
                            // Current user - just update location
                            return {
                                ...user,
                                latitude: userLocation.latitude,
                                longitude: userLocation.longitude
                            };
                        } else if (user.latitude && user.longitude) {
                            // Other users - recalculate distance and angle
                            const gpsDistance = calculateDistance(
                                userLocation.latitude,
                                userLocation.longitude,
                                user.latitude,
                                user.longitude
                            );
                            
                            // Aplicar Hybrid Precision: GPS + Ultrasonido si está cerca
                            const finalDistance = getFinalDistance(gpsDistance, user.id);
                            
                            const angle = Math.round(
                                calculateBearing(
                                    userLocation.latitude,
                                    userLocation.longitude,
                                    user.latitude,
                                    user.longitude
                                )
                            );
                            
                            return {
                                ...user,
                                distance: Math.round(finalDistance * 10) / 10, // 1 decimal de precisión
                                angle
                            };
                        }
                        return user;
                    });
                });
            }, [userLocation, currentUser]);

            // Calculate direction to point towards closest user with message
            const getDirectionToTarget = () => {
                if (!currentUser) return 0;
                const usersWithMessages = users.filter(u => u.hasNewMessage && u.id !== currentUser.id && u.distance <= radius);
                if (usersWithMessages.length === 0) return 0;
                
                // Get closest user with message
                const closestUser = usersWithMessages.reduce((prev, current) => 
                    prev.distance < current.distance ? prev : current
                );
                
                // The indicator should point to the target's actual world position
                // Since the avatar rotates with deviceHeading to stay upright,
                // and we want the indicator to point to the absolute direction,
                // we just return the target's angle (no adjustment needed)
                return closestUser.angle;
            };

            // Play radar beep with volume based on proximity
            const playRadarBeep = (distance, hasMessage) => {
                if (!audioContext || !hasMessage) return;
                
                // Calculate volume based on how close the person is to current radius
                // If person is at edge of radar or outside: quiet
                // If person is well within radar: louder
                const proximityRatio = distance / radius;
                let volume = 0;
                
                if (proximityRatio <= 1) {
                    // Person is within radar range
                    // Volume increases as they get closer to center
                    volume = Math.max(0.1, (1 - proximityRatio) * 0.6);
                } else {
                    // Person is outside radar range
                    volume = 0;
                }
                
                // Create beep sound (like Dragon Ball scouter)
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 800; // High pitch beep
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.15);
            };

            // Continuous radar beep for users with messages
            useEffect(() => {
                if (!audioContext || !locationPermission) return;
                
                let sweepAngle = 0;
                const sweepSpeed = 360 / 6000; // 360 degrees in 6 seconds (matches CSS animation)
                const lastBeepTime = {}; // Track last beep time for each user
                const BRIGHTEST_OFFSET = 40; // The brightest part of the sweep is at +40 degrees from sweep origin
                
                const checkSweepInterval = setInterval(() => {
                    sweepAngle = (sweepAngle + (sweepSpeed * 50)) % 360; // Update every 50ms
                    
                    users.forEach(user => {
                        if (currentUser && user.hasNewMessage && user.id !== currentUser.id && user.distance <= radius) {
                            const userAngle = user.angle;
                            
                            // Calculate where the brightest part of the sweep is
                            const brightestPartAngle = (sweepAngle + BRIGHTEST_OFFSET) % 360;
                            
                            // Check if the brightest part is passing over this user
                            const angleDiff = Math.abs(brightestPartAngle - userAngle);
                            const normalizedDiff = Math.min(angleDiff, 360 - angleDiff);
                            
                            // Very tight detection window (5 degrees) for precise beeping at brightest point
                            if (normalizedDiff < 5) {
                                // Only beep if we haven't beeped for this user in the last 5.8 seconds
                                const now = Date.now();
                                if (!lastBeepTime[user.id] || now - lastBeepTime[user.id] > 5800) {
                                    playRadarBeep(user.distance, true);
                                    lastBeepTime[user.id] = now;
                                }
                            }
                        }
                    });
                }, 50); // Check every 50ms for smooth detection
                
                return () => clearInterval(checkSweepInterval);
            }, [users, radius, audioContext, locationPermission, currentUser]);

            const handleSliderMouseDown = (e) => {
                e.preventDefault();
                setIsDraggingDial(true);
                handleSliderMove(e);
            };

            const handleSliderMove = (e) => {
                const slider = document.querySelector('.range-slider-track');
                if (!slider) return;
                
                const rect = slider.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                
                // Calculate position relative to slider
                let position = (clientX - rect.left) / rect.width;
                position = Math.max(0, Math.min(1, position)); // Clamp 0-1
                
                // Map 0-1 to 5-50 meters
                const newRadius = Math.round(5 + position * 45);
                setRadius(newRadius);
            };

            const handleSliderMouseMove = (e) => {
                if (!isDraggingDial) return;
                handleSliderMove(e);
            };

            const handleSliderMouseUp = () => {
                setIsDraggingDial(false);
            };

            useEffect(() => {
                if (isDraggingDial) {
                    window.addEventListener('mousemove', handleSliderMouseMove);
                    window.addEventListener('mouseup', handleSliderMouseUp);
                    window.addEventListener('touchmove', handleSliderMouseMove);
                    window.addEventListener('touchend', handleSliderMouseUp);
                    
                    return () => {
                        window.removeEventListener('mousemove', handleSliderMouseMove);
                        window.removeEventListener('mouseup', handleSliderMouseUp);
                        window.removeEventListener('touchmove', handleSliderMouseMove);
                        window.removeEventListener('touchend', handleSliderMouseUp);
                    };
                }
            }, [isDraggingDial]);

            const requestLocation = () => {
                setLocationPermission(true);
            };

            const updateThought = async () => {
                if (currentUser && thought.trim()) {
                    const thoughtData = {
                        text: thought.trim(),
                        timestamp: Date.now()
                    };
                    
                    // Update local state immediately for instant feedback
                    const updatedCurrentUser = { 
                        ...currentUser, 
                        thought: thoughtData.text, 
                        thoughtTimestamp: thoughtData.timestamp 
                    };
                    
                    setCurrentUser(updatedCurrentUser);
                    setUsers(prevUsers => prevUsers.map(u => 
                        u.id === currentUser.id ? updatedCurrentUser : u
                    ));
                    
                    // Clear input immediately
                    setThought('');
                    
                    // Save to Firebase if user is authenticated
                    const user = auth.currentUser;
                    if (user) {
                        try {
                            await db.collection('users').doc(user.uid).set({
                                thought: thoughtData.text,
                                thoughtTimestamp: firebase.firestore.FieldValue.serverTimestamp()
                            }, { merge: true });
                            
                            console.log('✅ Pensamiento publicado:', thoughtData.text);
                        } catch (error) {
                            console.error('Error updating thought:', error);
                        }
                    }
                }
            };
            
            // Check if thought is expired (24 hours)
            const isThoughtExpired = (timestamp) => {
                if (!timestamp) return true;
                const now = Date.now();
                const thoughtTime = timestamp.toMillis ? timestamp.toMillis() : timestamp;
                const hoursPassed = (now - thoughtTime) / (1000 * 60 * 60);
                return hoursPassed >= 24;
            };

            const handleAvatarClick = async (user) => {
                if (currentUser && user.id !== currentUser.id) {
                    if (user.hasStory) {
                        setViewingStory(user);
                    } else {
                        setSelectedUser(user);
                        
                        // Marcar mensaje como leído localmente
                        setUsers(users.map(u => 
                            u.id === user.id ? { ...u, hasNewMessage: false } : u
                        ));
                        
                        // Marcar mensajes como leídos en Firestore
                        try {
                            const messagesSnapshot = await db.collection('messages')
                                .where('sender', '==', user.id)
                                .where('receiver', '==', currentUser.id)
                                .where('read', '==', false)
                                .get();
                            
                            const batch = db.batch();
                            messagesSnapshot.docs.forEach(doc => {
                                batch.update(doc.ref, { read: true });
                            });
                            await batch.commit();
                            
                            console.log(`✅ Mensajes de ${user.name} marcados como leídos`);
                        } catch (error) {
                            console.error('Error marking messages as read:', error);
                        }
                    }
                }
            };

            const sendMessage = async () => {
                if ((!messageInput.trim() && !selectedImage) || !selectedUser || !currentUser) return;

                const chatKey = [currentUser.id, selectedUser.id].sort().join('-');
                let imageUrl = null;

                try {
                    // Si hay imagen, subirla primero
                    if (selectedImage) {
                        console.log('📤 Subiendo imagen...', selectedImage.name);
                        
                        const storageRef = storage.ref();
                        const imageRef = storageRef.child(`chat-images/${currentUser.id}/${Date.now()}_${selectedImage.name}`);
                        
                        const uploadTask = await imageRef.put(selectedImage);
                        imageUrl = await uploadTask.ref.getDownloadURL();
                        
                        console.log('✅ Imagen subida:', imageUrl);
                    }

                    const newMessage = {
                        sender: currentUser.id,
                        receiver: selectedUser.id,
                        content: messageInput.trim() || (imageUrl ? '📷 Imagen' : ''),
                        imageUrl: imageUrl,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                        read: false
                    };

                    console.log(`📤 Enviando mensaje a ${selectedUser.name} (${selectedUser.id})`);
                    console.log('Contenido:', messageInput.trim() || '📷 Imagen');

                    // Guardar mensaje en Firestore
                    const docRef = await db.collection('messages').add(newMessage);
                    
                    console.log(`✅ Mensaje guardado en Firestore con ID: ${docRef.id}`);
                    console.log(`Receptor: ${selectedUser.id}`);
                    
                    // Actualizar estado local inmediatamente para feedback
                    setMessages(prev => ({
                        ...prev,
                        [chatKey]: [...(prev[chatKey] || []), {
                            ...newMessage,
                            id: docRef.id,
                            timestamp: new Date()
                        }]
                    }));

                    setMessageInput('');
                    setSelectedImage(null);
                } catch (error) {
                    console.error('❌ Error enviando mensaje:', error);
                    alert('Error al enviar mensaje: ' + error.message);
                }
            };

            if (!locationPermission) {
                return (
                    <div className="location-permission">
                        <div className="permission-card">
                            <svg className="permission-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
                            </svg>
                            <h2>Ubicación Requerida</h2>
                            <p>Radar Social necesita acceso a tu ubicación para mostrarte personas cercanas y conectar con ellas.</p>
                            <button className="permission-btn" onClick={requestLocation}>
                                Permitir Ubicación
                            </button>
                        </div>
                    </div>
                );
            }

            return (
                <>
                    <div className="header">
                        <div className="header-left">
                            <svg className="header-icon" onClick={() => setShowSidebar(true)} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 12h16M4 18h16" />
                            </svg>
                            {/* Online Badge debajo del menú */}
                            <div className="online-badge-menu">
                                <div className="online-badge-dot"></div>
                                <span>ONLINE</span>
                            </div>
                        </div>
                        <div style={{ width: 28 }}></div>
                        <div style={{ position: 'relative' }}>
                            <svg className="header-icon" onClick={() => setShowInbox(true)} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
                            </svg>
                            {/* Badge de mensajes sin leer */}
                            {(() => {
                                const unreadCount = users.filter(u => u.hasNewMessage).length;
                                return unreadCount > 0 ? (
                                    <div style={{
                                        position: 'absolute',
                                        top: -4,
                                        right: -4,
                                        background: '#ef4444',
                                        color: '#fff',
                                        fontSize: 9,
                                        fontWeight: 700,
                                        width: 16,
                                        height: 16,
                                        borderRadius: '50%',
                                        display: 'flex',
                                        alignItems: 'center',
                                        justifyContent: 'center',
                                        border: '2px solid #0d1117'
                                    }}>
                                        {unreadCount}
                                    </div>
                                ) : null;
                            })()}
                        </div>
                    </div>

                    <div className="main-container">
                        {/* Precision Badge - Top Right Corner */}
                        <div className="tech-badges-container">
                            <div className={`tech-badge precision ${ultrasonicActive && ultrasonicDetections.nearby ? 'ultrasonic-active' : ''}`}>
                                {ultrasonicActive && ultrasonicDetections.nearby ? '🔊' : (sensorData.isMoving ? '🧠' : '📍')} 
                                {' '}±{ultrasonicActive && ultrasonicDetections.nearby ? 
                                    (ultrasonicDetections.nearby < 1 ? '0.5' : ultrasonicDetections.nearby.toFixed(1)) : 
                                    locationAccuracy.toFixed(1)
                                }m
                            </div>
                        </div>
                        
                        <div className="radar-container">
                            {/* People Counter */}
                            <div className="radar-info">
                                <div className="radar-info-count">
                                    {currentUser ? users.filter(u => u.id !== currentUser.id && u.distance <= radius).length : 0}
                                </div>
                                <div className="radar-info-title">Personas cerca de ti</div>
                            </div>

                            <div className="radar-bg">
                                <div className="radar-grid">
                                    {(() => {
                                        // Generate circles based on current radius
                                        const circles = [];
                                        const numCircles = 5;
                                        const interval = radius / numCircles;
                                        
                                        for (let i = 1; i <= numCircles; i++) {
                                            const meters = Math.round(interval * i);
                                            const percent = (i / numCircles) * 100;
                                            
                                            circles.push(
                                                <div key={`circle-${i}`}>
                                                    <div
                                                        className="radar-circle"
                                                        style={{
                                                            width: `${percent}%`,
                                                            height: `${percent}%`,
                                                            transition: 'all 0.4s ease'
                                                        }}
                                                    />
                                                    <div 
                                                        className="distance-label"
                                                        style={{
                                                            top: `${50 - (percent / 2)}%`,
                                                            left: '50%',
                                                            transition: 'all 0.4s ease'
                                                        }}
                                                    >
                                                        {meters}m
                                                    </div>
                                                </div>
                                            );
                                        }
                                        return circles;
                                    })()}
                                    {[0, 45, 90, 135].map(angle => (
                                        <div
                                            key={angle}
                                            className="radar-line"
                                            style={{ transform: `translateX(-50%) rotate(${angle}deg)` }}
                                        />
                                    ))}
                                    
                                    <div className="radar-sweep"></div>
                                </div>

                                {users
                                    .filter(user => currentUser && (user.id === currentUser.id || user.distance <= radius))
                                    .map(user => {
                                        const isCenter = currentUser && user.id === currentUser.id;
                                        
                                        // Calculate position based on distance, angle, and current zoom (radius)
                                        let x = 0, y = 0;
                                        if (!isCenter) {
                                            // IMPROVED POSITIONING ALGORITHM
                                            // Dead zone: minimum 15% (prevents overlap with center avatar)
                                            // Max zone: 45% (uses more radar space)
                                            // Formula: maps distance to 15%-45% range
                                            
                                            const MIN_PERCENTAGE = 15; // Dead zone around center
                                            const MAX_PERCENTAGE = 45; // Max usable area
                                            
                                            // Linear mapping: 0m → 15%, radius → 45%
                                            let percentage = MIN_PERCENTAGE + (user.distance / radius) * (MAX_PERCENTAGE - MIN_PERCENTAGE);
                                            percentage = Math.min(percentage, MAX_PERCENTAGE);
                                            
                                            const angleRad = (user.angle - 90) * (Math.PI / 180);
                                            x = percentage * Math.cos(angleRad);
                                            y = percentage * Math.sin(angleRad);
                                        }
                                        
                                        // Avatar sizing
                                        // Center avatar: fixed medium size
                                        // Other users: fixed small size (consistent regardless of zoom)
                                        let scale = 1.0;
                                        if (!isCenter) {
                                            // Fixed small size for all other avatars (like when radius is at 50m)
                                            scale = 0.6;
                                        }
                                        // Center avatar stays at normal size (scale = 1.0)
                                        // Center avatar is always fixed size (no scaling)
                                        
                                        return (
                                            <div
                                                key={user.id}
                                                className={`avatar-container ${isCenter ? 'center-avatar-fixed' : ''}`}
                                                style={isCenter ? {} : {
                                                    left: `calc(50% + ${x}%)`,
                                                    top: `calc(50% + ${y}%)`,
                                                    transform: `scale(${scale})`,
                                                    opacity: user.distance <= radius ? 1 : 0,
                                                    zIndex: 10 - Math.floor(user.distance / 10),
                                                    transition: 'left 2s ease-out, top 2s ease-out, transform 0.4s ease, opacity 0.4s ease'
                                                }}
                                                onClick={() => handleAvatarClick(user)}
                                            >
                                                <div className={`avatar-wrapper ${isCenter ? 'center-avatar' : 'regular-avatar'}`}>
                                                    {user.thought && (
                                                        <div className="avatar-thought">{user.thought}</div>
                                                    )}
                                                    <div 
                                                        className={`avatar-ring ${
                                                            user.hasNewMessage ? 'new-message' : 
                                                            user.hasStory ? 'has-story' : 'no-story'
                                                        }`}
                                                        style={isCenter ? { transform: `rotate(${deviceHeading}deg)` } : {}}
                                                    >
                                                        <div className="avatar-img-wrapper" style={isCenter ? { transform: `rotate(${-deviceHeading}deg)` } : {}}>
                                                            <img src={user.photo} alt={user.name} className="avatar-img" />
                                                        </div>
                                                        {isCenter && (
                                                            <div className="direction-indicator" />
                                                        )}
                                                        {user.hasNewMessage && (
                                                            <div className="message-badge">1</div>
                                                        )}
                                                    </div>
                                                    {!isCenter && (
                                                        <>
                                                            <div className="avatar-name">{user.name}</div>
                                                            <div className="avatar-distance">
                                                                {user.distance < 1 && ultrasonicActive ? 
                                                                    `${user.distance.toFixed(1)} m 🔊` : 
                                                                    `${Math.round(user.distance)} m`
                                                                }
                                                            </div>
                                                        </>
                                                    )}
                                                </div>
                                            </div>
                                        );
                                    })}

                                {/* Compass Cardinal Directions - Fixed decorative */}
                                <div className="compass-label compass-n">N</div>
                                <div className="compass-label compass-s">S</div>
                                <div className="compass-label compass-e">E</div>
                                <div className="compass-label compass-o">O</div>
                            </div>

                            {/* Horizontal Range Slider */}
                            <div className="range-slider-container">
                                <div className="range-slider-label">
                                    <div className="range-slider-title">Radio de Búsqueda</div>
                                    <div className="range-slider-value">{radius}m</div>
                                </div>
                                
                                <div 
                                    className="range-slider-track"
                                    onMouseDown={handleSliderMouseDown}
                                    onTouchStart={handleSliderMouseDown}
                                >
                                    <div 
                                        className="range-slider-progress"
                                        style={{ width: `${((radius - 5) / 45) * 100}%` }}
                                    />
                                    <div 
                                        className="range-slider-thumb"
                                        style={{ left: `${((radius - 5) / 45) * 100}%` }}
                                    />
                                </div>
                                
                                <div className="range-slider-marks">
                                    <div className="range-slider-mark">5m</div>
                                    <div className="range-slider-mark">15m</div>
                                    <div className="range-slider-mark">30m</div>
                                    <div className="range-slider-mark">50m</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div className="bottom-bar">
                        <div className="thought-input-container">
                            <input
                                type="text"
                                className="thought-input"
                                placeholder="Escribe un pensamiento..."
                                value={thought}
                                onChange={(e) => setThought(e.target.value.slice(0, 50))}
                                onKeyPress={(e) => {
                                    if (e.key === 'Enter') {
                                        updateThought();
                                    }
                                }}
                                maxLength={50}
                            />
                            <div className="send-button" onClick={updateThought}>
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" />
                                </svg>
                            </div>
                        </div>
                    </div>

                    {/* Inbox Overlay - Lista de Mensajes */}
                    {showInbox && (
                        <div className={`inbox-overlay ${showInbox ? 'active' : ''}`}>
                            <div className="inbox-header">
                                <svg onClick={() => setShowInbox(false)} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2.5} d="M15 19l-7-7 7-7" />
                                </svg>
                                <h2>Mensajes</h2>
                            </div>

                            <div className="inbox-list">
                                {(() => {
                                    // Obtener todos los usuarios con los que hay chat
                                    const chatUsers = users.filter(u => {
                                        if (!currentUser || u.id === currentUser.id) return false;
                                        const chatKey = [currentUser.id, u.id].sort().join('-');
                                        return messages[chatKey] && messages[chatKey].length > 0;
                                    });

                                    if (chatUsers.length === 0) {
                                        return (
                                            <div className="inbox-empty">
                                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
                                                </svg>
                                                <p>No tienes mensajes todavía</p>
                                                <p style={{ fontSize: 13, marginTop: 8, opacity: 0.7 }}>
                                                    Toca un avatar en el radar para iniciar un chat
                                                </p>
                                            </div>
                                        );
                                    }

                                    return chatUsers.map(user => {
                                        const chatKey = [currentUser.id, user.id].sort().join('-');
                                        const chatMessages = messages[chatKey] || [];
                                        const lastMessage = chatMessages[chatMessages.length - 1];
                                        
                                        return (
                                            <div
                                                key={user.id}
                                                className={`inbox-item ${user.hasNewMessage ? 'unread' : ''}`}
                                                onClick={() => {
                                                    setShowInbox(false);
                                                    setSelectedUser(user);
                                                }}
                                            >
                                                <img src={user.photo} alt={user.name} className="inbox-avatar" />
                                                <div className="inbox-info">
                                                    <div className="inbox-name">
                                                        {user.name}
                                                        {user.hasNewMessage && (
                                                            <span style={{ fontSize: 18 }}>💛</span>
                                                        )}
                                                    </div>
                                                    <div className="inbox-preview">
                                                        {lastMessage ? lastMessage.content : 'Sin mensajes'}
                                                    </div>
                                                </div>
                                                <div className="inbox-meta">
                                                    <div className="inbox-distance">{Math.round(user.distance)} m</div>
                                                    {user.hasNewMessage && (
                                                        <div className="inbox-unread-badge">1</div>
                                                    )}
                                                </div>
                                            </div>
                                        );
                                    });
                                })()}
                            </div>
                        </div>
                    )}

                    {selectedUser && (
                        <div className={`chat-overlay ${selectedUser ? 'active' : ''}`}>
                            <div className="chat-header">
                                <svg onClick={() => setSelectedUser(null)} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2.5} d="M15 19l-7-7 7-7" />
                                </svg>
                                <div className="chat-user-info">
                                    <img src={selectedUser.photo} alt={selectedUser.name} className="chat-user-avatar" />
                                    <div className="chat-user-details">
                                        <h3>{selectedUser.name}</h3>
                                        <p>{selectedUser.distance} m de distancia</p>
                                    </div>
                                </div>
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <circle cx="12" cy="12" r="1.5"/>
                                    <circle cx="12" cy="5" r="1.5"/>
                                    <circle cx="12" cy="19" r="1.5"/>
                                </svg>
                            </div>

                            {selectedUser.thought && (
                                <div className="chat-thought-display">
                                    <span style={{ fontSize: '17px' }}>⚡</span>
                                    {selectedUser.thought}
                                </div>
                            )}

                            <div className="chat-content">
                                <div className="chat-messages" ref={chatMessagesRef}>
                                    {(() => {
                                        const chatKey = [currentUser.id, selectedUser.id].sort().join('-');
                                        const chatMessages = messages[chatKey] || [];
                                        
                                        return (
                                            <>
                                                {chatMessages.length === 0 && (
                                                    <div className="chat-info">
                                                        Esta persona está cerca de ti. ¡Envía un mensaje para iniciar una conversación!
                                                    </div>
                                                )}
                                                
                                                {chatMessages.map(msg => {
                                                    const messageTime = msg.timestamp ? 
                                                        new Date(msg.timestamp).toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' }) 
                                                        : '';
                                                    const isSent = msg.sender === currentUser.id;
                                                    
                                                    return (
                                                        <div
                                                            key={msg.id}
                                                            className={`message ${isSent ? 'sent' : 'received'}`}
                                                        >
                                                            {msg.imageUrl && (
                                                                <img 
                                                                    src={msg.imageUrl} 
                                                                    alt="Imagen enviada" 
                                                                    style={{
                                                                        maxWidth: '250px',
                                                                        maxHeight: '250px',
                                                                        borderRadius: '8px',
                                                                        marginBottom: msg.content ? '6px' : '0',
                                                                        cursor: 'pointer',
                                                                        display: 'block'
                                                                    }}
                                                                    onClick={() => window.open(msg.imageUrl, '_blank')}
                                                                />
                                                            )}
                                                            {msg.content && (
                                                                <span style={{ 
                                                                    display: 'inline',
                                                                    marginRight: '50px' 
                                                                }}>
                                                                    {msg.content}
                                                                </span>
                                                            )}
                                                            <span className="message-time">
                                                                {messageTime}
                                                                {isSent && (
                                                                    <span className="message-status">
                                                                        ✓✓
                                                                    </span>
                                                                )}
                                                            </span>
                                                        </div>
                                                    );
                                                })}
                                            </>
                                        );
                                    })()}
                                </div>

                                <div className="chat-input-container">
                                    <input
                                        type="file"
                                        accept="image/*"
                                        style={{ display: 'none' }}
                                        id={`image-input-${selectedUser?.id}`}
                                        onChange={(e) => {
                                            const file = e.target.files[0];
                                            if (file) {
                                                setSelectedImage(file);
                                                console.log('📷 Imagen seleccionada:', file.name);
                                            }
                                        }}
                                    />
                                    {selectedImage && (
                                        <div style={{
                                            position: 'absolute',
                                            bottom: '70px',
                                            left: '16px',
                                            right: '16px',
                                            background: 'rgba(22, 27, 34, 0.95)',
                                            borderRadius: '12px',
                                            padding: '12px',
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: '12px',
                                            border: '1px solid rgba(56, 189, 98, 0.3)'
                                        }}>
                                            <div style={{
                                                fontSize: '24px'
                                            }}>📷</div>
                                            <div style={{
                                                flex: 1,
                                                fontSize: '13px',
                                                color: '#c9d1d9'
                                            }}>
                                                {selectedImage?.name}
                                            </div>
                                            <div
                                                onClick={() => setSelectedImage(null)}
                                                style={{
                                                    width: '28px',
                                                    height: '28px',
                                                    borderRadius: '50%',
                                                    background: 'rgba(239, 68, 68, 0.2)',
                                                    display: 'flex',
                                                    alignItems: 'center',
                                                    justifyContent: 'center',
                                                    cursor: 'pointer',
                                                    border: '1px solid rgba(239, 68, 68, 0.3)'
                                                }}
                                            >
                                                <svg width="16" height="16" fill="none" stroke="#ef4444" viewBox="0 0 24 24">
                                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2.5} d="M6 18L18 6M6 6l12 12" />
                                                </svg>
                                            </div>
                                        </div>
                                    )}
                                    <div 
                                        className="btn-round" 
                                        onClick={() => document.getElementById(`image-input-${selectedUser?.id}`).click()}
                                    >
                                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            {selectedImage ? (
                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                                            ) : (
                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
                                            )}
                                        </svg>
                                    </div>
                                    <textarea
                                        className="chat-input"
                                        placeholder={selectedImage ? "💬 Añade un mensaje (opcional)" : "Escribe tu respuesta..."}
                                        value={messageInput}
                                        onChange={(e) => setMessageInput(e.target.value)}
                                        rows="1"
                                    />
                                    <button
                                        className="chat-send-btn"
                                        onClick={sendMessage}
                                        disabled={!messageInput.trim() && !selectedImage}
                                    >
                                        <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" />
                                        </svg>
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Backdrop for sidebar */}
                    <div className={`overlay-backdrop ${showSidebar ? 'active' : ''}`} onClick={() => setShowSidebar(false)}></div>

                    {/* Sidebar */}
                    <div className={`sidebar ${showSidebar ? 'active' : ''}`}>
                        <div className="sidebar-header">
                            <h2>Menú</h2>
                            <svg onClick={() => setShowSidebar(false)} style={{ cursor: 'pointer', width: '24px', height: '24px', color: '#8b949e' }} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2.5} d="M6 18L18 6M6 6l12 12" />
                            </svg>
                        </div>
                        <div className="sidebar-content">
                            <div className="sidebar-item" onClick={() => { setShowSidebar(false); setShowProfile(true); }}>
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
                                </svg>
                                <span>Mi Perfil</span>
                            </div>
                            <div className="sidebar-item">
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z" />
                                </svg>
                                <span>Amigos</span>
                            </div>
                            <div className="sidebar-item">
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
                                </svg>
                                <span>Mensajes</span>
                            </div>
                            <div className="sidebar-item" onClick={() => { setShowSidebar(false); setShowTechSettings(true); }}>
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 3v2m6-2v2M9 19v2m6-2v2M5 9H3m2 6H3m18-6h-2m2 6h-2M7 19h10a2 2 0 002-2V7a2 2 0 00-2-2H7a2 2 0 00-2 2v10a2 2 0 002 2zM9 9h6v6H9V9z" />
                                </svg>
                                <span>Tecnologías</span>
                            </div>
                            <div className="sidebar-item">
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                                </svg>
                                <span>Configuración</span>
                            </div>
                            <div className="sidebar-item">
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                                </svg>
                                <span>Ayuda</span>
                            </div>
                        </div>
                    </div>

                    {/* Profile */}
                    <div className={`profile-overlay ${showProfile ? 'active' : ''}`}>
                        <div className="profile-header">
                            <svg onClick={() => setShowProfile(false)} style={{ cursor: 'pointer', width: '26px', height: '26px', color: '#8b949e' }} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2.5} d="M15 19l-7-7 7-7" />
                            </svg>
                            <h2 style={{ fontSize: '18px', fontWeight: 600, color: '#f0f6fc' }}>Mi Perfil</h2>
                        </div>
                        <div className="profile-content">
                            <div className="profile-avatar-section">
                                <img src={currentUser?.photo || 'https://i.pravatar.cc/150?img=33'} alt="Profile" className="profile-avatar-large" />
                                <div className="profile-name">{currentUser?.name || 'Usuario'}</div>
                                <div className="profile-bio">{currentUser?.thought || 'Sin estado'}</div>
                            </div>
                            
                            <div className="profile-section">
                                <div className="profile-section-title">Información Personal</div>
                                <div className="profile-field">
                                    <span className="profile-field-label">Nombre</span>
                                    <span className="profile-field-value">{currentUser?.name || 'Usuario'}</span>
                                </div>
                                {currentUser?.email && (
                                    <div className="profile-field">
                                        <span className="profile-field-label">Email</span>
                                        <span className="profile-field-value">{currentUser.email}</span>
                                    </div>
                                )}
                                <div className="profile-field">
                                    <span className="profile-field-label">Edad</span>
                                    <span className="profile-field-value">{currentUser?.age || 25} años</span>
                                </div>
                                <div className="profile-field">
                                    <span className="profile-field-label">Ubicación</span>
                                    <span className="profile-field-value">Panamá, PA</span>
                                </div>
                            </div>

                            <div className="profile-section">
                                <div className="profile-section-title">Estadísticas</div>
                                <div className="profile-field">
                                    <span className="profile-field-label">Conexiones</span>
                                    <span className="profile-field-value">{users.length - 1} personas cercanas</span>
                                </div>
                                <div className="profile-field">
                                    <span className="profile-field-label">Chats activos</span>
                                    <span className="profile-field-value">{Object.keys(chats).length}</span>
                                </div>
                                <div className="profile-field">
                                    <span className="profile-field-label">Estados compartidos</span>
                                    <span className="profile-field-value">3 hoy</span>
                                </div>
                            </div>

                            <div className="profile-section">
                                <button 
                                    onClick={async () => {
                                        if (confirm('¿Cerrar sesión? Dejarás de aparecer en el radar.')) {
                                            try {
                                                await auth.signOut();
                                                window.location.href = 'auth.html';
                                            } catch (error) {
                                                console.error('Error signing out:', error);
                                            }
                                        }
                                    }}
                                    style={{
                                        width: '100%',
                                        padding: '14px',
                                        background: 'rgba(239, 68, 68, 0.1)',
                                        border: '1px solid rgba(239, 68, 68, 0.3)',
                                        borderRadius: '12px',
                                        color: '#ef4444',
                                        fontSize: '15px',
                                        fontWeight: 600,
                                        cursor: 'pointer',
                                        transition: 'all 0.2s ease',
                                        display: 'flex',
                                        alignItems: 'center',
                                        justifyContent: 'center',
                                        gap: '8px'
                                    }}
                                    onMouseOver={(e) => {
                                        e.target.style.background = 'rgba(239, 68, 68, 0.15)';
                                        e.target.style.borderColor = 'rgba(239, 68, 68, 0.4)';
                                    }}
                                    onMouseOut={(e) => {
                                        e.target.style.background = 'rgba(239, 68, 68, 0.1)';
                                        e.target.style.borderColor = 'rgba(239, 68, 68, 0.3)';
                                    }}
                                >
                                    <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" />
                                    </svg>
                                    Cerrar Sesión
                                </button>
                            </div>
                        </div>
                    </div>

                    {/* Tech Settings Overlay */}
                    <div className={`tech-settings-overlay ${showTechSettings ? 'active' : ''}`}>
                        <div className="tech-settings-header">
                            <svg onClick={() => setShowTechSettings(false)} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2.5} d="M15 19l-7-7 7-7" />
                            </svg>
                            <h2>Configuración de Tecnologías</h2>
                        </div>
                        <div className="tech-settings-content">
                            {/* Mode Selector */}
                            <div className="tech-mode-selector">
                                <h3>Modo de Operación</h3>
                                <div className="tech-mode-options">
                                    <div 
                                        className={`tech-mode-option ${techSettings.mode === 'auto' ? 'active' : ''}`}
                                        onClick={() => setTechSettings({...techSettings, mode: 'auto'})}
                                    >
                                        <div className="icon">🤖</div>
                                        <div className="label">Automático</div>
                                        <div className="description">Combina todas las tecnologías</div>
                                    </div>
                                    <div 
                                        className={`tech-mode-option ${techSettings.mode === 'manual' ? 'active' : ''}`}
                                        onClick={() => setTechSettings({...techSettings, mode: 'manual'})}
                                    >
                                        <div className="icon">⚙️</div>
                                        <div className="label">Manual</div>
                                        <div className="description">Selecciona individualmente</div>
                                    </div>
                                </div>
                            </div>

                            {/* Individual Technologies */}
                            <div className="tech-list">
                                <h3>Tecnologías Disponibles</h3>
                                
                                {/* GPS */}
                                <div className={`tech-item ${techSettings.mode === 'auto' ? 'disabled' : ''}`}>
                                    <div className="tech-item-info">
                                        <div className="tech-item-name">
                                            <span className="tech-item-icon">📍</span>
                                            GPS
                                        </div>
                                        <div className="tech-item-description">
                                            Ubicación satelital precisa. Precisión: ±5-10m en exteriores.
                                        </div>
                                    </div>
                                    <div 
                                        className={`tech-toggle ${techSettings.mode === 'manual' && techSettings.gps ? 'active' : ''}`}
                                        onClick={() => {
                                            if (techSettings.mode === 'manual') {
                                                setTechSettings({...techSettings, gps: !techSettings.gps});
                                            }
                                        }}
                                    ></div>
                                </div>

                                {/* Kalman Filter */}
                                <div className={`tech-item ${techSettings.mode === 'auto' ? 'disabled' : ''}`}>
                                    <div className="tech-item-info">
                                        <div className="tech-item-name">
                                            <span className="tech-item-icon">🎯</span>
                                            Filtro Kalman
                                        </div>
                                        <div className="tech-item-description">
                                            Suaviza datos GPS reduciendo ruido. Mejora precisión cuando estás quieto.
                                        </div>
                                    </div>
                                    <div 
                                        className={`tech-toggle ${techSettings.mode === 'manual' && techSettings.kalman ? 'active' : ''}`}
                                        onClick={() => {
                                            if (techSettings.mode === 'manual') {
                                                setTechSettings({...techSettings, kalman: !techSettings.kalman});
                                            }
                                        }}
                                    ></div>
                                </div>

                                {/* Dead Reckoning */}
                                <div className={`tech-item ${techSettings.mode === 'auto' ? 'disabled' : ''}`}>
                                    <div className="tech-item-info">
                                        <div className="tech-item-name">
                                            <span className="tech-item-icon">🧠</span>
                                            Dead Reckoning
                                        </div>
                                        <div className="tech-item-description">
                                            Usa acelerómetro y giroscopio para estimar movimiento. Útil en interiores.
                                        </div>
                                    </div>
                                    <div 
                                        className={`tech-toggle ${techSettings.mode === 'manual' && techSettings.deadReckoning ? 'active' : ''}`}
                                        onClick={() => {
                                            if (techSettings.mode === 'manual') {
                                                setTechSettings({...techSettings, deadReckoning: !techSettings.deadReckoning});
                                            }
                                        }}
                                    ></div>
                                </div>

                                {/* Ultrasonic */}
                                <div className={`tech-item ${techSettings.mode === 'auto' ? 'disabled' : ''}`}>
                                    <div className="tech-item-info">
                                        <div className="tech-item-name">
                                            <span className="tech-item-icon">🔊</span>
                                            Ultrasonido
                                        </div>
                                        <div className="tech-item-description">
                                            Alta precisión (±0.1-1m) a corta distancia (&lt;5m). Requiere micrófono.
                                        </div>
                                    </div>
                                    <div 
                                        className={`tech-toggle ${techSettings.mode === 'manual' && techSettings.ultrasonic ? 'active' : ''}`}
                                        onClick={() => {
                                            if (techSettings.mode === 'manual') {
                                                setTechSettings({...techSettings, ultrasonic: !techSettings.ultrasonic});
                                            }
                                        }}
                                    ></div>
                                </div>
                            </div>

                            {/* Info Note */}
                            <div className="tech-info-note">
                                <h4>
                                    <svg width="16" height="16" fill="currentColor" viewBox="0 0 24 24">
                                        <path d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                    </svg>
                                    Modo Automático
                                </h4>
                                <p>
                                    En modo automático, el sistema combina todas las tecnologías inteligentemente para darte la mejor precisión posible según tu situación (interiores, exteriores, movimiento, etc.).
                                </p>
                            </div>
                        </div>
                    </div>

                    {/* Story Viewer */}
                    {viewingStory && (
                        <div className={`story-viewer ${viewingStory ? 'active' : ''}`}>
                            <div className="story-circle">
                                <div className="story-close" onClick={() => setViewingStory(null)}>
                                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2.5} d="M6 18L18 6M6 6l12 12" />
                                    </svg>
                                </div>
                                <div className="story-user-info">
                                    <img src={viewingStory.photo} alt={viewingStory.name} className="story-user-avatar" />
                                    <span className="story-user-name">{viewingStory.name}</span>
                                </div>
                                <img 
                                    src={viewingStory.photo} 
                                    alt={`${viewingStory.name}'s story`} 
                                    className="story-image"
                                />
                            </div>
                        </div>
                    )}
                </>
            );
        }

        ReactDOM.render(<RadarSocialApp />, document.getElementById('root'));

        // Register Service Worker for PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/service-worker.js')
                    .then(registration => {
                        console.log('Service Worker registrado:', registration);
                    })
                    .catch(error => {
                        console.log('Error al registrar Service Worker:', error);
                    });
            });
        }
    </script>
</body>
</html>
