<script type="text/babel">
    const { useState, useEffect, useRef } = React;

    // Firebase Config
    const firebaseConfig = {
        apiKey: "AIzaSyAhcfX0M5oqX7rZ6WdCZaHfxHKcxySxQl8",
        authDomain: "radar-social-5a61f.firebaseapp.com",
        projectId: "radar-social-5a61f",
        storageBucket: "radar-social-5a61f.firebasestorage.app",
        messagingSenderId: "1010787643000",
        appId: "1:1010787643000:web:e9dc6a1c175d875b90478d"
    };
    
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();
    const storage = firebase.storage();

    function RadarSocialApp() {
        // State
        const [showLanding, setShowLanding] = useState(true);
        const [radius, setRadius] = useState(1000); // hasta 1km
        const [thought, setThought] = useState('');
        const [currentUser, setCurrentUser] = useState(null);
        const [userLocation, setUserLocation] = useState(null);
        const [users, setUsers] = useState([]);
        const [selectedUser, setSelectedUser] = useState(null);
        const [showInstagramModal, setShowInstagramModal] = useState(false);
        const [instagramModalUser, setInstagramModalUser] = useState(null);
        const [quickMessage, setQuickMessage] = useState('');
        const [messages, setMessages] = useState({});
        const [messageInput, setMessageInput] = useState('');
        const [showSidebar, setShowSidebar] = useState(false);
        const [showProfile, setShowProfile] = useState(false);
        const [showInbox, setShowInbox] = useState(false);
        const [showTechSettings, setShowTechSettings] = useState(false);
        const [showStoryUpload, setShowStoryUpload] = useState(false);
        const [storyImage, setStoryImage] = useState(null);
        const [uploadingStory, setUploadingStory] = useState(false);
        const [viewingStory, setViewingStory] = useState(null);
        const [viewedStories, setViewedStories] = useState({});
        const [socialNotifications, setSocialNotifications] = useState([]);
        const [googleMap, setGoogleMap] = useState(null);
        const [waitingForGPS, setWaitingForGPS] = useState(true);
        const [locationAccuracy, setLocationAccuracy] = useState(20);
        const [isDraggingDial, setIsDraggingDial] = useState(false);
        const [enteringUsers, setEnteringUsers] = useState(new Set());
        const [lastSeenUsers, setLastSeenUsers] = useState({});
        
        const [techSettings, setTechSettings] = useState({
            mode: 'auto', gps: true, kalman: true, deadReckoning: true, ultrasonic: true
        });
        const [activeTech, setActiveTech] = useState({ name: 'GPS', icon: 'ðŸ“', precision: 5.0 });
        
        const mapRef = useRef(null);
        const chatMessagesRef = useRef(null);
        const markersRef = useRef([]);
        const lastMarkersDataRef = useRef('');
        const currentUserPositionRef = useRef({ lat: 0, lng: 0 });

        // Calcular distancia en metros (Haversine)
        const calculateDistance = (lat1, lon1, lat2, lon2) => {
            const R = 6371e3;
            const Ï†1 = lat1 * Math.PI / 180;
            const Ï†2 = lat2 * Math.PI / 180;
            const Î”Ï† = (lat2 - lat1) * Math.PI / 180;
            const Î”Î» = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(Î”Ï† / 2) * Math.sin(Î”Ï† / 2) +
                      Math.cos(Ï†1) * Math.cos(Ï†2) * Math.sin(Î”Î» / 2) * Math.sin(Î”Î» / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        };

        // UbicaciÃ³n inicial con varios intentos para mejor precisiÃ³n
        const getInitialLocation = () => {
            return new Promise((resolve) => {
                let attempts = 0;
                const maxAttempts = 5;
                
                const tryGetLocation = () => {
                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            const { latitude, longitude, accuracy } = position.coords;
                            if (accuracy < 50 || attempts >= maxAttempts) {
                                console.log(`ðŸ“ GPS OK: ${latitude.toFixed(6)}, ${longitude.toFixed(6)} (Â±${accuracy.toFixed(0)}m)`);
                                resolve({ latitude, longitude, accuracy });
                            } else {
                                attempts++;
                                setTimeout(tryGetLocation, 1000);
                            }
                        },
                        (error) => {
                            attempts++;
                            if (attempts < maxAttempts) setTimeout(tryGetLocation, 1000);
                            else resolve(null);
                        },
                        { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
                    );
                };
                tryGetLocation();
            });
        };

        // Posiciones en Ã³rbita alrededor del usuario (8 slots)
        const getOrbitalPosition = (centerLat, centerLng, index, totalSlots = 8) => {
            const orbitRadiusLat = 0.0012;  // ~120-130m
            const orbitRadiusLng = 0.0015;  // ~130-150m
            const startAngle = 90; // comenzamos desde abajo
            const angle = ((startAngle + (index * (360 / totalSlots))) * Math.PI) / 180;
            return {
                lat: centerLat + (orbitRadiusLat * Math.cos(angle)),
                lng: centerLng + (orbitRadiusLng * Math.sin(angle))
            };
        };

        // Limpiar markers
        const clearAllMarkers = () => {
            markersRef.current.forEach(marker => {
                if (marker && marker.setMap) marker.setMap(null);
            });
            markersRef.current = [];
        };

        // Marker visual (avatar + aro + pensamiento + nombre/distancia)
        const createUserMarker = (user, map, size, isCurrentUser = false) => {
    // PATCH â€” evitar crash cuando google maps no existe aÃºn
    if (typeof google === 'undefined' || !google.maps) {
        console.warn('Intento de crear marcador sin Google Maps cargado');
        return null;
    }

    const markerDiv = document.createElement('div');
            markerDiv.style.cssText = `
                display:flex;
                flex-direction:column;
                align-items:center;
                cursor:pointer;
                pointer-events:auto;
            `;

            // ðŸ’­ Burbuja de pensamiento pequeÃ±a, pegada al avatar (solo otros usuarios)
            if (user.thought && user.thought.trim() && !isCurrentUser) {
                const bubble = document.createElement('div');
                bubble.style.cssText = `
                    max-width: 120px;
                    padding: 6px 10px;
                    border-radius: 14px;
                    background: rgba(15, 23, 32, 0.96);
                    color: #e6edf3;
                    font-size: 11px;
                    font-weight: 500;
                    line-height: 1.3;
                    margin-bottom: 4px;
                    position: relative;
                    text-align: center;
                    white-space: nowrap;
                `;
                bubble.textContent = user.thought;

                const tail = document.createElement('div');
                tail.style.cssText = `
                    position:absolute;
                    bottom:-4px;
                    left:50%;
                    transform:translateX(-50%);
                    width:8px;
                    height:8px;
                    border-radius:50%;
                    background:rgba(15, 23, 32, 0.96);
                `;
                bubble.appendChild(tail);
                markerDiv.appendChild(bubble);
            }

            // ðŸ§‘â€ðŸ¦± Avatar
            const avatarContainer = document.createElement('div');
            avatarContainer.style.cssText = `
                width:${size}px;
                height:${size}px;
                position:relative;
            `;

            const hasStory = !!user.hasStory;

            // Aro exterior: SOLO si tiene story (tipo Instagram)
            const ring = document.createElement('div');
            ring.style.cssText = `
                position:absolute;
                inset:0;
                border-radius:50%;
                padding:${hasStory ? '3px' : '0'};
                ${hasStory
                    ? 'background:linear-gradient(45deg,#f09433,#e6683c,#dc2743,#cc2366,#bc1888);'
                    : ''
                }
                box-shadow:0 2px 10px rgba(0,0,0,0.35);
            `;

            const avatarImg = document.createElement('img');
            avatarImg.src = user.photo;
            avatarImg.style.cssText = `
                width:100%;
                height:100%;
                border-radius:50%;
                object-fit:cover;
                border:2px solid #0d1117;
                background:#0d1117;
            `;

            ring.appendChild(avatarImg);
            avatarContainer.appendChild(ring);
            markerDiv.appendChild(avatarContainer);

            // Nombre + distancia (solo otros usuarios)
            if (!isCurrentUser) {
                const nameLabel = document.createElement('div');
                nameLabel.style.cssText = `
                    margin-top:4px;
                    padding:3px 8px;
                    border-radius:999px;
                    background:rgba(0,0,0,0.65);
                    color:#f9fafb;
                    font-size:11px;
                    font-weight:600;
                    white-space:nowrap;
                `;
                const firstName = user.name.split(' ')[0];
                nameLabel.textContent = user.distance
                    ? `${firstName} ${user.distance}m`
                    : firstName;
                markerDiv.appendChild(nameLabel);
            }

            markerDiv.addEventListener('click', () => handleAvatarClick(user));

            class CustomMarker extends google.maps.OverlayView {
                constructor(position, content) {
                    super();
                    this.position = position;
                    this.content = content;
                }
                onAdd() {
                    this.getPanes().overlayMouseTarget.appendChild(this.content);
                }
                draw() {
                    const pos = this.getProjection().fromLatLngToDivPixel(this.position);
                    if (pos) {
                        this.content.style.left = pos.x - (this.content.offsetWidth / 2) + 'px';
                        this.content.style.top = pos.y - this.content.offsetHeight + 'px';
                        this.content.style.position = 'absolute';
                    }
                }
                onRemove() {
                    if (this.content.parentElement) {
                        this.content.parentElement.removeChild(this.content);
                    }
                }
            }

            const lat = user.displayLat || user.latitude;
            const lng = user.displayLng || user.longitude;
            const marker = new CustomMarker(new google.maps.LatLng(lat, lng), markerDiv);
            marker.setMap(map);
            return marker;
        };

        // Inicializar mapa con zoom fijo y lÃ­mite de 1km de pan
        const initializeGoogleMap = (lat, lng) => {
    // PATCH â€” evitar pantalla blanca si Google Maps no cargÃ³
    if (typeof google === 'undefined' || !google.maps) {
        console.warn('Google Maps no estÃ¡ listo aÃºn');
        return;
    }

    if (!mapRef.current || googleMap) return;
            
            const darkStyle = [
                { elementType: 'geometry', stylers: [{ color: '#0d1117' }] },
                { elementType: 'labels.text.stroke', stylers: [{ color: '#0d1117' }] },
                { elementType: 'labels.text.fill', stylers: [{ color: '#8696a0' }] },
                { featureType: 'poi', stylers: [{ visibility: 'off' }] },
                { featureType: 'transit', stylers: [{ visibility: 'off' }] },
                { featureType: 'road', elementType: 'geometry', stylers: [{ color: '#1f2933' }] },
                { featureType: 'water', elementType: 'geometry', stylers: [{ color: '#0a1520' }] }
            ];

            const FIXED_ZOOM = 16;
            const MAX_PAN_METERS = 1000; // 1km

            const map = new google.maps.Map(mapRef.current, {
                center: { lat, lng },
                zoom: FIXED_ZOOM,
                minZoom: FIXED_ZOOM,
                maxZoom: FIXED_ZOOM,
                styles: darkStyle,
                disableDefaultUI: true,
                zoomControl: false,
                clickableIcons: false,
                gestureHandling: 'greedy'
            });

            // Evitar cambios de zoom
            map.addListener('zoom_changed', () => {
                if (map.getZoom() !== FIXED_ZOOM) {
                    map.setZoom(FIXED_ZOOM);
                }
            });

            // Limitar paneo a 1km
            map.addListener('dragend', () => {
                const origin = currentUserPositionRef.current;
                const center = map.getCenter();
                if (!origin || !origin.lat || !center) return;

                const distance = calculateDistance(
                    origin.lat,
                    origin.lng,
                    center.lat(),
                    center.lng()
                );

                if (distance > MAX_PAN_METERS) {
                    const ratio = MAX_PAN_METERS / distance;
                    const limitedLat = origin.lat + (center.lat() - origin.lat) * ratio;
                    const limitedLng = origin.lng + (center.lng() - origin.lng) * ratio;
                    map.panTo(new google.maps.LatLng(limitedLat, limitedLng));
                }
            });

            setGoogleMap(map);
            console.log('âœ… Map initialized at:', lat, lng);
        };

        // Auth effect
        useEffect(() => {
            console.log('ðŸš€ RADAR SOCIAL v6.8 - Orbital System + IG Rings');

            const unsubscribe = auth.onAuthStateChanged(async (firebaseUser) => {
                if (firebaseUser) {
                    setShowLanding(false);
                    
                    const userDoc = await db.collection('users').doc(firebaseUser.uid).get();
                    let thought = '', hasActiveStory = false, storyUrl = null, storyTimestamp = null;
                    
                    if (userDoc.exists) {
                        const userData = userDoc.data();
                        if (userData.thought && userData.thoughtTimestamp) {
                            const hoursPassed = (Date.now() - (userData.thoughtTimestamp.toMillis ? userData.thoughtTimestamp.toMillis() : userData.thoughtTimestamp)) / 3600000;
                            if (hoursPassed < 24) thought = userData.thought;
                        }
                        if (userData.storyUrl && userData.storyTimestamp) {
                            const hoursPassed = (Date.now() - (userData.storyTimestamp.toMillis ? userData.storyTimestamp.toMillis() : userData.storyTimestamp)) / 3600000;
                            if (hoursPassed < 12) {
                                hasActiveStory = true;
                                storyUrl = userData.storyUrl;
                                storyTimestamp = userData.storyTimestamp.toMillis ? userData.storyTimestamp.toMillis() : userData.storyTimestamp;
                            }
                        }
                    }
                    
                    const initialUser = {
                        id: firebaseUser.uid,
                        name: firebaseUser.displayName || 'Usuario',
                        photo: firebaseUser.photoURL || `https://ui-avatars.com/api/?name=${encodeURIComponent(firebaseUser.displayName || 'User')}&background=38bd62&color=fff&size=150`,
                        thought,
                        hasStory: hasActiveStory,
                        storyUrl,
                        storyTimestamp,
                        email: firebaseUser.email,
                        latitude: 0,
                        longitude: 0,
                        isOnline: true
                    };
                    
                    setCurrentUser(initialUser);
                    
                    await db.collection('users').doc(firebaseUser.uid).set({
                        uid: firebaseUser.uid,
                        displayName: firebaseUser.displayName,
                        email: firebaseUser.email,
                        photoURL: firebaseUser.photoURL,
                        isOnline: true,
                        lastSeen: firebase.firestore.FieldValue.serverTimestamp(),
                        location: new firebase.firestore.GeoPoint(0, 0),
                        pendingGPS: true
                    }, { merge: true });
                    
                    // UbicaciÃ³n inicial + watch
                    if ('geolocation' in navigator) {
                        const location = await getInitialLocation();
                        if (location) {
                            setUserLocation({ latitude: location.latitude, longitude: location.longitude });
                            setCurrentUser(prev => ({ ...prev, latitude: location.latitude, longitude: location.longitude }));
                            currentUserPositionRef.current = { lat: location.latitude, lng: location.longitude };
                            setWaitingForGPS(false);
                            
                            await db.collection('users').doc(firebaseUser.uid).update({
                                location: new firebase.firestore.GeoPoint(location.latitude, location.longitude),
                                pendingGPS: false,
                                lastSeen: firebase.firestore.FieldValue.serverTimestamp()
                            });
                        }
                        
                        let usersUnsubscribe = null;
                        let lastUpdateTime = 0;
                        
                        const watchId = navigator.geolocation.watchPosition(
                            async (position) => {
                                const { latitude, longitude, accuracy } = position.coords;
                                
                                if (accuracy > 100) return;
                                
                                const now = Date.now();
                                if (now - lastUpdateTime < 3000) return;
                                lastUpdateTime = now;
                                
                                setUserLocation({ latitude, longitude });
                                setCurrentUser(prev => ({ ...prev, latitude, longitude }));
                                currentUserPositionRef.current = { lat: latitude, lng: longitude };
                                setLocationAccuracy(accuracy);
                                
                                if (!usersUnsubscribe) {
                                    usersUnsubscribe = db.collection('users')
                                        .where('isOnline', '==', true)
                                        .onSnapshot((snapshot) => {
                                            setCurrentUser(currentUserState => {
                                                if (!currentUserState?.latitude) return currentUserState;
                                                
                                                const otherUsers = [];
                                                snapshot.forEach((doc) => {
                                                    const userData = doc.data();
                                                    if (userData.uid === firebaseUser.uid) return;
                                                    
                                                    let isOnline = false;
                                                    if (userData.lastSeen) {
                                                        const lastSeenTime = userData.lastSeen.toMillis ? userData.lastSeen.toMillis() : userData.lastSeen;
                                                        isOnline = (Date.now() - lastSeenTime) <= 30000;
                                                    }
                                                    
                                                    if (userData.location && isOnline) {
                                                        const userLat = userData.location.latitude;
                                                        const userLon = userData.location.longitude;
                                                        
                                                        if (userLat !== 0 && userLon !== 0) {
                                                            const distance = Math.round(calculateDistance(
                                                                currentUserState.latitude, currentUserState.longitude,
                                                                userLat, userLon
                                                            ));
                                                            
                                                            let displayThought = '';
                                                            if (userData.thought && userData.thoughtTimestamp) {
                                                                const hoursPassed = (Date.now() - (userData.thoughtTimestamp.toMillis ? userData.thoughtTimestamp.toMillis() : userData.thoughtTimestamp)) / 3600000;
                                                                if (hoursPassed < 24) displayThought = userData.thought;
                                                            }
                                                            
                                                            let hasActiveStory = false, storyUrl = null, storyTimestamp = null;
                                                            if (userData.storyUrl && userData.storyTimestamp) {
                                                                const hoursPassed = (Date.now() - (userData.storyTimestamp.toMillis ? userData.storyTimestamp.toMillis() : userData.storyTimestamp)) / 3600000;
                                                                if (hoursPassed < 12) {
                                                                    hasActiveStory = true;
                                                                    storyUrl = userData.storyUrl;
                                                                    storyTimestamp = userData.storyTimestamp.toMillis ? userData.storyTimestamp.toMillis() : userData.storyTimestamp;
                                                                }
                                                            }
                                                            
                                                            otherUsers.push({
                                                                id: userData.uid,
                                                                name: userData.displayName || 'Usuario',
                                                                photo: userData.photoURL || 'https://ui-avatars.com/api/?name=User&background=38bd62&color=fff',
                                                                thought: displayThought,
                                                                hasStory: hasActiveStory,
                                                                storyUrl,
                                                                storyTimestamp,
                                                                distance,
                                                                isOnline: true,
                                                                latitude: userLat,
                                                                longitude: userLon
                                                            });
                                                        }
                                                    }
                                                });
                                                
                                                setUsers(otherUsers);
                                                return currentUserState;
                                            });
                                        });
                                }
                                
                                await db.collection('users').doc(firebaseUser.uid).update({
                                    location: new firebase.firestore.GeoPoint(latitude, longitude),
                                    isOnline: true,
                                    lastSeen: firebase.firestore.FieldValue.serverTimestamp(),
                                    accuracy: accuracy,
                                    pendingGPS: false
                                });
                            },
                            (error) => console.error('Location error:', error),
                            { enableHighAccuracy: true, timeout: 30000, maximumAge: 10000 }
                        );
                        
                        return () => {
                            navigator.geolocation.clearWatch(watchId);
                            if (usersUnsubscribe) usersUnsubscribe();
                        };
                    }
                } else {
                    setShowLanding(true);
                }
            });
            
            return () => unsubscribe();
        }, []);

        // Inicializar mapa cuando ya tengo ubicaciÃ³n
        useEffect(() => {
            if (!currentUser?.latitude || currentUser.latitude === 0 || googleMap) return;
            initializeGoogleMap(currentUser.latitude, currentUser.longitude);
        }, [currentUser?.latitude, currentUser?.longitude, googleMap]);

        // Marcadores: sistema orbital + avatares pequeÃ±os externos
        useEffect(() => {
            if (!googleMap || !currentUser?.latitude || currentUser.latitude === 0) return;

            const usersInRange = users
                .filter(u => u.distance <= radius && u.isOnline && u.latitude !== 0)
                .sort((a, b) => a.distance - b.distance);

            const currentDataSignature = JSON.stringify({
                currentUserLat: currentUser.latitude.toFixed(5),
                currentUserLng: currentUser.longitude.toFixed(5),
                currentUserPhoto: currentUser.photo,
                usersCount: usersInRange.length,
                userIds: usersInRange.map(u => u.id).join(','),
                radius
            });

            if (currentDataSignature === lastMarkersDataRef.current) {
                return;
            }
            lastMarkersDataRef.current = currentDataSignature;

            clearAllMarkers();

            // TÃº en el centro
            const currentUserMarker = createUserMarker(currentUser, googleMap, 70, true);
            markersRef.current.push(currentUserMarker);

            const orbitUsers = usersInRange.slice(0, 8);
            const farUsers = usersInRange.slice(8);

            // 8 mÃ¡s cercanos en Ã³rbita fija
            orbitUsers.forEach((user, index) => {
                const orbitalPos = getOrbitalPosition(
                    currentUser.latitude,
                    currentUser.longitude,
                    index,
                    8
                );
                const userWithPos = {
                    ...user,
                    displayLat: orbitalPos.lat,
                    displayLng: orbitalPos.lng
                };
                const marker = createUserMarker(userWithPos, googleMap, 56, false);
                markersRef.current.push(marker);
            });

            // Resto, mÃ¡s pequeÃ±os y en posiciÃ³n real
            farUsers.forEach(user => {
                const marker = createUserMarker(user, googleMap, 44, false);
                markersRef.current.push(marker);
            });

        }, [googleMap, currentUser?.latitude, currentUser?.longitude, currentUser?.photo, users, radius]);

        // Centrar mapa cuando tÃº te mueves (pero solo si te mueves bastante)
        useEffect(() => {
            if (!googleMap || !currentUser?.latitude || currentUser.latitude === 0) return;
            
            const currentCenter = googleMap.getCenter();
            const newLat = currentUser.latitude;
            const newLng = currentUser.longitude;
            
            if (currentCenter) {
                const distance = calculateDistance(
                    currentCenter.lat(), currentCenter.lng(),
                    newLat, newLng
                );
                if (distance < 20) return;
            }
            
            googleMap.setCenter({ lat: newLat, lng: newLng });
        }, [googleMap, currentUser?.latitude, currentUser?.longitude]);

        // Heartbeat online
        useEffect(() => {
            if (!currentUser) return;
            const interval = setInterval(() => {
                if (!document.hidden) {
                    db.collection('users').doc(currentUser.id).update({
                        isOnline: true,
                        lastSeen: firebase.firestore.FieldValue.serverTimestamp()
                    }).catch(console.error);
                }
            }, 10000);
            return () => clearInterval(interval);
        }, [currentUser]);

        // Handlers principales
        const handleGoogleSignIn = async () => {
            try {
                const provider = new firebase.auth.GoogleAuthProvider();
                provider.setCustomParameters({ prompt: 'select_account' });
                await auth.signInWithPopup(provider);
                setShowLanding(false);
            } catch (error) {
                console.error('Sign in error:', error);
                alert('Error: ' + error.message);
            }
        };

        const handleLogout = async () => {
            try {
                if (currentUser) {
                    await db.collection('users').doc(currentUser.id).update({
                        isOnline: false,
                        lastSeen: firebase.firestore.FieldValue.serverTimestamp()
                    });
                }
                await auth.signOut();
                setShowLanding(true);
                setCurrentUser(null);
                setShowSidebar(false);
            } catch (error) {
                console.error('Logout error:', error);
            }
        };

        const handleThoughtSubmit = async () => {
            if (!thought.trim() || !currentUser) return;
            const newThought = thought.trim();
            try {
                await db.collection('users').doc(currentUser.id).update({
                    thought: newThought,
                    thoughtTimestamp: firebase.firestore.FieldValue.serverTimestamp()
                });
                setCurrentUser(prev => ({ ...prev, thought: newThought }));
                setThought('');
            } catch (error) {
                console.error('Error updating thought:', error);
            }
        };

        const handleAvatarClick = (user) => {
            if (user.id === currentUser?.id) {
                if (currentUser.hasStory && currentUser.storyUrl) setViewingStory(currentUser);
                else setShowStoryUpload(true);
            } else {
                if (user.hasStory && user.storyUrl) setViewingStory(user);
                else { setInstagramModalUser(user); setShowInstagramModal(true); }
            }
        };

        const handleStoryImageSelect = (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => setStoryImage(event.target.result);
                reader.readAsDataURL(file);
            }
        };

        const handleStoryPublish = async () => {
            if (!storyImage || !currentUser) return;
            setUploadingStory(true);
            try {
                const response = await fetch(storyImage);
                const blob = await response.blob();
                const storyRef = storage.ref().child(`stories/${currentUser.id}/${Date.now()}.jpg`);
                await storyRef.put(blob);
                const downloadURL = await storyRef.getDownloadURL();
                
                await db.collection('users').doc(currentUser.id).update({
                    storyUrl: downloadURL,
                    storyTimestamp: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                setCurrentUser(prev => ({ ...prev, hasStory: true, storyUrl: downloadURL, storyTimestamp: Date.now() }));
                setStoryImage(null);
                setShowStoryUpload(false);
            } catch (error) {
                console.error('Error uploading story:', error);
                alert('Error: ' + error.message);
            } finally {
                setUploadingStory(false);
            }
        };

        const openChat = (user) => {
            setSelectedUser(user);
            setShowInstagramModal(false);
            
            const chatId = [currentUser.id, user.id].sort().join('_');
            db.collection('chats').doc(chatId).collection('messages')
                .orderBy('timestamp', 'asc')
                .onSnapshot((snapshot) => {
                    const msgs = [];
                    snapshot.forEach((doc) => msgs.push({ id: doc.id, ...doc.data() }));
                    setMessages(prev => ({ ...prev, [chatId]: msgs }));
                    setTimeout(() => {
                        if (chatMessagesRef.current) chatMessagesRef.current.scrollTop = chatMessagesRef.current.scrollHeight;
                    }, 100);
                });
        };

        const sendMessage = async () => {
            if (!messageInput.trim() || !selectedUser || !currentUser) return;
            const chatId = [currentUser.id, selectedUser.id].sort().join('_');
            const text = messageInput.trim();
            setMessageInput('');
            
            try {
                await db.collection('chats').doc(chatId).collection('messages').add({
                    text, senderId: currentUser.id, senderName: currentUser.name,
                    senderPhoto: currentUser.photo, timestamp: firebase.firestore.FieldValue.serverTimestamp()
                });
                await db.collection('chats').doc(chatId).set({
                    participants: [currentUser.id, selectedUser.id],
                    lastMessage: text,
                    lastMessageTime: firebase.firestore.FieldValue.serverTimestamp(),
                    [`unreadCount_${selectedUser.id}`]: firebase.firestore.FieldValue.increment(1)
                }, { merge: true });
            } catch (error) {
                console.error('Error sending message:', error);
                setMessageInput(text);
            }
        };

        const sendQuickMessage = async () => {
            if (!quickMessage.trim() || !instagramModalUser || !currentUser) return;
            const chatId = [currentUser.id, instagramModalUser.id].sort().join('_');
            
            try {
                await db.collection('chats').doc(chatId).collection('messages').add({
                    text: quickMessage.trim(), senderId: currentUser.id, senderName: currentUser.name,
                    senderPhoto: currentUser.photo, timestamp: firebase.firestore.FieldValue.serverTimestamp()
                });
                await db.collection('chats').doc(chatId).set({
                    participants: [currentUser.id, instagramModalUser.id],
                    lastMessage: quickMessage.trim(),
                    lastMessageTime: firebase.firestore.FieldValue.serverTimestamp(),
                    [`unreadCount_${instagramModalUser.id}`]: firebase.firestore.FieldValue.increment(1)
                }, { merge: true });
                setQuickMessage('');
                setShowInstagramModal(false);
                openChat(instagramModalUser);
            } catch (error) {
                console.error('Error sending quick message:', error);
            }
        };

        const sendLike = async () => {
            if (!instagramModalUser || !currentUser) return;
            const chatId = [currentUser.id, instagramModalUser.id].sort().join('_');
            try {
                await db.collection('chats').doc(chatId).collection('messages').add({
                    text: 'â¤ï¸', senderId: currentUser.id, senderName: currentUser.name,
                    senderPhoto: currentUser.photo, timestamp: firebase.firestore.FieldValue.serverTimestamp(), type: 'like'
                });
                await db.collection('chats').doc(chatId).set({
                    participants: [currentUser.id, instagramModalUser.id],
                    lastMessage: 'â¤ï¸', lastMessageTime: firebase.firestore.FieldValue.serverTimestamp(),
                    [`unreadCount_${instagramModalUser.id}`]: firebase.firestore.FieldValue.increment(1)
                }, { merge: true });
                setShowInstagramModal(false);
            } catch (error) {
                console.error('Error sending like:', error);
            }
        };

        const formatMessageTime = (timestamp) => {
            if (!timestamp) return '';
            const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
            return date.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });
        };

        // LANDING
        if (showLanding) {
            return (
                <div className="landing-page">
                    <div className="landing-map-bg">
                        <div className="landing-grid"></div>
                        <div className="radar-pulse"></div>
                        <div className="radar-pulse delay-1"></div>
                        <div className="radar-pulse delay-2"></div>
                    </div>
                    
                    <div className="floating-avatars">
                        <div className="floating-avatar avatar-1">
                            <div className="avatar-ring has-story">
                                <img src="https://images.unsplash.com/photo-1494790108377-be9c29b29330?w=150" alt=""/>
                            </div>
                            <div className="avatar-thought">Buscando cafÃ© â˜•</div>
                        </div>
                        <div className="floating-avatar avatar-2">
                            <div className="avatar-ring online">
                                <img src="https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=150" alt=""/>
                            </div>
                            <div className="avatar-distance">45m</div>
                        </div>
                        <div className="floating-avatar avatar-3">
                            <div className="avatar-ring has-story">
                                <img src="https://images.unsplash.com/photo-1438761681033-6461ffad8d80?w=150" alt=""/>
                            </div>
                            <div className="avatar-thought">ðŸŽµ En concierto</div>
                        </div>
                        <div className="floating-avatar avatar-4">
                            <div className="avatar-ring online">
                                <img src="https://images.unsplash.com/photo-1500648767791-00dcc994a43e?w=150" alt=""/>
                            </div>
                        </div>
                        <div className="floating-avatar avatar-5">
                            <div className="avatar-ring has-story">
                                <img src="https://images.unsplash.com/photo-1534528741775-53994a69daeb?w=150" alt=""/>
                            </div>
                            <div className="avatar-thought">Â¿Alguien para gym? ðŸ’ª</div>
                        </div>
                        <div className="floating-avatar avatar-6">
                            <div className="avatar-ring online">
                                <img src="https://images.unsplash.com/photo-1506794778202-cad84cf45f1d?w=150" alt=""/>
                            </div>
                            <div className="avatar-distance">120m</div>
                        </div>
                    </div>
                    
                    <div className="landing-content">
                        <div className="landing-logo-container">
                            <div className="landing-logo-icon">ðŸ“¡</div>
                            <h1 className="landing-title">Radar Social</h1>
                        </div>
                        
                        <p className="landing-tagline">
                            Descubre quiÃ©n estÃ¡ cerca.<br/>
                            <span className="highlight">Conecta en tiempo real.</span>
                        </p>
                        
                        <div className="landing-features-row">
                            <div className="feature-pill">
                                <span>ðŸŽ¯</span>
                                <span>Alta precisiÃ³n</span>
                            </div>
                            <div className="feature-pill">
                                <span>ðŸ’¬</span>
                                <span>Chat instantÃ¡neo</span>
                            </div>
                            <div className="feature-pill">
                                <span>ðŸ“¸</span>
                                <span>Stories 12h</span>
                            </div>
                        </div>
                        
                        <button className="google-signin-btn" onClick={handleGoogleSignIn}>
                            <svg className="google-icon" viewBox="0 0 24 24">
                                <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                                <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                                <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                                <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                            </svg>
                            Continuar con Google
                        </button>
                        
                        <p className="landing-footer-text">
                            Ãšnete a miles de personas conectando a tu alrededor
                        </p>
                    </div>
                </div>
            );
        }

        const usersInRange = users.filter(u => u.distance <= radius && u.isOnline && u.latitude !== 0);
        const chatId = selectedUser ? [currentUser?.id, selectedUser.id].sort().join('_') : null;
        const chatMessages = chatId ? (messages[chatId] || []) : [];

        return (
            <>
                {waitingForGPS && (
                    <div className="location-permission">
                        <div className="permission-card">
                            <svg className="permission-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                                <circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/>
                            </svg>
                            <h2>Esperando GPS...</h2>
                            <p>Obteniendo tu ubicaciÃ³n con alta precisiÃ³n. Esto puede tomar unos segundos.</p>
                            <div className="gps-dots">
                                <div className="gps-dot"/><div className="gps-dot"/><div className="gps-dot"/>
                            </div>
                        </div>
                    </div>
                )}

                <div className="main-container">
                    <div className="radar-container">
                        <div id="google-map" ref={mapRef}></div>
                        
                        <div className="map-header">
                            <svg className="header-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" onClick={() => setShowSidebar(true)}>
                                <line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/>
                            </svg>
                            <div className="map-people-counter">
                                <span className="map-people-counter-number">{usersInRange.length}</span>
                                <span className="map-people-counter-text">cerca</span>
                            </div>
                            <svg className="header-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" onClick={() => setShowInbox(true)}>
                                <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/>
                            </svg>
                        </div>
                    </div>
                    
                    <div className="range-slider-container">
                        <div className="range-slider-label">
                            <span className="range-slider-title">Radio de bÃºsqueda</span>
                            <span className="range-slider-value">{radius}m</span>
                        </div>
                        <div
                            className="range-slider-track"
                            onMouseDown={(e) => {
                                const rect = e.currentTarget.getBoundingClientRect();
                                const percent = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
                                setRadius(Math.round(10 + percent * 990));
                                setIsDraggingDial(true);
                            }}
                            onMouseMove={(e) => {
                                if (!isDraggingDial) return;
                                const rect = e.currentTarget.getBoundingClientRect();
                                const percent = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
                                setRadius(Math.round(10 + percent * 990));
                            }}
                            onMouseUp={() => setIsDraggingDial(false)}
                            onMouseLeave={() => setIsDraggingDial(false)}
                            onTouchStart={(e) => {
                                const rect = e.currentTarget.getBoundingClientRect();
                                const touch = e.touches[0];
                                const percent = Math.max(0, Math.min(1, (touch.clientX - rect.left) / rect.width));
                                setRadius(Math.round(10 + percent * 990));
                                setIsDraggingDial(true);
                            }}
                            onTouchMove={(e) => {
                                if (!isDraggingDial) return;
                                const rect = e.currentTarget.getBoundingClientRect();
                                const touch = e.touches[0];
                                const percent = Math.max(0, Math.min(1, (touch.clientX - rect.left) / rect.width));
                                setRadius(Math.round(10 + percent * 990));
                            }}
                            onTouchEnd={() => setIsDraggingDial(false)}
                        >
                            <div
                                className="range-slider-progress"
                                style={{ width: `${((radius - 10) / 990) * 100}%` }}
                            />
                            <div
                                className="range-slider-thumb"
                                style={{ left: `${((radius - 10) / 990) * 100}%` }}
                            />
                        </div>
                        <div className="range-slider-marks">
                            <span className="range-slider-mark">10m</span>
                            <span className="range-slider-mark">500m</span>
                            <span className="range-slider-mark">1km</span>
                        </div>
                    </div>
                    
                    <div className="thought-input-container">
                        <input
                            type="text"
                            className="thought-input"
                            placeholder="Escribe un pensamiento..."
                            value={thought}
                            onChange={(e) => setThought(e.target.value)}
                            onKeyPress={(e) => e.key === 'Enter' && handleThoughtSubmit()}
                            maxLength={50}
                        />
                        <button className="send-button" onClick={handleThoughtSubmit}>
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                                <line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/>
                            </svg>
                        </button>
                    </div>
                </div>

                {/* Sidebar */}
                <div className={`overlay-backdrop ${showSidebar ? 'active' : ''}`} onClick={() => setShowSidebar(false)}/>
                <div className={`sidebar ${showSidebar ? 'active' : ''}`}>
                    <div className="sidebar-header">
                        <h2>MenÃº</h2>
                        <svg style={{ width: 24, height: 24, cursor: 'pointer', color: '#8b949e' }} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" onClick={() => setShowSidebar(false)}>
                            <line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/>
                        </svg>
                    </div>
                    <div className="sidebar-content">
                        <div className="sidebar-item" onClick={() => { setShowProfile(true); setShowSidebar(false); }}>
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>
                            <span>Mi Perfil</span>
                        </div>
                        <div className="sidebar-item" onClick={() => { setShowInbox(true); setShowSidebar(false); }}>
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg>
                            <span>Mensajes</span>
                        </div>
                        <div className="sidebar-item" onClick={() => { setShowTechSettings(true); setShowSidebar(false); }}>
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>
                            <span>TecnologÃ­as</span>
                        </div>
                        <div className="sidebar-item" onClick={() => { setShowStoryUpload(true); setShowSidebar(false); }}>
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></svg>
                            <span>Subir Historia</span>
                        </div>
                        <div className="sidebar-item" style={{ marginTop: 'auto', color: '#f87171' }} onClick={handleLogout}>
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"/><polyline points="16 17 21 12 16 7"/><line x1="21" y1="12" x2="9" y2="12"/></svg>
                            <span>Cerrar SesiÃ³n</span>
                        </div>
                        <div style={{ padding: '16px 20px', borderTop: '1px solid rgba(48,54,61,0.5)', marginTop: '12px' }}>
                            <span style={{ fontSize: '11px', color: '#6e7681', fontWeight: '500' }}>Radar Social v6.8</span>
                        </div>
                    </div>
                </div>

                {/* Profile */}
                <div className={`profile-overlay ${showProfile ? 'active' : ''}`}>
                    <div className="profile-header">
                        <svg style={{ width: 24, height: 24, cursor: 'pointer', color: '#8b949e' }} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" onClick={() => setShowProfile(false)}><polyline points="15 18 9 12 15 6"/></svg>
                        <h2>Mi Perfil</h2>
                    </div>
                    <div className="profile-content">
                        <div className="profile-avatar-section">
                            <img src={currentUser?.photo} alt={currentUser?.name} className="profile-avatar-large"/>
                            <h2 className="profile-name">{currentUser?.name}</h2>
                            <p className="profile-bio">{currentUser?.thought || 'Sin pensamiento actual'}</p>
                        </div>
                        <div className="profile-section">
                            <h3 className="profile-section-title">InformaciÃ³n</h3>
                            <div className="profile-field"><span className="profile-field-label">Email</span><span className="profile-field-value">{currentUser?.email}</span></div>
                            <div className="profile-field"><span className="profile-field-label">Estado</span><span className="profile-field-value" style={{ color: '#38bd62' }}>â— En lÃ­nea</span></div>
                            <div className="profile-field"><span className="profile-field-label">Historia</span><span className="profile-field-value">{currentUser?.hasStory ? 'ðŸ“¸ Activa' : 'Sin historia'}</span></div>
                        </div>
                        <div className="profile-section">
                            <h3 className="profile-section-title">UbicaciÃ³n</h3>
                            <div className="profile-field"><span className="profile-field-label">PrecisiÃ³n GPS</span><span className="profile-field-value">Â±{locationAccuracy.toFixed(1)}m</span></div>
                            <div className="profile-field"><span className="profile-field-label">TecnologÃ­a</span><span className="profile-field-value">{activeTech.icon} {activeTech.name}</span></div>
                        </div>
                    </div>
                </div>

                {/* Inbox */}
                <div className={`inbox-overlay ${showInbox ? 'active' : ''}`}>
                    <div className="inbox-header">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" style={{ width: 24, height: 24, cursor: 'pointer', color: '#8b949e' }} onClick={() => setShowInbox(false)}><polyline points="15 18 9 12 15 6"/></svg>
                        <h2>Mensajes</h2>
                    </div>
                    <div className="inbox-list">
                        {users.length === 0 ? (
                            <div className="inbox-empty">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg>
                                <p>No hay conversaciones aÃºn</p>
                            </div>
                        ) : (
                            users.map(user => (
                                <div key={user.id} className="inbox-item" onClick={() => { openChat(user); setShowInbox(false); }}>
                                    <img src={user.photo} alt={user.name} className="inbox-avatar"/>
                                    <div className="inbox-info">
                                        <div className="inbox-name">{user.name}</div>
                                        <div className="inbox-preview">{user.thought || 'Toca para chatear'}</div>
                                    </div>
                                    <span className="inbox-distance">{user.distance}m</span>
                                </div>
                            ))
                        )}
                    </div>
                </div>

                {/* Tech Settings */}
                <div className={`tech-settings-overlay ${showTechSettings ? 'active' : ''}`}>
                    <div className="tech-settings-header">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" style={{ width: 24, height: 24, cursor: 'pointer', color: '#8b949e' }} onClick={() => setShowTechSettings(false)}><polyline points="15 18 9 12 15 6"/></svg>
                        <h2>TecnologÃ­as de PrecisiÃ³n</h2>
                    </div>
                    <div className="tech-settings-content">
                        <div className="tech-mode-selector">
                            <h3>Modo de OperaciÃ³n</h3>
                            <div className="tech-mode-options">
                                <div className={`tech-mode-option ${techSettings.mode === 'auto' ? 'active' : ''}`} onClick={() => setTechSettings(prev => ({ ...prev, mode: 'auto' }))}>
                                    <div className="icon">ðŸ¤–</div><div className="label">Auto</div><div className="description">SelecciÃ³n inteligente</div>
                                </div>
                                <div className={`tech-mode-option ${techSettings.mode === 'manual' ? 'active' : ''}`} onClick={() => setTechSettings(prev => ({ ...prev, mode: 'manual' }))}>
                                    <div className="icon">âš™ï¸</div><div className="label">Manual</div><div className="description">Control total</div>
                                </div>
                            </div>
                        </div>
                        <div className="tech-list">
                            <h3>TecnologÃ­as Disponibles</h3>
                            <div className={`tech-item ${techSettings.mode === 'auto' ? 'disabled' : ''}`}>
                                <div className="tech-item-info">
                                    <div className="tech-item-name"><span className="tech-item-icon">ðŸ“</span>GPS EstÃ¡ndar</div>
                                    <div className="tech-item-description">UbicaciÃ³n satelital. PrecisiÃ³n: 5-15m</div>
                                </div>
                                <div className={`tech-toggle ${techSettings.gps ? 'active' : ''}`} onClick={() => techSettings.mode !== 'auto' && setTechSettings(prev => ({ ...prev, gps: !prev.gps }))}/>
                            </div>
                            <div className={`tech-item ${techSettings.mode === 'auto' ? 'disabled' : ''}`}>
                                <div className="tech-item-info">
                                    <div className="tech-item-name"><span className="tech-item-icon">ðŸŽ¯</span>Filtro Kalman</div>
                                    <div className="tech-item-description">Suaviza movimiento. PrecisiÃ³n: 2-5m</div>
                                </div>
                                <div className={`tech-toggle ${techSettings.kalman ? 'active' : ''}`} onClick={() => techSettings.mode !== 'auto' && setTechSettings(prev => ({ ...prev, kalman: !prev.kalman }))}/>
                            </div>
                            <div className={`tech-item ${techSettings.mode === 'auto' ? 'disabled' : ''}`}>
                                <div className="tech-item-info">
                                    <div className="tech-item-name"><span className="tech-item-icon">ðŸ§ </span>Dead Reckoning</div>
                                    <div className="tech-item-description">Usa acelerÃ³metro. PrecisiÃ³n: 1-3m</div>
                                </div>
                                <div className={`tech-toggle ${techSettings.deadReckoning ? 'active' : ''}`} onClick={() => techSettings.mode !== 'auto' && setTechSettings(prev => ({ ...prev, deadReckoning: !prev.deadReckoning }))}/>
                            </div>
                            <div className={`tech-item ${techSettings.mode === 'auto' ? 'disabled' : ''}`}>
                                <div className="tech-item-info">
                                    <div className="tech-item-name"><span className="tech-item-icon">ðŸ”Š</span>UltrasÃ³nico</div>
                                    <div className="tech-item-description">Audio inaudible. PrecisiÃ³n: 0.1-2m</div>
                                </div>
                                <div className={`tech-toggle ${techSettings.ultrasonic ? 'active' : ''}`} onClick={() => techSettings.mode !== 'auto' && setTechSettings(prev => ({ ...prev, ultrasonic: !prev.ultrasonic }))}/>
                            </div>
                        </div>
                    </div>
                </div>

                {/* Story Upload */}
                <div className={`story-upload-overlay ${showStoryUpload ? 'active' : ''}`}>
                    <div className="story-upload-container">
                        <div className="story-upload-header">
                            <h2>Nueva Historia</h2>
                            <div className="story-upload-close" onClick={() => { setShowStoryUpload(false); setStoryImage(null); }}>
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                            </div>
                        </div>
                        <div className="story-preview-area">
                            {storyImage ? (
                                <>
                                    <img src={storyImage} alt="Preview"/>
                                    <div className="story-remove-btn" onClick={() => setStoryImage(null)}>
                                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                                    </div>
                                </>
                            ) : (
                                <div className="story-preview-placeholder">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></svg>
                                    <span>Selecciona una imagen</span>
                                </div>
                            )}
                        </div>
                        <div className="story-upload-actions">
                            <label className="story-select-btn">
                                <svg style={{ width: 20, height: 20 }} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></svg>
                                GalerÃ­a
                                <input type="file" accept="image/*" style={{ display: 'none' }} onChange={handleStoryImageSelect}/>
                            </label>
                            <button className="story-publish-btn" disabled={!storyImage || uploadingStory} onClick={handleStoryPublish}>
                                {uploadingStory ? 'Subiendo...' : (
                                    <>
                                        <svg style={{ width: 20, height: 20 }} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/></svg>
                                        Publicar
                                    </>
                                )}
                            </button>
                        </div>
                    </div>
                </div>

                {/* Story Viewer */}
                <div className={`story-viewer ${viewingStory ? 'active' : ''}`}>
                    {viewingStory && (
                        <div className="story-container">
                            <div className="story-progress-bar"><div className="story-progress-fill" key={viewingStory.id}></div></div>
                            <div className="story-header">
                                <div className="story-user-info">
                                    <img src={viewingStory.photo} alt={viewingStory.name} className="story-user-avatar"/>
                                    <span className="story-user-name">{viewingStory.name}</span>
                                </div>
                                <div className="story-close" onClick={() => { setViewedStories(prev => ({ ...prev, [viewingStory.id]: Date.now() })); setViewingStory(null); }}>
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                                </div>
                            </div>
                            <img src={viewingStory.storyUrl} alt="Story" className="story-image"/>
                            {viewingStory.id !== currentUser?.id && (
                                <>
                                    <div className="story-reactions">
                                        {['â¤ï¸', 'ðŸ”¥', 'ðŸ˜', 'ðŸ˜‚', 'ðŸ‘'].map(emoji => (
                                            <button key={emoji} className="story-reaction-btn">{emoji}</button>
                                        ))}
                                    </div>
                                    <button className="story-message-btn" onClick={() => { setViewingStory(null); openChat(viewingStory); }}>
                                        <svg style={{ width: 20, height: 20 }} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>
                                        Enviar mensaje
                                    </button>
                                </>
                            )}
                        </div>
                    )}
                </div>

                {/* Instagram Modal */}
                <div className={`instagram-modal-backdrop ${showInstagramModal ? 'active' : ''}`} onClick={() => setShowInstagramModal(false)}/>
                <div className={`instagram-modal ${showInstagramModal ? 'active' : ''}`}>
                    {instagramModalUser && (
                        <>
                            <div className="instagram-modal-header">
                                <img src={instagramModalUser.photo} alt={instagramModalUser.name} className="instagram-modal-avatar"/>
                                <div className="instagram-modal-info">
                                    <div className="instagram-modal-name">{instagramModalUser.name}</div>
                                    <div className="instagram-modal-distance">ðŸ“ A {instagramModalUser.distance}m {instagramModalUser.thought && `â€¢ "${instagramModalUser.thought}"`}</div>
                                </div>
                            </div>
                            <div className="instagram-modal-actions">
                                <input type="text" className="instagram-modal-input" placeholder={`Mensaje a ${instagramModalUser.name}...`} value={quickMessage} onChange={(e) => setQuickMessage(e.target.value)} onKeyPress={(e) => e.key === 'Enter' && sendQuickMessage()}/>
                                <div className="instagram-modal-heart" onClick={sendLike}>
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/></svg>
                                </div>
                            </div>
                        </>
                    )}
                </div>

                {/* Chat */}
                <div className={`chat-overlay ${selectedUser ? 'active' : ''}`}>
                    {selectedUser && (
                        <>
                            <div className="chat-header">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" style={{ width: 24, height: 24, cursor: 'pointer', color: '#aebac1' }} onClick={() => setSelectedUser(null)}><polyline points="15 18 9 12 15 6"/></svg>
                                <div className="chat-user-info">
                                    <img src={selectedUser.photo} alt={selectedUser.name} className="chat-user-avatar"/>
                                    <div className="chat-user-details">
                                        <h3>{selectedUser.name}</h3>
                                        <p>A {selectedUser.distance}m â€¢ {selectedUser.isOnline ? 'En lÃ­nea' : 'Desconectado'}</p>
                                    </div>
                                </div>
                            </div>
                            <div className="chat-content">
                                <div className="chat-messages" ref={chatMessagesRef}>
                                    {chatMessages.length === 0 ? (
                                        <div className="chat-info">Â¡Inicia una conversaciÃ³n con {selectedUser.name}!<br/>EstÃ¡n a solo {selectedUser.distance}m de distancia.</div>
                                    ) : (
                                        chatMessages.map((msg) => (
                                            <div key={msg.id} className={`message ${msg.senderId === currentUser?.id ? 'sent' : 'received'}`}>
                                                {msg.type === 'like' ? <span style={{ fontSize: '24px' }}>â¤ï¸</span> : msg.text}
                                                <span className="message-time">{formatMessageTime(msg.timestamp)}</span>
                                            </div>
                                        ))
                                    )}
                                </div>
                                <div className="chat-input-container">
                                    <input type="text" className="chat-input" placeholder="Escribe un mensaje..." value={messageInput} onChange={(e) => setMessageInput(e.target.value)} onKeyPress={(e) => e.key === 'Enter' && sendMessage()}/>
                                    <button className="chat-send-btn" onClick={sendMessage} disabled={!messageInput.trim()}>
                                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/></svg>
                                    </button>
                                </div>
                            </div>
                        </>
                    )}
                </div>
            </>
        );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<RadarSocialApp />);
</script>
