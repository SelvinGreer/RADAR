<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Radar Social</title>
    
    <!-- PWA Meta Tags -->
    <meta name="description" content="Encuentra y conecta con personas cerca de ti usando radar geolocalizado">
    <meta name="theme-color" content="#0d1117">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Radar Social">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icon-192.png">
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-storage-compat.js"></script>
    
    <!-- Google Maps API con TU API Key -->
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyA2kFaHgj0LpeB3MJBUTG_piDyW_zJ1wzU&libraries=places"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #0d1117;
            color: #e6edf3;
            overflow-x: hidden;
            position: fixed;
            width: 100%;
            height: 100vh;
            height: 100dvh; /* Dynamic viewport height (mejor para móviles) */
            padding-bottom: env(safe-area-inset-bottom); /* Respeta barra de Android/iOS */
        }

        #root {
            width: 100%;
            height: 100vh;
            height: 100dvh; /* Dynamic viewport height */
            display: flex;
            flex-direction: column;
            padding-bottom: env(safe-area-inset-bottom); /* Respeta barra de Android/iOS */
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 20px; /* Reducido de 16px a 12px */
            background: linear-gradient(180deg, rgba(22, 27, 34, 0.98) 0%, rgba(17, 21, 27, 0.95) 100%);
            backdrop-filter: blur(20px);
            position: relative;
            z-index: 100;
            border-bottom: 1px solid rgba(48, 54, 61, 0.3);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }


        .online-badge-menu {
            position: static;
            padding: 4px 10px;
            background: rgba(34, 197, 94, 0.15);
            border: 1px solid rgba(34, 197, 94, 0.4);
            border-radius: 8px;
            font-size: 10px;
            font-weight: 700;
            color: #22c55e;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            backdrop-filter: blur(12px);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .online-badge-dot {
            width: 5px;
            height: 5px;
            background: #22c55e;
            border-radius: 50%;
            animation: badgePulse 2s ease-in-out infinite;
        }

        @keyframes badgePulse {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7);
                opacity: 1;
            }
            50% {
                box-shadow: 0 0 0 3px rgba(34, 197, 94, 0);
                opacity: 0.7;
            }
        }

        .header-icon {
            width: 24px; /* Reducido de 28px a 24px */
            height: 24px; /* Reducido de 28px a 24px */
            cursor: pointer;
            color: #c9d1d9;
            transition: all 0.2s ease;
            opacity: 0.9;
        }

        .header-icon:hover {
            opacity: 1;
            color: #f0f6fc;
        }

        .header-title {
            font-size: 20px; /* Reducido de 22px a 20px */
            font-weight: 600;
            letter-spacing: -0.3px;
            color: #f0f6fc;
        }

        .main-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: visible;
            padding: 20px;
            /* Padding bottom dinámico: 140px base + espacio para barra de Android */
            padding-bottom: calc(140px + env(safe-area-inset-bottom, 0px));
            background: radial-gradient(ellipse at center, rgba(22, 27, 34, 0.5) 0%, #0d1117 70%);
        }

        .radar-container {
            position: relative;
            width: 100%;
            height: 100%;
            margin: 0;
            overflow: hidden;
        }

        /* Google Map Container - Pantalla completa */
        #google-map {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        /* Ocultar controles de Google Maps para estética limpia */
        #google-map .gm-style-cc,
        #google-map .gm-style a[href^="https://maps.google.com/maps"] {
            display: none !important;
        }
        
        /* Header flotante sobre el mapa */
        .map-header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            z-index: 10;
            background: linear-gradient(180deg, rgba(13, 17, 23, 0.95) 0%, rgba(13, 17, 23, 0.7) 70%, transparent 100%);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            padding: max(env(safe-area-inset-top), 12px) 16px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        /* Slider flotante en la parte inferior */
        .map-slider-container {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 10;
            background: linear-gradient(0deg, rgba(13, 17, 23, 0.95) 0%, rgba(13, 17, 23, 0.7) 70%, transparent 100%);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            padding: 20px 20px max(env(safe-area-inset-bottom), 20px);
        }
        
        /* Contador de personas flotante */
        .map-people-counter {
            position: static;
            background: rgba(13, 17, 23, 0.9);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-radius: 20px;
            padding: 8px 14px;
            display: flex;
            align-items: center;
            gap: 6px;
            border: 1px solid rgba(56, 189, 98, 0.2);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .map-people-counter-number {
            font-size: 16px;
            font-weight: 700;
            color: #38bd62;
        }
        
        .map-people-counter-text {
            font-size: 12px;
            color: rgba(230, 237, 243, 0.8);
        }
        

        /* OCULTAR estilos antiguos del radar circular (ya no se usan) */
        .radar-container::before,
        .radar-bg,
        .radar-grid,
        .radar-circle,
        .distance-label,
        .radar-line,
        .radar-sweep {
            display: none;
        }

        .radar-bg {
            position: absolute;
            inset: 0;
            border-radius: 50%;
            background: radial-gradient(circle at 45% 45%, 
                rgba(18, 38, 26, 1) 0%,
                rgba(12, 28, 18, 1) 40%,
                rgba(8, 18, 12, 1) 70%,
                rgba(13, 17, 23, 1) 100%
            );
            border: 1px solid rgba(48, 54, 61, 0.6);
            box-shadow: 
                0 0 0 1px rgba(22, 27, 34, 0.8),
                0 8px 32px rgba(0, 0, 0, 0.6),
                inset 0 0 80px rgba(0, 0, 0, 0.5),
                inset 0 1px 1px rgba(255, 255, 255, 0.02);
            overflow: visible;
        }

        .radar-content-rotatable {
            position: absolute;
            inset: 0;
            border-radius: 50%;
            transition: transform 0.3s ease;
        }

        .radar-grid {
            position: absolute;
            inset: 0;
            border-radius: 50%;
            overflow: hidden;
        }

        .radar-circle {
            position: absolute;
            border-radius: 50%;
            border: 1px solid rgba(56, 189, 98, 0.08);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .distance-label {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(139, 148, 158, 0.5);
            font-size: 11px;
            font-weight: 600;
            pointer-events: none;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
        }

        .radar-line {
            position: absolute;
            width: 1px;
            height: 100%;
            background: rgba(56, 189, 98, 0.06);
            top: 0;
            left: 50%;
            transform-origin: center;
        }

        .radar-sweep {
            position: absolute;
            width: 200%;
            height: 200%;
            top: -50%;
            left: -50%;
            background: conic-gradient(
                from 0deg,
                rgba(56, 189, 98, 0.05) 0deg,
                rgba(56, 189, 98, 0.15) 20deg,
                rgba(56, 189, 98, 0.25) 40deg,
                transparent 60deg,
                transparent 360deg
            );
            animation: radarSweep 6s linear infinite;
            pointer-events: none;
            border-radius: 50%;
            transform-origin: center;
        }

        @keyframes radarSweep {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Horizontal Range Slider - Integrated Design */
        .range-slider-container {
            position: fixed;
            left: 50%;
            /* Bottom dinámico: 125px base + espacio para barra de Android */
            bottom: calc(125px + env(safe-area-inset-bottom, 0px));
            transform: translateX(-50%);
            z-index: 50;
            width: 300px;
            padding: 12px 0;
        }

        .range-slider-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding: 0 4px;
        }

        .range-slider-title {
            font-size: 11px;
            font-weight: 600;
            color: rgba(139, 148, 158, 0.7);
            text-transform: uppercase;
            letter-spacing: 0.8px;
        }

        .range-slider-value {
            font-size: 18px;
            font-weight: 700;
            color: #38bd62;
            letter-spacing: -0.5px;
            text-shadow: 0 0 8px rgba(56, 189, 98, 0.4);
        }

        .range-slider-track {
            position: relative;
            width: 100%;
            height: 4px;
            background: rgba(48, 54, 61, 0.4);
            border-radius: 2px;
            overflow: visible;
            cursor: pointer;
        }

        .range-slider-progress {
            position: absolute;
            height: 100%;
            background: linear-gradient(90deg, rgba(56, 189, 98, 0.6) 0%, #38bd62 100%);
            border-radius: 2px;
            transition: width 0.2s ease;
            box-shadow: 0 0 12px rgba(56, 189, 98, 0.5);
        }

        .range-slider-thumb {
            position: absolute;
            top: 50%;
            width: 18px;
            height: 18px;
            background: linear-gradient(145deg, #38bd62 0%, #2ea556 100%);
            border: 3px solid #0d1117;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            cursor: grab;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 
                0 2px 8px rgba(0, 0, 0, 0.4),
                0 0 16px rgba(56, 189, 98, 0.6);
        }

        .range-slider-thumb:active {
            cursor: grabbing;
            transform: translate(-50%, -50%) scale(1.2);
            box-shadow: 
                0 3px 12px rgba(0, 0, 0, 0.5),
                0 0 20px rgba(56, 189, 98, 0.8);
        }

        .range-slider-marks {
            display: flex;
            justify-content: space-between;
            margin-top: 6px;
            padding: 0 4px;
        }

        .range-slider-mark {
            font-size: 9px;
            color: rgba(139, 148, 158, 0.4);
            font-weight: 500;
        }

        .avatar-container {
            position: absolute;
            cursor: pointer;
            z-index: 10;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        .avatar-container:active {
            transform: scale(0.94);
        }

        .avatar-wrapper {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            transform: translate(-50%, -50%);
            transform-origin: center center;
        }

        .avatar-ring {
            border-radius: 50%;
            padding: 2.5px;
            position: relative;
            flex-shrink: 0;
        }

        .avatar-ring.has-story {
            background: linear-gradient(135deg, #f59e0b 0%, #f97316 35%, #ec4899 70%, #a855f7 100%);
        }

        .avatar-ring.viewed-story {
            background: rgba(71, 85, 105, 0.5);
            opacity: 0.6;
        }

        .avatar-ring.no-story {
            background: rgba(71, 85, 105, 0.5);
        }

        .avatar-ring.new-message {
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            animation: messagePulse 1.5s ease-in-out infinite;
        }

        @keyframes messagePulse {
            0%, 100% { 
                opacity: 1;
                box-shadow: 0 0 16px rgba(251, 191, 36, 0.4);
            }
            50% { 
                opacity: 0.75;
                box-shadow: 0 0 24px rgba(251, 191, 36, 0.6);
            }
        }

        .avatar-img-wrapper {
            border-radius: 50%;
            background: #0d1117;
            border: 2.5px solid #0d1117;
            overflow: hidden;
            position: relative;
        }

        .avatar-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .avatar-thought {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(22, 27, 34, 0.95);
            color: #e6edf3;
            padding: 5px 11px;
            border-radius: 9px;
            font-size: 12px;
            font-weight: 500;
            white-space: nowrap;
            border: 1px solid rgba(48, 54, 61, 0.6);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            max-width: 110px;
            overflow: hidden;
            text-overflow: ellipsis;
            letter-spacing: -0.1px;
            margin-bottom: 4px;
        }

        .avatar-name {
            font-size: 14px;
            font-weight: 600;
            color: #f0f6fc;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.9);
            letter-spacing: -0.2px;
            margin-top: 3px;
        }

        .avatar-distance {
            font-size: 12px;
            color: #8b949e;
            font-weight: 500;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.9);
            margin-top: 1px;
        }

        .message-badge {
            position: absolute;
            top: -2px;
            right: -2px;
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, #f59e0b 0%, #dc2626 100%);
            border-radius: 50%;
            border: 2px solid #0d1117;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 700;
            color: #fff;
            box-shadow: 0 2px 8px rgba(245, 158, 11, 0.5);
            animation: messageBadgePulse 2s ease-in-out infinite;
        }

        .add-story-btn {
            position: absolute;
            bottom: -5px;
            right: -5px;
            width: 28px;
            height: 28px;
            background: linear-gradient(135deg, #38bd62 0%, #2d9d51 100%);
            border-radius: 50%;
            border: 3px solid #0d1117;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: 600;
            color: #fff;
            cursor: pointer;
            box-shadow: 0 3px 12px rgba(56, 189, 98, 0.4);
            transition: all 0.2s ease;
            z-index: 10;
        }

        .add-story-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 16px rgba(56, 189, 98, 0.6);
        }

        .add-story-btn:active {
            transform: scale(0.95);
        }


        @keyframes messageBadgePulse {
            0%, 100% { 
                transform: scale(1);
            }
            50% { 
                transform: scale(1.1);
            }
        }

        .radar-info {
            position: absolute;
            top: -75px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 5;
            white-space: nowrap;
        }

        .radar-info-title {
            font-size: 11px;
            font-weight: 500;
            color: #8b949e;
            letter-spacing: -0.1px;
        }

        .precision-badge {
            display: inline-block;
            margin-top: 4px;
            padding: 2px 8px;
            background: rgba(56, 189, 98, 0.15);
            border: 1px solid rgba(56, 189, 98, 0.3);
            border-radius: 8px;
            font-size: 9px;
            font-weight: 600;
            color: #38bd62;
            letter-spacing: 0.3px;
            text-transform: uppercase;
            transition: all 0.3s ease;
        }

        .tech-badges-container {
            position: fixed !important;
            top: 67px !important; /* Ajustado para header más delgado (75px - 8px) */
            right: 16px !important;
            z-index: 100 !important;
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: flex-end;
        }

        .tech-badge {
            padding: 6px 12px !important;
            font-size: 10px !important;
            backdrop-filter: blur(12px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3) !important;
            display: flex !important;
            align-items: center;
            gap: 6px;
            background: rgba(56, 189, 98, 0.15);
            border: 1px solid rgba(56, 189, 98, 0.3);
            border-radius: 8px;
            font-weight: 600;
            color: #38bd62;
            letter-spacing: 0.3px;
            text-transform: uppercase;
            transition: all 0.3s ease;
        }

        .tech-badge.online {
            background: rgba(34, 197, 94, 0.15);
            border-color: rgba(34, 197, 94, 0.4);
            color: #22c55e;
        }

        .tech-badge.precision {
            background: rgba(56, 189, 98, 0.15);
            border-color: rgba(56, 189, 98, 0.3);
            color: #38bd62;
        }

        .tech-badge-dot {
            width: 6px;
            height: 6px;
            background: currentColor;
            border-radius: 50%;
            animation: badgePulse 2s ease-in-out infinite;
        }

        @keyframes badgePulse {
            0%, 100% {
                box-shadow: 0 0 0 0 currentColor;
                opacity: 1;
            }
            50% {
                box-shadow: 0 0 0 4px transparent;
                opacity: 0.7;
            }
        }
        
        @keyframes reactionPop {
            0% {
                transform: translate(-50%, -50%) scale(0);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.2);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(0.8);
                opacity: 0;
            }
        }

        .precision-badge-corner {
            position: fixed !important;
            top: 80px !important;
            right: 16px !important;
            z-index: 100 !important;
            margin: 0 !important;
            padding: 6px 12px !important;
            font-size: 10px !important;
            backdrop-filter: blur(12px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3) !important;
            display: block !important;
        }

        .precision-badge.ultrasonic-active {
            background: rgba(255, 193, 7, 0.2);
            border-color: rgba(255, 193, 7, 0.5);
            color: #ffc107;
            animation: ultrasonic-pulse 1.5s ease-in-out infinite;
        }

        @keyframes ultrasonic-pulse {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(255, 193, 7, 0.4);
            }
            50% {
                box-shadow: 0 0 0 4px rgba(255, 193, 7, 0);
            }
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        @keyframes slideUp {
            from {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
            to {
                opacity: 0;
                transform: translateX(-50%) translateY(-20px);
            }
        }

        .social-notification {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(22, 27, 34, 0.98);
            border: 1px solid rgba(56, 189, 98, 0.3);
            border-radius: 16px;
            padding: 16px 20px;
            max-width: 340px;
            width: calc(100% - 40px);
            z-index: 9998;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(56, 189, 98, 0.1);
            animation: popupSlideIn 0.4s ease;
            backdrop-filter: blur(10px);
        }

        .social-notification-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 10px;
        }

        .social-notification-avatar {
            width: 42px;
            height: 42px;
            border-radius: 50%;
            border: 2px solid rgba(56, 189, 98, 0.5);
            object-fit: cover;
        }

        .social-notification-info {
            flex: 1;
        }

        .social-notification-name {
            font-size: 15px;
            font-weight: 600;
            color: #f0f6fc;
            margin-bottom: 2px;
        }

        .social-notification-distance {
            font-size: 13px;
            color: #8b949e;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .social-notification-message {
            font-size: 14px;
            color: #c9d1d9;
            line-height: 1.5;
            margin-bottom: 12px;
        }

        .social-notification-actions {
            display: flex;
            gap: 8px;
        }

        .social-notification-btn {
            flex: 1;
            height: 38px;
            border-radius: 8px;
            border: none;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .social-notification-btn-primary {
            background: linear-gradient(135deg, #38bd62 0%, #2d9d51 100%);
            color: #fff;
        }

        .social-notification-btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(56, 189, 98, 0.4);
        }

        .social-notification-btn-secondary {
            background: rgba(255, 255, 255, 0.05);
            color: #8b949e;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .social-notification-btn-secondary:hover {
            background: rgba(255, 255, 255, 0.08);
            color: #c9d1d9;
        }

        .social-notification-close {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .social-notification-close:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .social-notification-close svg {
            width: 14px;
            height: 14px;
            color: #8b949e;
        }

        @keyframes popupSlideIn {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(-30px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0) scale(1);
            }
        }

        @keyframes popupSlideOut {
            from {
                opacity: 1;
                transform: translateX(-50%) translateY(0) scale(1);
            }
            to {
                opacity: 0;
                transform: translateX(-50%) translateY(-30px) scale(0.95);
            }
        }



        .radar-info-count {
            font-size: 32px;
            font-weight: 800;
            color: #2d3640;
            letter-spacing: -1px;
            text-shadow: 
                0 1px 0 rgba(255, 255, 255, 0.2),
                0 2px 4px rgba(0, 0, 0, 0.8),
                0 0 20px rgba(88, 166, 255, 0.4),
                inset 0 -2px 4px rgba(0, 0, 0, 0.3);
            background: linear-gradient(180deg, #3d4856 0%, #252b35 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            filter: drop-shadow(0 2px 6px rgba(88, 166, 255, 0.3));
            margin-bottom: 2px;
        }

        .compass-label {
            position: absolute;
            font-size: 32px;
            font-weight: 800;
            color: rgba(139, 148, 158, 0.10);
            user-select: none;
            pointer-events: none;
            font-family: 'Inter', sans-serif;
            letter-spacing: 1px;
            text-shadow: 0 0 20px rgba(139, 148, 158, 0.05);
        }

        .compass-n {
            top: 10%;
            left: 50%;
            transform: translateX(-50%);
        }

        .compass-s {
            bottom: 10%;
            left: 50%;
            transform: translateX(-50%);
        }

        .compass-e {
            right: 10%;
            top: 50%;
            transform: translateY(-50%);
        }

        .compass-o {
            left: 10%;
            top: 50%;
            transform: translateY(-50%);
        }

        /* Center avatar (current user) - Fixed in center, smaller and aesthetic */
        .center-avatar-fixed {
            position: absolute !important;
            left: 50% !important;
            top: 50% !important;
            transform: translate(-50%, -50%) !important;
            z-index: 100 !important;
            opacity: 1 !important;
            pointer-events: auto !important;
        }
        
        .center-avatar-fixed .avatar-wrapper {
            transform: none !important;
        }
        
        .center-avatar .avatar-ring {
            width: 50px;
            height: 50px;
            padding: 2px;
            box-shadow: 
                0 0 0 2px rgba(56, 189, 98, 0.15),
                0 0 20px rgba(56, 189, 98, 0.3),
                0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .center-avatar .avatar-img-wrapper {
            width: 46px;
            height: 46px;
            border: 2px solid #0d1117;
        }

        .direction-indicator {
            position: absolute;
            top: -8px;
            left: 50%;
            margin-left: -6px;
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 12px solid #38bd62;
            filter: drop-shadow(0 0 6px rgba(56, 189, 98, 0.6));
            transition: transform 0.1s ease-out;
            z-index: 10;
            pointer-events: none;
        }

        /* Regular avatars */
        .regular-avatar .avatar-ring {
            width: 58px;
            height: 58px;
            padding: 2px;
        }

        .regular-avatar .avatar-img-wrapper {
            width: 54px;
            height: 54px;
            border: 2px solid #0d1117;
        }

        .bottom-bar {
            display: none !important; /* Eliminado completamente */
        }

        .thought-input-container {
            position: absolute;
            bottom: max(env(safe-area-inset-bottom), 16px);
            left: 16px;
            right: 16px;
            z-index: 15;
            display: flex;
            align-items: center;
        }

        .thought-input {
            flex: 1;
            background: rgba(13, 17, 23, 0.95);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(56, 189, 98, 0.3);
            border-radius: 25px;
            padding: 13px 50px 13px 20px;
            color: #e6edf3;
            font-size: 15px;
            font-family: 'Inter', sans-serif;
            outline: none;
            transition: all 0.2s ease;
            font-weight: 400;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            letter-spacing: -0.2px;
            width: 100%;
        }
        
        .send-button {
            position: absolute;
            right: 6px;
            width: 38px;
            height: 38px;
            border-radius: 50%;
            background: rgba(56, 189, 98, 0.15);
            border: 1px solid rgba(56, 189, 98, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            opacity: 0.7;
        }
        
        .send-button:hover {
            opacity: 1;
            background: rgba(56, 189, 98, 0.25);
            transform: scale(1.05);
        }
        
        .send-button:active {
            transform: scale(0.95);
        }
        
        .send-button svg {
            width: 18px;
            height: 18px;
            color: #38bd62;
        }
        }

        .thought-input::placeholder {
            color: #6e7681;
        }

        .thought-input:focus {
            border-color: rgba(48, 54, 61, 0.7);
            background: rgba(22, 27, 34, 0.85);
        }

        .location-permission {
            position: fixed;
            inset: 0;
            background: rgba(13, 17, 23, 0.97);
            backdrop-filter: blur(20px);
            z-index: 400;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 30px;
        }

        .permission-card {
            background: rgba(22, 27, 34, 0.95);
            border: 1px solid rgba(48, 54, 61, 0.6);
            border-radius: 18px;
            padding: 34px 26px;
            text-align: center;
            max-width: 350px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .permission-icon {
            width: 68px;
            height: 68px;
            margin: 0 auto 22px;
            color: #58a6ff;
            opacity: 0.9;
        }

        .permission-card h2 {
            font-size: 21px;
            color: #f0f6fc;
            margin-bottom: 11px;
            font-weight: 600;
            letter-spacing: -0.3px;
        }

        .permission-card p {
            color: #8b949e;
            line-height: 1.6;
            margin-bottom: 26px;
            font-size: 14px;
            font-weight: 400;
        }

        .permission-btn {
            width: 100%;
            padding: 15px;
            border-radius: 11px;
            background: rgba(88, 166, 255, 0.14);
            color: #58a6ff;
            font-size: 15px;
            font-weight: 600;
            font-family: 'Inter', sans-serif;
            border: 1px solid rgba(88, 166, 255, 0.18);
            cursor: pointer;
            transition: all 0.2s ease;
            letter-spacing: -0.2px;
        }

        .chat-overlay {
            position: fixed;
            inset: 0;
            background: #0d1117;
            z-index: 200;
            display: flex;
            flex-direction: column;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }

        .chat-overlay.active {
            transform: translateX(0);
        }

        .inbox-overlay {
            position: fixed;
            inset: 0;
            background: #0d1117;
            z-index: 200;
            display: flex;
            flex-direction: column;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }

        .inbox-overlay.active {
            transform: translateX(0);
        }

        .story-upload-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 300;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .story-upload-overlay.active {
            display: flex;
        }

        .story-upload-container {
            width: 100%;
            max-width: 500px;
            background: #161b22;
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .story-upload-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 24px;
        }

        .story-upload-header h2 {
            font-size: 20px;
            font-weight: 600;
            color: #f0f6fc;
            margin: 0;
        }

        .story-upload-close {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .story-upload-close:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .story-upload-close svg {
            width: 20px;
            height: 20px;
            color: #8b949e;
        }

        .story-preview-area {
            width: 100%;
            aspect-ratio: 9/16;
            max-height: 60vh;
            background: #0d1117;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px;
            overflow: hidden;
            position: relative;
        }

        .story-preview-area img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .story-preview-placeholder {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            color: #6e7681;
        }

        .story-preview-placeholder svg {
            width: 64px;
            height: 64px;
        }

        .story-upload-actions {
            display: flex;
            gap: 12px;
        }

        .story-select-btn, .story-publish-btn {
            flex: 1;
            height: 48px;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .story-select-btn {
            background: rgba(56, 189, 98, 0.15);
            color: #38bd62;
            border: 1px solid rgba(56, 189, 98, 0.3);
        }

        .story-select-btn:hover {
            background: rgba(56, 189, 98, 0.25);
        }

        .story-publish-btn {
            background: linear-gradient(135deg, #38bd62 0%, #2d9d51 100%);
            color: #fff;
        }

        .story-publish-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 16px rgba(56, 189, 98, 0.4);
        }

        .story-publish-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .story-remove-btn {
            position: absolute;
            top: 12px;
            right: 12px;
            width: 36px;
            height: 36px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.2s ease;
        }

        .story-remove-btn:hover {
            background: rgba(220, 38, 38, 0.9);
        }

        .story-remove-btn svg {
            width: 20px;
            height: 20px;
            color: #fff;
        }


        .inbox-header {
            display: flex;
            align-items: center;
            gap: 14px;
            padding: 16px 20px;
            background: rgba(22, 27, 34, 0.95);
            border-bottom: 1px solid rgba(48, 54, 61, 0.5);
        }

        .inbox-header svg {
            width: 26px;
            height: 26px;
            color: #8b949e;
            cursor: pointer;
        }

        .inbox-header h2 {
            flex: 1;
            font-size: 18px;
            font-weight: 600;
            color: #f0f6fc;
            margin: 0;
        }

        .inbox-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }

        .inbox-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px 12px;
            background: rgba(22, 27, 34, 0.5);
            border-radius: 12px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }

        .inbox-item:hover {
            background: rgba(22, 27, 34, 0.8);
            border-color: rgba(56, 189, 98, 0.3);
        }

        .inbox-item.unread {
            background: rgba(56, 189, 98, 0.08);
            border-color: rgba(56, 189, 98, 0.3);
        }

        .inbox-avatar {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            border: 2px solid rgba(71, 85, 105, 0.5);
            flex-shrink: 0;
        }

        .inbox-item.unread .inbox-avatar {
            border-color: #fbbf24;
        }

        .inbox-info {
            flex: 1;
            min-width: 0;
        }

        .inbox-name {
            font-size: 15px;
            font-weight: 600;
            color: #f0f6fc;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .unread-count-badge {
            background: linear-gradient(135deg, #f43f5e 0%, #ec4899 100%);
            color: white;
            font-size: 11px;
            font-weight: 700;
            padding: 2px 6px;
            border-radius: 10px;
            min-width: 18px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(244, 63, 94, 0.3);
        }

        .inbox-preview {
            font-size: 13px;
            color: #8b949e;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .inbox-item.unread .inbox-preview {
            color: #c9d1d9;
            font-weight: 500;
        }

        .inbox-meta {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 4px;
        }

        .inbox-distance {
            font-size: 11px;
            color: #6e7681;
        }

        .inbox-unread-badge {
            background: #ef4444;
            color: #fff;
            font-size: 10px;
            font-weight: 700;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .inbox-empty {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #6e7681;
            padding: 40px 20px;
        }

        .inbox-empty svg {
            width: 64px;
            height: 64px;
            margin-bottom: 16px;
            opacity: 0.4;
        }

        .inbox-empty p {
            font-size: 15px;
            margin: 0;
        }

        /* ========================================
           TECH SETTINGS OVERLAY
           ======================================== */
        .tech-settings-overlay {
            position: fixed;
            inset: 0;
            background: #0d1117;
            z-index: 200;
            display: flex;
            flex-direction: column;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }

        .tech-settings-overlay.active {
            transform: translateX(0);
        }

        .tech-settings-header {
            display: flex;
            align-items: center;
            gap: 14px;
            padding: 16px 20px;
            background: rgba(22, 27, 34, 0.95);
            border-bottom: 1px solid rgba(48, 54, 61, 0.5);
        }

        .tech-settings-header svg {
            width: 26px;
            height: 26px;
            color: #8b949e;
            cursor: pointer;
        }

        .tech-settings-header h2 {
            flex: 1;
            font-size: 18px;
            font-weight: 600;
            color: #f0f6fc;
            margin: 0;
        }

        .tech-settings-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .tech-mode-selector {
            margin-bottom: 30px;
        }

        .tech-mode-selector h3 {
            font-size: 14px;
            font-weight: 600;
            color: #f0f6fc;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .tech-mode-options {
            display: flex;
            gap: 12px;
        }

        .tech-mode-option {
            flex: 1;
            padding: 12px;
            background: rgba(22, 27, 34, 0.5);
            border: 2px solid rgba(48, 54, 61, 0.5);
            border-radius: 12px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tech-mode-option:hover {
            background: rgba(22, 27, 34, 0.8);
            border-color: rgba(56, 189, 98, 0.3);
        }

        .tech-mode-option.active {
            background: rgba(56, 189, 98, 0.15);
            border-color: rgba(56, 189, 98, 0.6);
        }

        .tech-mode-option .icon {
            font-size: 24px;
            margin-bottom: 6px;
        }

        .tech-mode-option .label {
            font-size: 12px;
            font-weight: 600;
            color: #c9d1d9;
        }

        .tech-mode-option.active .label {
            color: #38bd62;
        }

        .tech-mode-option .description {
            font-size: 10px;
            color: #8b949e;
            margin-top: 4px;
        }

        .tech-list {
            margin-top: 20px;
        }

        .tech-list h3 {
            font-size: 14px;
            font-weight: 600;
            color: #f0f6fc;
            margin-bottom: 16px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .tech-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px;
            background: rgba(22, 27, 34, 0.5);
            border: 1px solid rgba(48, 54, 61, 0.5);
            border-radius: 12px;
            margin-bottom: 12px;
            transition: all 0.2s ease;
        }

        .tech-item:hover {
            background: rgba(22, 27, 34, 0.8);
        }

        .tech-item.disabled {
            opacity: 0.5;
            pointer-events: none;
        }

        .tech-item-info {
            flex: 1;
        }

        .tech-item-name {
            font-size: 15px;
            font-weight: 600;
            color: #f0f6fc;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tech-item-icon {
            font-size: 18px;
        }

        .tech-item-description {
            font-size: 12px;
            color: #8b949e;
            line-height: 1.4;
        }

        .tech-toggle {
            position: relative;
            width: 50px;
            height: 28px;
            background: rgba(139, 148, 158, 0.3);
            border-radius: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .tech-toggle.active {
            background: rgba(56, 189, 98, 0.5);
        }

        .tech-toggle::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 22px;
            height: 22px;
            background: #8b949e;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .tech-toggle.active::after {
            left: 25px;
            background: #38bd62;
        }

        .tech-info-note {
            margin-top: 30px;
            padding: 16px;
            background: rgba(56, 139, 253, 0.1);
            border: 1px solid rgba(56, 139, 253, 0.3);
            border-radius: 12px;
        }

        .tech-info-note h4 {
            font-size: 13px;
            font-weight: 600;
            color: #58a6ff;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .tech-info-note p {
            font-size: 12px;
            color: #8b949e;
            line-height: 1.5;
            margin: 0;
        }

        .tech-apply-container {
            margin-top: 24px;
            padding: 0 4px 4px;
        }

        .tech-apply-btn {
            width: 100%;
            height: 52px;
            background: linear-gradient(135deg, #38bd62 0%, #2d9d51 100%);
            border: none;
            border-radius: 12px;
            color: #fff;
            font-size: 16px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            cursor: pointer;
            box-shadow: 0 4px 16px rgba(56, 189, 98, 0.3);
            transition: all 0.2s ease;
        }

        .tech-apply-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(56, 189, 98, 0.4);
        }

        .tech-apply-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(56, 189, 98, 0.3);
        }

        .tech-apply-btn svg {
            flex-shrink: 0;
        }


        .chat-header {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 16px;
            background: #1f2c33;
            border-bottom: none;
        }

        .chat-header svg {
            width: 24px;
            height: 24px;
            color: #aebac1;
            cursor: pointer;
        }

        .chat-user-info {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .chat-user-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            cursor: pointer;
            transition: transform 0.2s ease;
        }
        
        .chat-user-avatar:hover {
            transform: scale(1.05);
        }
        
        .chat-avatar-wrapper {
            position: relative;
            width: 40px;
            height: 40px;
            cursor: pointer;
        }
        
        .chat-avatar-ring {
            position: absolute;
            width: 46px;
            height: 46px;
            border-radius: 50%;
            top: -3px;
            left: -3px;
            pointer-events: none;
        }
        
        .chat-avatar-ring.has-story {
            background: linear-gradient(45deg, #f09433 0%, #e6683c 25%, #dc2743 50%, #cc2366 75%, #bc1888 100%);
            padding: 2px;
        }
        
        .chat-avatar-ring.story-seen {
            background: #8696a0;
            padding: 2px;
        }

        .chat-user-details h3 {
            font-size: 16px;
            font-weight: 400;
            color: #e9edef;
            margin-bottom: 0px;
        }

        .chat-user-details p {
            font-size: 13px;
            color: #8696a0;
        }

        .chat-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .chat-thought-display {
            background: rgba(22, 27, 34, 0.7);
            border: 1px solid rgba(48, 54, 61, 0.4);
            padding: 10px 16px;
            margin: 12px 16px;
            border-radius: 10px;
            color: #8b949e;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            /* Fondo tipo WhatsApp */
            background: #0b141a;
            background-image: 
                repeating-linear-gradient(
                    45deg,
                    transparent,
                    transparent 10px,
                    rgba(255, 255, 255, 0.02) 10px,
                    rgba(255, 255, 255, 0.02) 20px
                );
        }

        .chat-info {
            background: rgba(22, 27, 34, 0.6);
            border: 1px solid rgba(48, 54, 61, 0.3);
            padding: 12px 16px;
            border-radius: 10px;
            color: #8b949e;
            font-size: 13px;
            text-align: center;
            line-height: 1.5;
        }

        .message {
            max-width: 75%;
            padding: 6px 7px 8px 9px;
            border-radius: 8px;
            font-size: 14.2px;
            line-height: 19px;
            word-wrap: break-word;
            position: relative;
            box-shadow: 0 1px 0.5px rgba(0, 0, 0, 0.13);
            margin-bottom: 2px;
        }

        .message.sent {
            background: #005c4b;
            color: #e9edef;
            align-self: flex-end;
            border-radius: 8px 8px 0 8px;
        }

        .message.received {
            background: #1f2c33;
            color: #e9edef;
            align-self: flex-start;
            border-radius: 0 8px 8px 8px;
        }
        
        /* Timestamp en mensaje */
        .message-time {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.5);
            margin-left: 8px;
            float: right;
            margin-top: 4px;
        }
        
        /* Checkmarks para mensajes enviados */
        .message-status {
            display: inline-block;
            margin-left: 4px;
            font-size: 14px;
            vertical-align: middle;
            transition: color 0.3s ease;
        }
        
        .message-status.sent {
            color: rgba(255, 255, 255, 0.4); /* Gris - enviado */
        }
        
        .message-status.delivered {
            color: rgba(255, 255, 255, 0.4); /* Gris - entregado */
        }
        
        .message-status.read {
            color: #53bdeb; /* Azul - leído */
        }

        .chat-input-container {
            padding: 5px 8px 5px 8px;
            background: #1f2c33;
            display: flex;
            gap: 6px;
            align-items: center;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
        }

        .chat-input {
            flex: 1;
            background: #2a3942;
            border: none;
            border-radius: 20px;
            padding: 10px 12px;
            color: #e9edef;
            font-size: 15px;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            outline: none;
            resize: none;
            min-height: 40px;
            max-height: 100px;
        }

        .chat-input::placeholder {
            color: #8696a0;
        }

        .chat-send-btn {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: #00a884;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .chat-send-btn:disabled {
            background: #182229;
            cursor: not-allowed;
        }

        .chat-send-btn:not(:disabled):active {
            transform: scale(0.95);
            background: #06cf9c;
        }

        .chat-send-btn svg {
            color: #0b141a;
        }
        
        .chat-send-btn:disabled svg {
            color: #8696a0;
        }
        
        /* Botón redondo (emoji, adjuntar, etc) */
        .btn-round {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: transparent;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background 0.2s ease;
            flex-shrink: 0;
            color: #8696a0;
        }
        
        .btn-round:active {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .btn-round svg {
            width: 26px;
            height: 26px;
        }

        /* Sidebar */
        .sidebar {
            position: fixed;
            left: 0;
            top: 0;
            bottom: 0;
            width: 280px;
            background: rgba(22, 27, 34, 0.98);
            backdrop-filter: blur(20px);
            border-right: 1px solid rgba(48, 54, 61, 0.5);
            z-index: 300;
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        .sidebar.active {
            transform: translateX(0);
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid rgba(48, 54, 61, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .sidebar-header h2 {
            font-size: 20px;
            font-weight: 600;
            color: #f0f6fc;
        }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px 0;
        }

        .sidebar-item {
            padding: 14px 20px;
            display: flex;
            align-items: center;
            gap: 14px;
            color: #c9d1d9;
            cursor: pointer;
            transition: all 0.2s ease;
            border-left: 3px solid transparent;
        }

        .sidebar-item:hover {
            background: rgba(48, 54, 61, 0.3);
            border-left-color: #58a6ff;
        }

        .sidebar-item svg {
            width: 22px;
            height: 22px;
            color: #8b949e;
        }

        /* Profile */
        .profile-overlay {
            position: fixed;
            inset: 0;
            background: #0d1117;
            z-index: 250;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        .profile-overlay.active {
            transform: translateX(0);
        }

        .profile-header {
            padding: 16px 20px;
            background: rgba(22, 27, 34, 0.95);
            border-bottom: 1px solid rgba(48, 54, 61, 0.5);
            display: flex;
            align-items: center;
            gap: 14px;
        }

        .profile-content {
            flex: 1;
            overflow-y: auto;
            padding: 24px 20px;
        }

        .profile-avatar-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 28px;
        }

        .profile-avatar-large {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            border: 3px solid rgba(88, 166, 255, 0.3);
            object-fit: cover;
            margin-bottom: 16px;
        }

        .profile-name {
            font-size: 24px;
            font-weight: 600;
            color: #f0f6fc;
            margin-bottom: 4px;
        }

        .profile-bio {
            color: #8b949e;
            text-align: center;
            font-size: 14px;
        }

        .profile-section {
            margin-bottom: 24px;
        }

        .profile-section-title {
            font-size: 13px;
            font-weight: 600;
            color: #8b949e;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
        }

        .profile-field {
            background: rgba(22, 27, 34, 0.6);
            border: 1px solid rgba(48, 54, 61, 0.4);
            border-radius: 10px;
            padding: 12px 16px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .profile-field-label {
            color: #8b949e;
            font-size: 14px;
        }

        .profile-field-value {
            color: #f0f6fc;
            font-size: 14px;
            font-weight: 500;
        }

        /* Circular Story Viewer */
        /* Story Viewer - Instagram Style */
        .story-viewer {
            position: fixed;
            inset: 0;
            background: #000;
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .story-viewer.active {
            opacity: 1;
            visibility: visible;
        }

        .story-container {
            width: 100%;
            height: 100%;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .story-progress-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: rgba(255, 255, 255, 0.3);
            z-index: 10;
            overflow: hidden;
        }

        .story-progress-fill {
            height: 100%;
            background: #fff;
            width: 0%;
            animation: storyProgress 5s linear forwards;
        }

        @keyframes storyProgress {
            from {
                width: 0%;
            }
            to {
                width: 100%;
            }
        }

        .story-header {
            position: absolute;
            top: 16px;
            left: 16px;
            right: 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            z-index: 10;
        }

        .story-user-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .story-user-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: 2px solid #fff;
            object-fit: cover;
        }

        .story-user-name {
            color: #fff;
            font-size: 14px;
            font-weight: 600;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
        }

        .story-close {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .story-close:active {
            background: rgba(0, 0, 0, 0.7);
        }

        .story-close svg {
            width: 20px;
            height: 20px;
            color: #fff;
        }

        .story-image {
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            object-fit: contain;
        }

        .story-message-btn {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            padding: 14px 28px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 50px;
            color: #fff;
            font-size: 15px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            box-shadow: 0 8px 24px rgba(102, 126, 234, 0.4);
            transition: all 0.3s ease;
            z-index: 11;
        }

        .story-message-btn:hover {
            transform: translateX(-50%) translateY(-2px);
            box-shadow: 0 12px 32px rgba(102, 126, 234, 0.5);
        }

        .story-message-btn:active {
            transform: translateX(-50%) translateY(0px);
        }
        
        /* Story Reactions */
        .story-reactions {
            position: absolute;
            bottom: 110px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            z-index: 11;
        }
        
        .story-reaction-btn {
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(12px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            padding: 0;
        }
        
        .story-reaction-btn:hover {
            transform: scale(1.2);
            background: rgba(0, 0, 0, 0.8);
            border-color: rgba(255, 255, 255, 0.4);
        }
        
        .story-reaction-btn:active {
            transform: scale(0.9);
        }

        .overlay-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            z-index: 250;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .overlay-backdrop.active {
            opacity: 1;
            pointer-events: all;
        }
        /* Landing Page - Pantalla de Bienvenida */
        .landing-page {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, #0d1117 0%, #161b22 50%, #0d1117 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            padding: 20px;
        }

        .landing-content {
            text-align: center;
            max-width: 400px;
            width: 100%;
        }

        .landing-logo {
            font-size: 80px;
            margin-bottom: 20px;
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        .landing-title {
            font-size: 32px;
            font-weight: 700;
            color: #fff;
            margin-bottom: 10px;
            letter-spacing: -0.5px;
        }

        .landing-subtitle {
            font-size: 16px;
            color: #8b949e;
            margin-bottom: 40px;
            line-height: 1.5;
        }

        .google-signin-btn {
            background: #fff;
            color: #1f2937;
            border: none;
            border-radius: 50px;
            padding: 16px 40px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            margin: 0 auto;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }

        .google-signin-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        }

        .google-signin-btn:active {
            transform: translateY(0px);
        }

        .google-icon {
            width: 20px;
            height: 20px;
        }

        .landing-features {
            margin-top: 60px;
            display: flex;
            gap: 30px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .landing-feature {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            opacity: 0.7;
        }

        .landing-feature-icon {
            font-size: 32px;
        }

        .landing-feature-text {
            font-size: 12px;
            color: #8b949e;
        }

        /* ========================================
           ANDROID NAVIGATION BAR FIX - DEFINITIVO
           ======================================== */
        
        /* Soporte para navegadores modernos con dvh (dynamic viewport height) */
        @supports (height: 100dvh) {
            body, #root {
                height: 100dvh !important;
            }
        }
        
        /* Fallback para navegadores sin dvh */
        @supports not (height: 100dvh) {
            body, #root {
                height: calc(100vh - env(safe-area-inset-bottom, 0px)) !important;
            }
        }
        
        /* Asegurar que elementos fixed en bottom respeten la barra de Android */
        @media (max-height: 700px) {
            /* Pantallas pequeñas: reducir padding adicional */
            .main-container {
                padding-bottom: calc(120px + env(safe-area-inset-bottom, 0px)) !important;
            }
            .range-slider-container {
                bottom: calc(110px + env(safe-area-inset-bottom, 0px)) !important;
            }
        }
        
        /* Para Android Chrome específicamente */
        @supports (-webkit-touch-callout: none) {
            /* iOS Safari */
            body {
                padding-bottom: env(safe-area-inset-bottom, 20px);
            }
        }
        
        /* Prevenir scroll bounce en iOS */
        html {
            overscroll-behavior: none;
            -webkit-overflow-scrolling: touch;
        }
        
        /* Asegurar que el contenido nunca quede detrás de la barra */
        * {
            box-sizing: border-box;
        }

    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Initialize Firebase
        const firebaseConfig = {
            apiKey: "AIzaSyAhcfX0M5oqX7rZ6WdCZaHfxHKcxySxQl8",
            authDomain: "radar-social-5a61f.firebaseapp.com",
            projectId: "radar-social-5a61f",
            storageBucket: "radar-social-5a61f.firebasestorage.app",
            messagingSenderId: "1010787643000",
            appId: "1:1010787643000:web:e9dc6a1c175d875b90478d",
            measurementId: "G-NXM0HPCWMY"
        };
        
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();
        const storage = firebase.storage();

        // ==========================================
        // KALMAN FILTER CLASS - Suaviza GPS
        // ==========================================
        class KalmanFilter {
            constructor(processNoise = 0.001, measurementNoise = 0.1) {
                this.x = 0;  // Estado estimado
                this.P = 1;  // Error de estimación
                this.Q = processNoise;  // Ruido del proceso
                this.R = measurementNoise;  // Ruido de medición
            }
            
            update(measurement) {
                // Predicción
                this.P = this.P + this.Q;
                
                // Actualización (corrección)
                const K = this.P / (this.P + this.R);  // Ganancia de Kalman
                this.x = this.x + K * (measurement - this.x);
                this.P = (1 - K) * this.P;
                
                return this.x;
            }
            
            reset(value) {
                this.x = value;
                this.P = 1;
            }
        }

        function RadarSocialApp() {
            const [showLanding, setShowLanding] = useState(true); // Landing page con Google Sign In
            const [locationPermission, setLocationPermission] = useState(false);
            const [radius, setRadius] = useState(100); // Aumentado de 50m a 100m
            const [thought, setThought] = useState('');
            const [currentUser, setCurrentUser] = useState(null);
            const [userLocation, setUserLocation] = useState(null);
            const [users, setUsers] = useState([]); // Start empty - will load from Firebase
            const [lastSeenUsers, setLastSeenUsers] = useState({}); // Track when we last saw each user
            const [isDraggingDial, setIsDraggingDial] = useState(false);
            const [selectedUser, setSelectedUser] = useState(null);
            const [chats, setChats] = useState({});
            const [messages, setMessages] = useState({});
            const [messageInput, setMessageInput] = useState('');
            const [selectedImage, setSelectedImage] = useState(null);
            const [messageSentTimestamps, setMessageSentTimestamps] = useState([]); // Rate limiting
            const [audioContext, setAudioContext] = useState(null);
            const [showSidebar, setShowSidebar] = useState(false);
            const [showProfile, setShowProfile] = useState(false);
            const [showInbox, setShowInbox] = useState(false);
            const [showTechSettings, setShowTechSettings] = useState(false);
            
            // Estados para control de tecnologías
            const [techSettings, setTechSettings] = useState({
                mode: 'auto', // 'auto', 'manual'
                gps: true,
                kalman: true,
                deadReckoning: true,
                ultrasonic: true
            });
            const [activeTech, setActiveTech] = useState({
                name: 'GPS',
                icon: '📍',
                precision: 5.0
            });
            const [techRefreshTicker, setTechRefreshTicker] = useState(0); // Para forzar refresh de tecnologías
            const [showStoryUpload, setShowStoryUpload] = useState(false);
            const [storyImage, setStoryImage] = useState(null);
            const [uploadingStory, setUploadingStory] = useState(false);
            const [socialNotifications, setSocialNotifications] = useState([]);
            const [notificationsEnabled, setNotificationsEnabled] = useState(false);
            const [soundEnabled, setSoundEnabled] = useState(true);
            const [googleMap, setGoogleMap] = useState(null); // Instancia del mapa de Google Maps
            const [mapMarkers, setMapMarkers] = useState({}); // Markers de usuarios en el mapa
            const mapRef = useRef(null); // Referencia al div del mapa
            const [wakeLockEnabled, setWakeLockEnabled] = useState(false);
            const wakeLockRef = useRef(null);
            const [previousNearbyUsers, setPreviousNearbyUsers] = useState([]);
            const [notifiedUsers, setNotifiedUsers] = useState({}); // { userId: timestamp }
            const [viewingStory, setViewingStory] = useState(null);
            const [storyReactions, setStoryReactions] = useState({}); // { userId: 'emoji' }
            const [viewedStories, setViewedStories] = useState({}); // { userId: timestamp }
            const [deviceHeading, setDeviceHeading] = useState(0); // Phone compass direction
            const [lastKnownPositions, setLastKnownPositions] = useState({}); // For GPS smoothing
            
            // SENSOR FUSION - Estados para sensores
            const [sensorData, setSensorData] = useState({
                acceleration: { x: 0, y: 0, z: 0 },
                rotation: { alpha: 0, beta: 0, gamma: 0 },
                heading: 0,
                isMoving: false,
                lastMotionTime: 0
            });
            const [locationAccuracy, setLocationAccuracy] = useState(20); // metros
            
            // ULTRASONIC SYSTEM - Estados para audio ultrasónico
            const [ultrasonicActive, setUltrasonicActive] = useState(false);
            const [ultrasonicDetections, setUltrasonicDetections] = useState({}); // { userId: distance }
            const ultrasonicContext = useRef(null);
            const ultrasonicAnalyser = useRef(null);
            const detectionInterval = useRef(null);
            const chatMessagesRef = useRef(null);
            
            // Kalman Filters para latitud y longitud
            const kalmanLat = useRef(new KalmanFilter(0.001, 0.1));
            const kalmanLon = useRef(new KalmanFilter(0.001, 0.1));
            const lastDeadReckoningPos = useRef(null);
            const lastDeadReckoningTime = useRef(Date.now());

            // Calculate distance between two GPS coordinates (Haversine formula)
            const calculateDistance = (lat1, lon1, lat2, lon2) => {
                const R = 6371e3; // Earth's radius in meters
                const φ1 = lat1 * Math.PI / 180;
                const φ2 = lat2 * Math.PI / 180;
                const Δφ = (lat2 - lat1) * Math.PI / 180;
                const Δλ = (lon2 - lon1) * Math.PI / 180;

                const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
                          Math.cos(φ1) * Math.cos(φ2) *
                          Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

                return R * c; // Distance in meters
            };

            // Calculate angle/bearing from point 1 to point 2
            const calculateBearing = (lat1, lon1, lat2, lon2) => {
                const φ1 = lat1 * Math.PI / 180;
                const φ2 = lat2 * Math.PI / 180;
                const Δλ = (lon2 - lon1) * Math.PI / 180;

                const y = Math.sin(Δλ) * Math.cos(φ2);
                const x = Math.cos(φ1) * Math.sin(φ2) -
                          Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);
                const θ = Math.atan2(y, x);

                return (θ * 180 / Math.PI + 360) % 360; // Bearing in degrees
            };

            // ==========================================
            // SENSOR FUSION - Dead Reckoning
            // ==========================================
            const applyDeadReckoning = (lastPos, acceleration, heading, deltaTime) => {
                if (!lastPos || !sensorData.isMoving) return lastPos;
                
                // Calcular velocidad aproximada desde aceleración
                // v = a * t (aproximación simple)
                const speed = Math.sqrt(
                    acceleration.x ** 2 + 
                    acceleration.y ** 2
                ) * deltaTime; // metros
                
                // Convertir heading a radianes
                const headingRad = heading * Math.PI / 180;
                
                // Calcular desplazamiento en metros
                const dx = speed * Math.sin(headingRad);
                const dy = speed * Math.cos(headingRad);
                
                // Convertir metros a grados (aproximado)
                const dLat = dy / 111320; // 1 grado lat ≈ 111.32 km
                const dLon = dx / (111320 * Math.cos(lastPos.latitude * Math.PI / 180));
                
                return {
                    latitude: lastPos.latitude + dLat,
                    longitude: lastPos.longitude + dLon
                };
            };

            // ==========================================
            // SENSOR FUSION - Combina GPS + Sensores
            // ==========================================
            const applySensorFusion = (rawGPS, accuracy) => {
                // 1. Aplicar Kalman Filter al GPS
                const filteredLat = kalmanLat.current.update(rawGPS.latitude);
                const filteredLon = kalmanLon.current.update(rawGPS.longitude);
                
                // 2. Si el usuario está en movimiento, aplicar Dead Reckoning
                if (sensorData.isMoving && lastDeadReckoningPos.current) {
                    const now = Date.now();
                    const deltaTime = (now - lastDeadReckoningTime.current) / 1000; // segundos
                    
                    const predictedPos = applyDeadReckoning(
                        lastDeadReckoningPos.current,
                        sensorData.acceleration,
                        sensorData.heading,
                        deltaTime
                    );
                    
                    // 3. Combinar GPS filtrado con predicción
                    // Dar más peso al GPS si la precisión es buena
                    const gpsWeight = Math.max(0.3, Math.min(0.9, 1 - (accuracy / 50)));
                    const drWeight = 1 - gpsWeight;
                    
                    const fusedLat = (filteredLat * gpsWeight) + (predictedPos.latitude * drWeight);
                    const fusedLon = (filteredLon * gpsWeight) + (predictedPos.longitude * drWeight);
                    
                    lastDeadReckoningTime.current = now;
                    lastDeadReckoningPos.current = { latitude: fusedLat, longitude: fusedLon };
                    
                    // Precisión mejorada (2-5m típicamente)
                    const improvedAccuracy = Math.min(accuracy * 0.3, 5);
                    setLocationAccuracy(improvedAccuracy);
                    
                    console.log(`🧠 Sensor Fusion: GPS(${accuracy.toFixed(1)}m) → Fused(${improvedAccuracy.toFixed(1)}m)`);
                    
                    return {
                        latitude: fusedLat,
                        longitude: fusedLon,
                        accuracy: improvedAccuracy
                    };
                } else {
                    // Usuario quieto, solo usar GPS filtrado
                    lastDeadReckoningPos.current = { latitude: filteredLat, longitude: filteredLon };
                    lastDeadReckoningTime.current = Date.now();
                    
                    const improvedAccuracy = Math.min(accuracy * 0.5, 8);
                    setLocationAccuracy(improvedAccuracy);
                    
                    console.log(`📍 Kalman Filter: GPS(${accuracy.toFixed(1)}m) → Filtered(${improvedAccuracy.toFixed(1)}m)`);
                    
                    return {
                        latitude: filteredLat,
                        longitude: filteredLon,
                        accuracy: improvedAccuracy
                    };
                }
            };

            // ==========================================
            // GOOGLE MAPS - Inicialización y Manejo
            // ==========================================
            
            // Inicializar mapa de Google Maps
            const initializeGoogleMap = (lat, lng) => {
                console.log('🗺️ initializeGoogleMap llamada con:', lat, lng);
                console.log('   mapRef.current:', mapRef.current);
                console.log('   googleMap:', googleMap);
                console.log('   typeof google:', typeof google);
                console.log('   typeof google.maps:', typeof google !== 'undefined' ? typeof google.maps : 'google undefined');
                
                if (!mapRef.current) {
                    console.error('❌ mapRef.current es null!');
                    return;
                }
                
                if (googleMap) {
                    console.log('⚠️ googleMap ya existe, no reinicializar');
                    return;
                }
                
                if (typeof google === 'undefined' || typeof google.maps === 'undefined') {
                    console.error('❌ Google Maps API no está cargada!');
                    return;
                }
                
                console.log('✅ Todas las verificaciones pasaron, creando mapa...');
                
                // Estilo dark/military para el mapa (como Instagram)
                const darkStyle = [
                    { elementType: 'geometry', stylers: [{ color: '#0d1117' }] },
                    { elementType: 'labels.text.stroke', stylers: [{ color: '#0d1117' }] },
                    { elementType: 'labels.text.fill', stylers: [{ color: '#8696a0' }] },
                    {
                        featureType: 'administrative.locality',
                        elementType: 'labels.text.fill',
                        stylers: [{ color: '#a0a9b1' }]
                    },
                    {
                        featureType: 'poi',
                        elementType: 'labels.text.fill',
                        stylers: [{ color: '#757c85' }]
                    },
                    {
                        featureType: 'poi.park',
                        elementType: 'geometry',
                        stylers: [{ color: '#1a2a1f' }]
                    },
                    {
                        featureType: 'poi.park',
                        elementType: 'labels.text.fill',
                        stylers: [{ color: '#5a7061' }]
                    },
                    {
                        featureType: 'road',
                        elementType: 'geometry',
                        stylers: [{ color: '#1f2933' }]
                    },
                    {
                        featureType: 'road',
                        elementType: 'geometry.stroke',
                        stylers: [{ color: '#2a3542' }]
                    },
                    {
                        featureType: 'road',
                        elementType: 'labels.text.fill',
                        stylers: [{ color: '#9ca5af' }]
                    },
                    {
                        featureType: 'road.highway',
                        elementType: 'geometry',
                        stylers: [{ color: '#2e3d4d' }]
                    },
                    {
                        featureType: 'road.highway',
                        elementType: 'geometry.stroke',
                        stylers: [{ color: '#3a4a5c' }]
                    },
                    {
                        featureType: 'transit',
                        elementType: 'geometry',
                        stylers: [{ color: '#1a2530' }]
                    },
                    {
                        featureType: 'transit.station',
                        elementType: 'labels.text.fill',
                        stylers: [{ color: '#757c85' }]
                    },
                    {
                        featureType: 'water',
                        elementType: 'geometry',
                        stylers: [{ color: '#0a1520' }]
                    },
                    {
                        featureType: 'water',
                        elementType: 'labels.text.fill',
                        stylers: [{ color: '#4a5a68' }]
                    },
                    {
                        featureType: 'water',
                        elementType: 'labels.text.stroke',
                        stylers: [{ color: '#0a1520' }]
                    }
                ];
                
                // Crear mapa
                const map = new google.maps.Map(mapRef.current, {
                    center: { lat, lng },
                    zoom: getZoomFromRadius(radius),
                    styles: darkStyle,
                    disableDefaultUI: true, // Ocultar controles default
                    gestureHandling: 'greedy', // Permitir arrastrar con un dedo
                    clickableIcons: false, // No hacer POIs clickeables
                    mapTypeControl: false,
                    fullscreenControl: false,
                    streetViewControl: false,
                    zoomControl: false,
                });
                
                setGoogleMap(map);
                console.log('✅ Google Maps CREADO Y GUARDADO!');
                console.log('   Mapa:', map);
                console.log('   Centro:', map.getCenter());
                console.log('   Zoom:', map.getZoom());
            };
            
            // Convertir radio (metros) a nivel de zoom de Google Maps
            const getZoomFromRadius = (radiusInMeters) => {
                // Fórmula aproximada para convertir radio a zoom
                // Zoom 20 = ~50m, Zoom 19 = ~100m, Zoom 18 = ~200m, etc.
                if (radiusInMeters <= 5) return 20;
                if (radiusInMeters <= 30) return 19;
                if (radiusInMeters <= 60) return 18;
                if (radiusInMeters <= 100) return 17;
                return 16;
            };
            
            // Actualizar zoom del mapa cuando cambia el radio
            useEffect(() => {
                if (googleMap && radius && currentUser) {
                    const newZoom = getZoomFromRadius(radius);
                    // ✅ CENTRAR EN USUARIO al hacer zoom
                    googleMap.setCenter({ 
                        lat: currentUser.latitude, 
                        lng: currentUser.longitude 
                    });
                    googleMap.setZoom(newZoom);
                    console.log(`🔍 Zoom actualizado a ${newZoom} (radio: ${radius}m) - Centrado en usuario`);
                }
            }, [radius, googleMap, currentUser]);
            
            // Inicializar mapa cuando tengamos ubicación del usuario
            useEffect(() => {
                console.log('🔄 useEffect de inicialización ejecutado');
                console.log('   currentUser:', currentUser);
                console.log('   currentUser.latitude:', currentUser?.latitude);
                console.log('   currentUser.longitude:', currentUser?.longitude);
                console.log('   googleMap:', googleMap);
                
                if (currentUser && currentUser.latitude && currentUser.longitude && !googleMap) {
                    console.log('✅ Condiciones cumplidas, llamando initializeGoogleMap...');
                    initializeGoogleMap(currentUser.latitude, currentUser.longitude);
                } else {
                    console.log('⏳ Esperando condiciones:', {
                        tieneUsuario: !!currentUser,
                        tieneLatitud: !!currentUser?.latitude,
                        tieneLongitud: !!currentUser?.longitude,
                        noTieneMapa: !googleMap
                    });
                }
            }, [currentUser, googleMap]);
            
            // Centrar mapa en usuario cuando su ubicación cambie
            useEffect(() => {
                if (googleMap && currentUser && currentUser.latitude && currentUser.longitude) {
                    googleMap.panTo({
                        lat: currentUser.latitude,
                        lng: currentUser.longitude
                    });
                }
            }, [currentUser?.latitude, currentUser?.longitude, googleMap]);
            
            // Crear marker personalizado (avatar) para un usuario en el mapa
            const createUserMarker = (user, map, currentUserData, isCurrentUser = false) => {
                // Crear elemento HTML del marker
                const markerDiv = document.createElement('div');
                markerDiv.className = 'map-marker';
                
                // Z-index dinámico: usuarios más cerca quedan detrás, más lejos adelante
                const zIndex = calculateZIndex(user, currentUserData, isCurrentUser);
                
                markerDiv.style.cssText = `
                    width: ${isCurrentUser ? '60px' : '50px'};
                    height: ${isCurrentUser ? '60px' : '50px'};
                    cursor: pointer;
                    position: relative;
                    z-index: ${zIndex};
                `;
                
                // Anillo (story o estado online)
                const ring = document.createElement('div');
                const hasStory = user.hasStory;
                const hasNewMessage = user.hasNewMessage;
                const isOnline = user.isOnline;
                
                let ringColor;
                if (hasStory) {
                    const alreadyViewed = viewedStories[user.id] && 
                                        (!user.storyTimestamp || user.storyTimestamp <= viewedStories[user.id]);
                    ringColor = alreadyViewed 
                        ? 'rgba(139, 148, 158, 0.4)' 
                        : 'linear-gradient(45deg, #f09433 0%, #e6683c 25%, #dc2743 50%, #cc2366 75%, #bc1888 100%)';
                } else if (hasNewMessage) {
                    ringColor = '#ffd700';
                } else if (isOnline || isCurrentUser) {
                    ringColor = '#38bd62';
                } else {
                    ringColor = 'rgba(139, 148, 158, 0.4)';
                }
                
                ring.style.cssText = `
                    position: absolute;
                    width: 100%;
                    height: 100%;
                    border-radius: 50%;
                    background: ${ringColor};
                    padding: 3px;
                    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
                `;
                
                // Imagen del avatar
                const avatarImg = document.createElement('img');
                avatarImg.src = user.photo;
                avatarImg.style.cssText = `
                    width: 100%;
                    height: 100%;
                    border-radius: 50%;
                    object-fit: cover;
                    border: 2px solid #0d1117;
                `;
                
                ring.appendChild(avatarImg);
                markerDiv.appendChild(ring);
                
                // Pensamiento encima del avatar (si existe)
                if (user.thought && user.thought.trim() && (user.isOnline || Date.now() - (user.thoughtTime || 0) < 3600000)) {
                    if (isCurrentUser) {
                        console.log('✅ Mostrando pensamiento del usuario actual:', user.thought);
                    }
                    
                    const thoughtLabel = document.createElement('div');
                    thoughtLabel.textContent = user.thought;
                    
                    // Estilo diferente si es el usuario actual (más sutil)
                    if (isCurrentUser) {
                        thoughtLabel.style.cssText = `
                            position: absolute;
                            bottom: 100%;
                            left: 50%;
                            transform: translateX(-50%);
                            background: rgba(56, 189, 98, 0.15);
                            backdrop-filter: blur(8px);
                            -webkit-backdrop-filter: blur(8px);
                            color: #38bd62;
                            padding: 5px 10px;
                            border-radius: 10px;
                            font-size: 10px;
                            font-weight: 600;
                            white-space: nowrap;
                            margin-bottom: 6px;
                            border: 1px solid rgba(56, 189, 98, 0.4);
                            box-shadow: 0 2px 6px rgba(56, 189, 98, 0.3);
                            max-width: 120px;
                            overflow: hidden;
                            text-overflow: ellipsis;
                            pointer-events: none;
                            opacity: 0.9;
                        `;
                    } else {
                        // Estilo normal para otros usuarios
                        thoughtLabel.style.cssText = `
                            position: absolute;
                            bottom: 100%;
                            left: 50%;
                            transform: translateX(-50%);
                            background: rgba(13, 17, 23, 0.95);
                            backdrop-filter: blur(12px);
                            -webkit-backdrop-filter: blur(12px);
                            color: #e6edf3;
                            padding: 8px 12px;
                            border-radius: 12px;
                            font-size: 12px;
                            font-weight: 500;
                            white-space: nowrap;
                            margin-bottom: 8px;
                            border: 1px solid rgba(56, 189, 98, 0.3);
                            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
                            max-width: 150px;
                            overflow: hidden;
                            text-overflow: ellipsis;
                            pointer-events: none;
                        `;
                    }
                    
                    markerDiv.appendChild(thoughtLabel);
                }
                
                // Badge de mensajes no leídos
                if (user.unreadCount > 0) {
                    const badge = document.createElement('div');
                    badge.textContent = user.unreadCount;
                    badge.style.cssText = `
                        position: absolute;
                        top: -4px;
                        right: -4px;
                        background: #ffd700;
                        color: #0d1117;
                        border-radius: 50%;
                        width: 20px;
                        height: 20px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 11px;
                        font-weight: 700;
                        border: 2px solid #0d1117;
                        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
                    `;
                    markerDiv.appendChild(badge);
                }
                
                // Click handler
                markerDiv.addEventListener('click', () => {
                    handleAvatarClick(user);
                });
                
                // Crear Custom Overlay
                class CustomMarker extends google.maps.OverlayView {
                    constructor(position, content) {
                        super();
                        this.position = position;
                        this.content = content;
                    }
                    
                    onAdd() {
                        const pane = this.getPanes().overlayMouseTarget;
                        pane.appendChild(this.content);
                    }
                    
                    draw() {
                        const overlayProjection = this.getProjection();
                        const position = overlayProjection.fromLatLngToDivPixel(this.position);
                        
                        if (position) {
                            // Aplicar offset si existe (para evitar superposición)
                            const finalX = position.x + (this.offset?.x || 0);
                            const finalY = position.y + (this.offset?.y || 0);
                            
                            this.content.style.left = finalX - (this.content.offsetWidth / 2) + 'px';
                            this.content.style.top = finalY - (this.content.offsetHeight / 2) + 'px';
                            this.content.style.position = 'absolute';
                        }
                    }
                    
                    onRemove() {
                        if (this.content.parentElement) {
                            this.content.parentElement.removeChild(this.content);
                        }
                    }
                }
                
                const marker = new CustomMarker(
                    new google.maps.LatLng(user.latitude, user.longitude),
                    markerDiv
                );
                
                marker.setMap(map);
                
                return marker;
            };
            
            
            // ==========================================
            // SISTEMA ANTI-SUPERPOSICIÓN CON OFFSETS
            // ==========================================
            
            const applyCollisionOffsets = (markers, googleMap, currentUserId) => {
                if (!googleMap || Object.keys(markers).length < 2) return;
                
                const projection = googleMap.getProjection();
                if (!projection) return;
                
                // Resetear offsets primero
                Object.values(markers).forEach(marker => {
                    marker.offset = { x: 0, y: 0 };
                });
                
                // Obtener posiciones en píxeles
                const positions = [];
                Object.entries(markers).forEach(([userId, marker]) => {
                    const pixel = projection.fromLatLngToDivPixel(marker.position);
                    if (pixel) {
                        positions.push({
                            userId,
                            marker,
                            x: pixel.x,
                            y: pixel.y,
                            isCurrentUser: userId === currentUserId,
                            offset: { x: 0, y: 0 }
                        });
                    }
                });
                
                const COLLISION_RADIUS = 50; // 50 píxeles de radio de colisión (aumentado)
                const OFFSET_DISTANCE = 65; // Desplazar 65px cuando hay colisión (aumentado)
                
                // Detectar colisiones y aplicar offsets
                positions.forEach((pos1, i) => {
                    positions.forEach((pos2, j) => {
                        if (i >= j) return; // Evitar duplicados
                        
                        const dx = pos2.x - pos1.x;
                        const dy = pos2.y - pos1.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // ¡HAY COLISIÓN!
                        if (distance < COLLISION_RADIUS) {
                            console.log(`⚠️ Colisión detectada: ${distance.toFixed(0)}px entre avatares`);
                            
                            // Calcular ángulo entre avatares
                            const angle = Math.atan2(dy, dx);
                            
                            if (pos1.isCurrentUser) {
                                // TÚ no te mueves, solo el otro
                                pos2.offset.x = Math.cos(angle) * OFFSET_DISTANCE;
                                pos2.offset.y = Math.sin(angle) * OFFSET_DISTANCE;
                                console.log(`   → Desplazando otro avatar: (${pos2.offset.x.toFixed(0)}, ${pos2.offset.y.toFixed(0)})`);
                            } else if (pos2.isCurrentUser) {
                                // TÚ no te mueves, solo el otro
                                pos1.offset.x = -Math.cos(angle) * OFFSET_DISTANCE;
                                pos1.offset.y = -Math.sin(angle) * OFFSET_DISTANCE;
                                console.log(`   → Desplazando otro avatar: (${pos1.offset.x.toFixed(0)}, ${pos1.offset.y.toFixed(0)})`);
                            } else {
                                // Ambos se desplazan
                                pos1.offset.x -= Math.cos(angle) * (OFFSET_DISTANCE / 2);
                                pos1.offset.y -= Math.sin(angle) * (OFFSET_DISTANCE / 2);
                                pos2.offset.x += Math.cos(angle) * (OFFSET_DISTANCE / 2);
                                pos2.offset.y += Math.sin(angle) * (OFFSET_DISTANCE / 2);
                                console.log(`   → Desplazando ambos avatares`);
                            }
                        }
                    });
                });
                
                // Aplicar offsets a los markers
                positions.forEach(pos => {
                    pos.marker.offset = pos.offset;
                    pos.marker.draw();
                });
                
                const collisions = positions.filter(p => Math.abs(p.offset.x) > 0 || Math.abs(p.offset.y) > 0).length;
                console.log(`✅ Anti-superposición: ${collisions} avatares desplazados de ${positions.length} totales`);
            };
            
            const calculateZIndex = (user, currentUser, isCurrentUser) => {
                if (isCurrentUser) return 1000; // Usuario actual siempre al frente
                
                // Usuarios más cerca tienen z-index MÁS BAJO (quedan detrás)
                // Usuarios más lejos tienen z-index MÁS ALTO (quedan adelante)
                const baseZIndex = 100;
                const distanceBonus = Math.floor(user.distance); // 1 punto por metro
                
                return baseZIndex + distanceBonus;
            };
            
            // Actualizar markers de usuarios en el mapa
            useEffect(() => {
                if (!googleMap || !currentUser) return;
                
                console.log('🎯 Actualizando markers en el mapa...');
                
                // Limpiar markers anteriores
                Object.values(mapMarkers).forEach(marker => {
                    marker.setMap(null);
                });
                
                const newMarkers = {};
                
                // Marker del usuario actual (centro)
                newMarkers[currentUser.id] = createUserMarker(currentUser, googleMap, currentUser, true);
                
                // Markers de otros usuarios (dentro del radio)
                users
                    .filter(user => {
                        if (!currentUser) return false;
                        if (user.distance > radius) return false;
                        return user.isOnline || user.hasNewMessage;
                    })
                    .forEach(user => {
                        newMarkers[user.id] = createUserMarker(user, googleMap, currentUser, false);
                    });
                
                setMapMarkers(newMarkers);
                
                console.log(`✅ ${Object.keys(newMarkers).length} markers actualizados`);
                
                // Aplicar anti-superposición después del renderizado
                setTimeout(() => {
                    applyCollisionOffsets(newMarkers, googleMap, currentUser.id);
                }, 150);
                
            }, [googleMap, currentUser, users, radius, viewedStories]);
            
            // Re-aplicar anti-superposición cuando cambia el zoom/radio
            useEffect(() => {
                if (!googleMap || !currentUser || Object.keys(mapMarkers).length < 2) return;
                
                const timeoutId = setTimeout(() => {
                    applyCollisionOffsets(mapMarkers, googleMap, currentUser.id);
                }, 200);
                
                return () => clearTimeout(timeoutId);
            }, [radius, googleMap, currentUser, mapMarkers]);

            // ==========================================
            // ULTRASONIC SYSTEM - Audio Ultrasónico
            // ==========================================
            
            // Emitir señal ultrasónica con ID de usuario codificado
            const emitUltrasonicSignal = (userId) => {
                if (!audioContext) return;
                
                try {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    // Frecuencia base: 19.5 kHz (inaudible para humanos)
                    const baseFreq = 19500;
                    
                    // Codificar userId en la frecuencia (simple FSK)
                    // Último dígito del hash del userId determina offset
                    const userHash = userId.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
                    const freqOffset = (userHash % 10) * 50; // 0-500 Hz offset
                    
                    oscillator.frequency.value = baseFreq + freqOffset;
                    oscillator.type = 'sine';
                    
                    // Volumen moderado
                    gainNode.gain.value = 0.3;
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    // Burst corto de 150ms
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.15);
                    
                    console.log(`🔊 Emitiendo ultrasonido: ${(baseFreq + freqOffset).toFixed(0)} Hz`);
                } catch (error) {
                    console.error('Error emitting ultrasonic:', error);
                }
            };
            
            // Iniciar detector de ultrasonido
            const startUltrasonicDetector = async () => {
                if (ultrasonicActive) return;
                
                try {
                    // Solicitar permiso de micrófono
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            sampleRate: 48000 // Alta frecuencia de muestreo para captar 19.5 kHz
                        }
                    });
                    
                    // Crear contexto de audio para análisis
                    const ctx = new (window.AudioContext || window.webkitAudioContext)();
                    ultrasonicContext.current = ctx;
                    
                    const analyser = ctx.createAnalyser();
                    analyser.fftSize = 4096; // Alta resolución
                    analyser.smoothingTimeConstant = 0.3;
                    ultrasonicAnalyser.current = analyser;
                    
                    const source = ctx.createMediaStreamSource(stream);
                    source.connect(analyser);
                    
                    setUltrasonicActive(true);
                    console.log('✅ Detector ultrasónico activado');
                    
                    // Iniciar detección continua
                    detectUltrasonicSignals();
                } catch (error) {
                    console.error('Error starting ultrasonic detector:', error);
                    console.log('⚠️ Micrófono no disponible - precisión <5m desactivada');
                }
            };
            
            // Detener detector de ultrasonido
            const stopUltrasonicDetector = () => {
                if (detectionInterval.current) {
                    clearInterval(detectionInterval.current);
                    detectionInterval.current = null;
                }
                
                if (ultrasonicContext.current) {
                    ultrasonicContext.current.close();
                    ultrasonicContext.current = null;
                }
                
                setUltrasonicActive(false);
                setUltrasonicDetections({});
                console.log('❌ Detector ultrasónico desactivado');
            };
            
            // Detectar señales ultrasónicas
            const detectUltrasonicSignals = () => {
                if (!ultrasonicAnalyser.current) return;
                
                const analyser = ultrasonicAnalyser.current;
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                
                detectionInterval.current = setInterval(() => {
                    analyser.getByteFrequencyData(dataArray);
                    
                    // Buscar picos en rango 19-20 kHz
                    // frequencyBinCount / 2 = Nyquist frequency (24 kHz at 48kHz sample rate)
                    const nyquist = ultrasonicContext.current.sampleRate / 2;
                    const binWidth = nyquist / bufferLength;
                    
                    const minFreq = 19000;
                    const maxFreq = 20000;
                    const minBin = Math.floor(minFreq / binWidth);
                    const maxBin = Math.floor(maxFreq / binWidth);
                    
                    let maxAmplitude = 0;
                    let peakFrequency = 0;
                    
                    for (let i = minBin; i < maxBin && i < bufferLength; i++) {
                        if (dataArray[i] > maxAmplitude) {
                            maxAmplitude = dataArray[i];
                            peakFrequency = i * binWidth;
                        }
                    }
                    
                    // Threshold: detectar señal si amplitud > 100
                    if (maxAmplitude > 100) {
                        // Calcular distancia aproximada por intensidad de señal
                        // Ley del cuadrado inverso simplificada
                        // distance ≈ 5 * (1 - amplitude/255)
                        const normalizedAmplitude = maxAmplitude / 255;
                        const estimatedDistance = Math.max(0.1, 5 * (1 - normalizedAmplitude));
                        
                        console.log(`🎯 Ultrasonido detectado: ${peakFrequency.toFixed(0)} Hz, Amp:${maxAmplitude}, ~${estimatedDistance.toFixed(2)}m`);
                        
                        // Guardar detección
                        setUltrasonicDetections(prev => ({
                            ...prev,
                            'nearby': estimatedDistance,
                            lastUpdate: Date.now()
                        }));
                    }
                }, 200); // Detectar cada 200ms
            };
            
            // Combinar distancia GPS con distancia ultrasónica
            const getFinalDistance = (gpsDistance, userId) => {
                // Si hay detección ultrasónica reciente (< 1 segundo) y distancia GPS < 5m
                const hasRecentDetection = ultrasonicDetections.lastUpdate && 
                                         (Date.now() - ultrasonicDetections.lastUpdate) < 1000;
                
                if (gpsDistance < 5 && hasRecentDetection && ultrasonicDetections.nearby) {
                    const ultrasonicDist = ultrasonicDetections.nearby;
                    // Promedio ponderado: 70% ultrasónico, 30% GPS
                    const finalDist = (ultrasonicDist * 0.7) + (gpsDistance * 0.3);
                    return Math.max(0.1, finalDist); // Mínimo 10cm
                }
                return gpsDistance;
            };

            useEffect(() => {
                // VERSION CHECK
                console.log('🚀 RADAR SOCIAL v4.0 - GOOGLE MAPS ✅ COMPLETO');
                console.log('═══════════════════════════════════════');
                console.log('🗺️ GOOGLE MAPS CON TU API KEY:');
                console.log('   ✅ API Key configurada correctamente');
                console.log('   ✅ Mapa de Google Maps activo');
                console.log('   ✅ Pantalla completa con calles reales');
                console.log('   ✅ Avatares como markers personalizados');
                console.log('   ✅ Header flotante transparente');
                console.log('   ✅ Slider con zoom automático');
                console.log('   ✅ Estilo dark profesional');
                console.log('═══════════════════════════════════════');
                console.log('📸 Re-view stories | ⏰ Tiempo | 🗑️ 12h');
                console.log('🐛 Fix usuarios nuevos | 🔔 Notificaciones');
                console.log('🔐 Seguridad | ❤️ Reacciones | 💬 Contador');
                console.log('═══════════════════════════════════════');
                
                // Verificar si ya hay un usuario logueado
                const currentAuthUser = auth.currentUser;
                if (currentAuthUser) {
                    console.log('👤 Usuario ya autenticado, ocultando landing');
                    setShowLanding(false);
                }
                
                // Initialize audio context
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                setAudioContext(ctx);
                
                // Load real user from Firebase
                const unsubscribe = auth.onAuthStateChanged(async (firebaseUser) => {
                    if (firebaseUser) {
                        try {
                            console.log('✅ Firebase User logged in:', firebaseUser.displayName);
                            console.log('📧 Email:', firebaseUser.email);
                            console.log('📷 Photo URL:', firebaseUser.photoURL);
                            
                            // Ocultar landing page
                            setShowLanding(false);
                            
                            // ==========================================
                            // CREAR USUARIO INMEDIATAMENTE (sin esperar GPS)
                            // ==========================================
                            
                            // Obtener datos del usuario de Firestore
                            const userDoc = await db.collection('users').doc(firebaseUser.uid).get();
                            
                            let thought = '';
                            let hasActiveStory = false;
                            let storyUrl = null;
                            let storyTimestamp = null;
                            
                            if (userDoc.exists) {
                                const userData = userDoc.data();
                                
                                // Check thought expiration
                                if (userData.thought && userData.thoughtTimestamp) {
                                    const now = Date.now();
                                    const thoughtTime = userData.thoughtTimestamp.toMillis ? userData.thoughtTimestamp.toMillis() : userData.thoughtTimestamp;
                                    const hoursPassed = (now - thoughtTime) / (1000 * 60 * 60);
                                    
                                    if (hoursPassed < 24) {
                                        thought = userData.thought;
                                    }
                                }
                                
                                // Check story expiration
                                if (userData.storyUrl && userData.storyTimestamp) {
                                    const now = Date.now();
                                    const storyTime = userData.storyTimestamp.toMillis ? userData.storyTimestamp.toMillis() : userData.storyTimestamp;
                                    const hoursPassed = (now - storyTime) / (1000 * 60 * 60);
                                    
                                    // Stories duran 12 horas (como Instagram)
                                    if (hoursPassed < 12) {
                                        hasActiveStory = true;
                                        storyUrl = userData.storyUrl;
                                        storyTimestamp = storyTime;
                                    } else {
                                        // Story expirado - limpiar de Firestore
                                        console.log(`🗑️ Story de ${firebaseUser.displayName} expirado (${hoursPassed.toFixed(1)}h)`);
                                    }
                                }
                            }
                            
                            // Crear usuario INMEDIATAMENTE con ubicación temporal (0, 0)
                            const initialUser = {
                                id: firebaseUser.uid,
                                name: firebaseUser.displayName || 'Usuario',
                                age: 25,
                                photo: firebaseUser.photoURL || `https://ui-avatars.com/api/?name=${encodeURIComponent(firebaseUser.displayName || 'User')}&background=38bd62&color=fff&size=150`,
                                thought: thought,
                                hasStory: hasActiveStory,
                                storyUrl: storyUrl,
                                storyTimestamp: storyTimestamp,
                                distance: 0,
                                angle: 0,
                                hasNewMessage: false,
                                unreadCount: 0, // Nuevo: contador de mensajes sin leer
                                email: firebaseUser.email,
                                latitude: 0,  // Se actualizará con GPS
                                longitude: 0  // Se actualizará con GPS
                            };
                            
                            console.log('👤 Usuario creado inmediatamente:', initialUser);
                            setCurrentUser(initialUser);
                            setThought(thought);
                            
                            // ==========================================
                            // MARCAR COMO ONLINE EN FIRESTORE INMEDIATAMENTE
                            // ==========================================
                            // Aunque no tengamos GPS aún, marcamos al usuario como online
                            // CON UBICACIÓN TEMPORAL para que aparezca en el listener
                            // El GPS actualizará la ubicación en unos segundos
                            try {
                                await db.collection('users').doc(firebaseUser.uid).set({
                                    uid: firebaseUser.uid,
                                    displayName: firebaseUser.displayName,
                                    email: firebaseUser.email,
                                    photoURL: firebaseUser.photoURL,
                                    isOnline: true,
                                    lastSeen: firebase.firestore.FieldValue.serverTimestamp(),
                                    // TEMPORAL: Ubicación en (0, 0) para que aparezca en listener
                                    // Se actualizará con GPS real en 2-10 segundos
                                    location: new firebase.firestore.GeoPoint(0, 0),
                                    pendingGPS: true, // Flag que indica que estamos esperando GPS real
                                }, { merge: true });
                                
                                console.log('✅ Usuario marcado como ONLINE en Firestore (esperando GPS para ubicación real)');
                            } catch (firestoreError) {
                                console.error('⚠️ Error al marcar usuario como online:', firestoreError);
                                // No bloqueamos el flujo si falla
                            }
                            
                        } catch (error) {
                            console.error('❌ Error crítico al crear usuario inicial:', error);
                            alert('Error al iniciar sesión: ' + error.message);
                        }
                        
                        // ==========================================
                        // AHORA SÍ, OBTENER UBICACIÓN GPS
                        // ==========================================
                        
                        // Get user's current location with HIGH PRECISION
                        if ('geolocation' in navigator) {
                            let lastUpdateTime = 0;
                            let usersUnsubscribe = null;
                            
                            // ✅ OBTENER UBICACIÓN INICIAL PRECISA INMEDIATAMENTE
                            navigator.geolocation.getCurrentPosition(
                                (position) => {
                                    const { latitude, longitude, accuracy } = position.coords;
                                    console.log(`📍 Ubicación inicial: ${latitude.toFixed(6)}, ${longitude.toFixed(6)} (±${accuracy.toFixed(1)}m)`);
                                    
                                    // Actualizar estado inmediatamente
                                    setUserLocation({ latitude, longitude });
                                    setCurrentUser(prev => ({
                                        ...prev,
                                        latitude,
                                        longitude
                                    }));
                                },
                                (error) => {
                                    console.warn('⚠️ No se pudo obtener ubicación inicial:', error.message);
                                },
                                {
                                    enableHighAccuracy: true,
                                    timeout: 10000,
                                    maximumAge: 0  // Forzar lectura nueva (no caché)
                                }
                            );
                            
                            // Use watchPosition for continuous updates
                            let previousLocation = null;
                            
                            const watchId = navigator.geolocation.watchPosition(
                                async (position) => {
                                    const { latitude, longitude, accuracy } = position.coords;
                                    const currentTime = Date.now();
                                    
                                    // ✅ IGNORAR LECTURAS MUY IMPRECISAS (especialmente al inicio)
                                    if (accuracy > 50) {
                                        console.log(`⚠️ GPS impreciso ignorado: ±${accuracy.toFixed(1)}m (esperando mejor señal...)`);
                                        return;
                                    }
                                    
                                    // ==========================================
                                    // APLICAR SENSOR FUSION 🧠
                                    // ==========================================
                                    const fusedLocation = applySensorFusion(
                                        { latitude, longitude },
                                        accuracy
                                    );
                                    
                                    // Check if movement is significant (more than 3 meters)
                                    const shouldUpdate = !previousLocation || 
                                                       calculateDistance(
                                                           previousLocation.latitude,
                                                           previousLocation.longitude,
                                                           fusedLocation.latitude,
                                                           fusedLocation.longitude
                                                       ) >= 3;
                                    
                                    if (shouldUpdate) {
                                        console.log(`📍 GPS Raw: ${latitude.toFixed(6)}, ${longitude.toFixed(6)} (±${accuracy.toFixed(1)}m)`);
                                        console.log(`🎯 Fused: ${fusedLocation.latitude.toFixed(6)}, ${fusedLocation.longitude.toFixed(6)} (±${fusedLocation.accuracy.toFixed(1)}m)`);
                                        
                                        // Update local state with FUSED location
                                        setUserLocation({ 
                                            latitude: fusedLocation.latitude, 
                                            longitude: fusedLocation.longitude 
                                        });
                                        previousLocation = { 
                                            latitude: fusedLocation.latitude, 
                                            longitude: fusedLocation.longitude 
                                        };
                                        
                                        // ✅ ACTUALIZAR USUARIO CON UBICACIÓN REAL
                                        setCurrentUser(prev => ({
                                            ...prev,
                                            latitude: fusedLocation.latitude,
                                            longitude: fusedLocation.longitude
                                        }));
                                    } else {
                                        console.log(`📍 Movement ignored (< 3m)`);
                                    }
                                    
                                    // Update Firebase every 3 seconds (throttle to avoid excessive writes)
                                    if (currentTime - lastUpdateTime >= 3000 && shouldUpdate) {
                                        lastUpdateTime = currentTime;
                                        
                                        try {
                                            // First time setup - iniciar listener de usuarios
                                            if (!usersUnsubscribe) {
                                                console.log('🔄 Iniciando listener de otros usuarios...');
                                                
                                                // Listen to all users in real-time
                                                usersUnsubscribe = db.collection('users')
                                                    .where('isOnline', '==', true)
                                                    .onSnapshot((snapshot) => {
                                                        const otherUsers = [];
                                                        
                                                        // CRÍTICO: Obtener ubicación actual del ESTADO, no de la variable local
                                                        // Esto asegura que siempre usamos las coordenadas MÁS RECIENTES
                                                        setCurrentUser(currentUserState => {
                                                            if (!currentUserState || !currentUserState.latitude || !currentUserState.longitude) {
                                                                console.warn('⚠️ currentUser sin ubicación válida');
                                                                return currentUserState;
                                                            }
                                                            
                                                            const currentLat = currentUserState.latitude;
                                                            const currentLon = currentUserState.longitude;
                                                        
                                                        snapshot.forEach((doc) => {
                                                            const userData = doc.data();
                                                            
                                                            // Skip current user
                                                            if (userData.uid === firebaseUser.uid) return;
                                                            
                                                            console.log(`👀 Viendo usuario: ${userData.displayName || 'Unknown'}, location: ${userData.location ? 'Yes' : 'No'}, isOnline: ${userData.isOnline}`);
                                                            
                                                            // VERIFICAR ESTADO ONLINE (pero NO filtrar aún)
                                                            let isOnline = false;
                                                            if (userData.lastSeen) {
                                                                const lastSeenTime = userData.lastSeen.toMillis ? userData.lastSeen.toMillis() : userData.lastSeen;
                                                                const now = Date.now();
                                                                const timeSinceLastSeen = now - lastSeenTime;
                                                                
                                                                isOnline = timeSinceLastSeen <= 30000; // Últimos 30 segundos
                                                                
                                                                if (!isOnline) {
                                                                    console.log(`⏸️ Usuario ${userData.displayName} offline (${Math.round(timeSinceLastSeen/1000)}s)`);
                                                                    // NO hacer return aquí - el usuario podría tener mensajes pendientes
                                                                }
                                                            }
                                                            
                                                            // Calculate distance and angle from current user
                                                            // SOLO procesar si el usuario tiene ubicación VÁLIDA
                                                            // EXCEPCIÓN: Si el usuario es NUEVO (pendingGPS=true o recién conectado < 15s),
                                                            // lo mostramos en (0,0) temporalmente hasta que obtengamos GPS real
                                                            
                                                            let isNewUser = false;
                                                            if (userData.pendingGPS || 
                                                                (userData.lastSeen && 
                                                                 (Date.now() - (userData.lastSeen.toMillis ? userData.lastSeen.toMillis() : userData.lastSeen)) < 15000)) {
                                                                isNewUser = true;
                                                            }
                                                            
                                                            if (userData.location) {
                                                                const userLat = userData.location.latitude;
                                                                const userLon = userData.location.longitude;
                                                                
                                                                // Si es usuario NUEVO con GPS temporal (0,0), lo mostramos en el centro
                                                                // de lo contrario, solo mostramos usuarios con GPS válido (!= 0,0)
                                                                // Si es usuario NUEVO con GPS temporal (0,0), lo mostramos en el centro
                                                                // de lo contrario, solo mostramos usuarios con GPS válido (!= 0,0)
                                                                if (isNewUser || (userLat !== 0 && userLon !== 0)) {
                                                                
                                                                let distance, angle;
                                                                
                                                                // Si es usuario nuevo con ubicación temporal (0,0)
                                                                if (userLat === 0 && userLon === 0) {
                                                                    // Mostrar en el centro del radar temporalmente
                                                                    distance = 1; // 1 metro (muy cerca, casi en el centro)
                                                                    angle = 0; // Norte
                                                                    console.log(`🆕 Usuario NUEVO sin GPS aún: ${userData.displayName} - Mostrando en centro temporalmente`);
                                                                } else {
                                                                    // Usuario con GPS real - calcular distancia y ángulo normal
                                                                    distance = Math.round(
                                                                        calculateDistance(currentLat, currentLon, userLat, userLon)
                                                                    );
                                                                    
                                                                    angle = Math.round(
                                                                        calculateBearing(currentLat, currentLon, userLat, userLon)
                                                                    );
                                                                }
                                                                
                                                                // Check if thought is expired (24 hours)
                                                                let displayThought = '';
                                                                if (userData.thought && userData.thoughtTimestamp) {
                                                                    const now = Date.now();
                                                                    const thoughtTime = userData.thoughtTimestamp.toMillis ? userData.thoughtTimestamp.toMillis() : userData.thoughtTimestamp;
                                                                    const hoursPassed = (now - thoughtTime) / (1000 * 60 * 60);
                                                                    
                                                                    if (hoursPassed < 24) {
                                                                        displayThought = userData.thought;
                                                                    }
                                                                }
                                                                
                                                                // Check if story is expired (24 hours)
                                                                let hasActiveStory = false;
                                                                let storyUrl = null;
                                                                let storyTimestamp = null;
                                                                if (userData.storyUrl && userData.storyTimestamp) {
                                                                    const now = Date.now();
                                                                    const storyTime = userData.storyTimestamp.toMillis ? userData.storyTimestamp.toMillis() : userData.storyTimestamp;
                                                                    const hoursPassed = (now - storyTime) / (1000 * 60 * 60);
                                                                    
                                                                    // Stories duran 12 horas (como Instagram)
                                                                    if (hoursPassed < 12) {
                                                                        hasActiveStory = true;
                                                                        storyUrl = userData.storyUrl;
                                                                        storyTimestamp = storyTime;
                                                                    } else {
                                                                        // Story expirado - limpiar de Firestore
                                                                        console.log(`🗑️ Story de ${userData.displayName} expirado (${hoursPassed.toFixed(1)}h)`);
                                                                    }
                                                                }
                                                                
                                                                console.log(`➕ Agregando ${userData.displayName} al radar: ${distance}m, ${angle}°, online:${isOnline}${userLat === 0 && userLon === 0 ? ' [🆕 GPS TEMPORAL]' : ''}`);
                                                                
                                                                otherUsers.push({
                                                                    id: userData.uid,
                                                                    name: userData.displayName || 'Usuario',
                                                                    age: 25,
                                                                    photo: userData.photoURL || 'https://ui-avatars.com/api/?name=' + encodeURIComponent(userData.displayName || 'User') + '&background=38bd62&color=fff&size=150',
                                                                    thought: displayThought,
                                                                    hasStory: hasActiveStory,
                                                                    storyUrl: storyUrl,
                                                                    storyTimestamp: storyTimestamp,
                                                                    distance: distance,
                                                                    angle: angle,
                                                                    hasNewMessage: false, // Se actualizará por el listener de mensajes
                                                                    unreadCount: 0, // Nuevo: contador de mensajes sin leer
                                                                    isOnline: isOnline, // Estado de conexión
                                                                    latitude: userLat,
                                                                    longitude: userLon
                                                                });
                                                                } // Cierre del if (isNewUser || (userLat !== 0 && userLon !== 0))
                                                            } // Cierre del if (userData.location)
                                                        });
                                                        
                                                        // ==========================================
                                                        // GRACE PERIOD: Mantener usuarios visibles por 5 segundos
                                                        // Esto previene parpadeo durante detección ultrasónica
                                                        // ==========================================
                                                        const GRACE_PERIOD = 5000; // 5 segundos
                                                        const now = Date.now();
                                                        
                                                        // Actualizar timestamps de usuarios que acabamos de ver
                                                        // y obtener el objeto actualizado
                                                        let currentLastSeen = {};
                                                        setLastSeenUsers(prev => {
                                                            const updated = { ...prev };
                                                            otherUsers.forEach(user => {
                                                                updated[user.id] = now;
                                                            });
                                                            currentLastSeen = updated; // Capturar para usar abajo
                                                            return updated;
                                                        });
                                                        
                                                        setUsers(prevUsers => {
                                                            // 1. Usuarios que acabamos de ver (activos ahora)
                                                            const activeUsers = otherUsers.map(newUser => {
                                                                const existingUser = prevUsers.find(u => u.id === newUser.id);
                                                                
                                                                if (existingUser) {
                                                                    const preservedUser = { ...newUser };
                                                                    
                                                                    if (existingUser.hasNewMessage) {
                                                                        console.log(`💛 PRESERVANDO hasNewMessage=true para ${newUser.name}`);
                                                                        preservedUser.hasNewMessage = true;
                                                                    }
                                                                    
                                                                    return preservedUser;
                                                                }
                                                                
                                                                return newUser;
                                                            });
                                                            
                                                            // 2. Usuarios previos que están en grace period
                                                            // (no están en lista activa pero los vimos recientemente)
                                                            const activeUserIds = new Set(activeUsers.map(u => u.id));
                                                            const gracePeriodUsers = prevUsers.filter(prevUser => {
                                                                // Si ya está en lista activa, skip
                                                                if (activeUserIds.has(prevUser.id)) return false;
                                                                
                                                                // Verificar si está en grace period
                                                                const lastSeen = currentLastSeen[prevUser.id];
                                                                if (!lastSeen) return false;
                                                                
                                                                const timeSinceLastSeen = now - lastSeen;
                                                                const inGracePeriod = timeSinceLastSeen < GRACE_PERIOD;
                                                                
                                                                if (inGracePeriod) {
                                                                    console.log(`⏳ GRACE PERIOD: Manteniendo ${prevUser.name} visible (${Math.round(timeSinceLastSeen/1000)}s ago)`);
                                                                } else {
                                                                    console.log(`⏰ GRACE PERIOD expiró: Removiendo ${prevUser.name} (${Math.round(timeSinceLastSeen/1000)}s ago)`);
                                                                }
                                                                
                                                                return inGracePeriod;
                                                            });
                                                            
                                                            // 3. Combinar usuarios activos + grace period
                                                            return [...activeUsers, ...gracePeriodUsers];
                                                        });
                                                        
                                                        console.log(`👥 Usuarios actualizados: ${otherUsers.length} usuarios ONLINE activos`);
                                                        if (otherUsers.length > 0) {
                                                            console.log('Lista:', otherUsers.map(u => `${u.name} (${u.distance}m)`).join(', '));
                                                        }
                                                        
                                                        // Retornar currentUser sin cambios
                                                        return currentUserState;
                                                    }); // Cierre de setCurrentUser
                                                    });
                                            }
                                            
                                            // Update user in Firestore with FUSED location
                                            await db.collection('users').doc(firebaseUser.uid).set({
                                                uid: firebaseUser.uid,
                                                displayName: firebaseUser.displayName,
                                                email: firebaseUser.email,
                                                photoURL: firebaseUser.photoURL,
                                                location: new firebase.firestore.GeoPoint(fusedLocation.latitude, fusedLocation.longitude),
                                                isOnline: true,
                                                lastSeen: firebase.firestore.FieldValue.serverTimestamp(),
                                                accuracy: fusedLocation.accuracy,
                                                pendingGPS: false // GPS real obtenido ✅
                                            }, { merge: true });
                                            
                                            // Update current user location in state
                                            setCurrentUser(prev => prev ? ({
                                                ...prev,
                                                latitude: fusedLocation.latitude,
                                                longitude: fusedLocation.longitude
                                            }) : prev);
                                            
                                        } catch (error) {
                                            console.error('Error updating location:', error);
                                        }
                                    }
                                },
                                (error) => {
                                    console.error('Location error:', error);
                                    
                                    // Instead of alert, we could show a non-intrusive notification
                                    // For now, just log it
                                    let errorMessage = 'No se pudo obtener tu ubicación.';
                                    
                                    switch(error.code) {
                                        case error.PERMISSION_DENIED:
                                            errorMessage = 'Permiso de ubicación denegado.';
                                            break;
                                        case error.POSITION_UNAVAILABLE:
                                            errorMessage = 'Ubicación no disponible.';
                                            break;
                                        case error.TIMEOUT:
                                            errorMessage = 'Tiempo de espera agotado.';
                                            break;
                                    }
                                    
                                    console.warn('⚠️', errorMessage);
                                },
                                {
                                    enableHighAccuracy: true,  // ✅ Alta precisión GPS
                                    timeout: 30000,            // 30 segundos timeout
                                    maximumAge: 5000           // Usar caché de 5 segundos (evita ubicación inicial mala)
                                }
                            );
                            
                            // Cleanup on unmount
                            return () => {
                                navigator.geolocation.clearWatch(watchId);
                                if (usersUnsubscribe) usersUnsubscribe();
                                // Mark user as offline
                                db.collection('users').doc(firebaseUser.uid).update({
                                    isOnline: false,
                                    lastSeen: firebase.firestore.FieldValue.serverTimestamp()
                                }).catch(err => console.error('Error marking offline:', err));
                            };
                            
                        } else {
                            console.error('❌ Tu dispositivo no soporta geolocalización');
                            // Redirect to error page or show elegant message
                            window.location.href = 'auth.html';
                        }
                    } else {
                        // No user logged in, redirect to auth
                        console.log('No user logged in, redirecting...');
                        window.location.href = 'auth.html';
                    }
                });
                
                return () => unsubscribe();
            }, []);

            // Listen to device orientation (compass)
            useEffect(() => {
                let hasRequested = false;
                
                const handleOrientation = (event) => {
                    // alpha: rotation around z-axis (compass heading)
                    // iOS uses webkitCompassHeading, Android uses alpha
                    let heading = 0;
                    
                    if (event.webkitCompassHeading !== undefined) {
                        // iOS - direct compass heading
                        heading = event.webkitCompassHeading;
                    } else if (event.alpha !== null) {
                        // Android - calculate from alpha
                        heading = 360 - event.alpha;
                    }
                    
                    setDeviceHeading(heading);
                };
                
                const requestOrientationPermission = async () => {
                    if (hasRequested) return;
                    hasRequested = true;
                    
                    // Request permission on iOS 13+
                    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                        try {
                            const permissionState = await DeviceOrientationEvent.requestPermission();
                            if (permissionState === 'granted') {
                                window.addEventListener('deviceorientation', handleOrientation, true);
                                console.log('✅ Brújula activada (iOS)');
                            } else {
                                console.log('❌ Permiso de brújula denegado');
                            }
                        } catch (error) {
                            console.error('Error requesting orientation permission:', error);
                        }
                    } else if (window.DeviceOrientationEvent) {
                        // Non-iOS or older iOS - no permission needed
                        window.addEventListener('deviceorientation', handleOrientation, true);
                        console.log('✅ Brújula activada');
                    } else {
                        console.log('❌ Brújula no soportada');
                    }
                };
                
                // On iOS, we need a user gesture to request permission
                // Add a one-time click listener to the document
                const handleFirstClick = () => {
                    requestOrientationPermission();
                    document.removeEventListener('click', handleFirstClick);
                };
                
                // For iOS: wait for first click
                if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                    document.addEventListener('click', handleFirstClick);
                } else {
                    // For Android: start immediately
                    requestOrientationPermission();
                }
                
                return () => {
                    window.removeEventListener('deviceorientation', handleOrientation, true);
                    document.removeEventListener('click', handleFirstClick);
                };
            }, []);

            // ==========================================
            // SENSOR FUSION - Listen to Motion Sensors
            // ==========================================
            useEffect(() => {
                let motionTimeout;
                
                const handleMotion = (event) => {
                    const accel = event.accelerationIncludingGravity || event.acceleration;
                    
                    if (accel) {
                        // Calcular magnitud de aceleración
                        const magnitude = Math.sqrt(
                            (accel.x || 0) ** 2 + 
                            (accel.y || 0) ** 2 + 
                            (accel.z || 0) ** 2
                        );
                        
                        // Detectar movimiento (threshold: 11 m/s² para filtrar gravedad)
                        const isMoving = magnitude > 11; // Más de 1.1g = movimiento
                        
                        // Obtener rotación
                        const rotation = event.rotationRate || { alpha: 0, beta: 0, gamma: 0 };
                        
                        setSensorData(prev => ({
                            ...prev,
                            acceleration: {
                                x: accel.x || 0,
                                y: accel.y || 0,
                                z: accel.z || 0
                            },
                            rotation: {
                                alpha: rotation.alpha || 0,
                                beta: rotation.beta || 0,
                                gamma: rotation.gamma || 0
                            },
                            isMoving: isMoving,
                            lastMotionTime: Date.now()
                        }));
                        
                        // Auto-desactivar "isMoving" después de 2 segundos sin movimiento
                        clearTimeout(motionTimeout);
                        if (isMoving) {
                            motionTimeout = setTimeout(() => {
                                setSensorData(prev => ({ ...prev, isMoving: false }));
                            }, 2000);
                        }
                    }
                };
                
                // Request permission on iOS 13+
                const requestMotionPermission = async () => {
                    if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                        try {
                            const permissionState = await DeviceMotionEvent.requestPermission();
                            if (permissionState === 'granted') {
                                window.addEventListener('devicemotion', handleMotion, true);
                                console.log('✅ Motion sensors activated');
                            }
                        } catch (error) {
                            console.error('Error requesting motion permission:', error);
                        }
                    } else if (window.DeviceMotionEvent) {
                        window.addEventListener('devicemotion', handleMotion, true);
                        console.log('✅ Motion sensors activated');
                    }
                };
                
                // Try to activate on first user interaction
                const activateOnClick = () => {
                    requestMotionPermission();
                    document.removeEventListener('click', activateOnClick);
                };
                
                document.addEventListener('click', activateOnClick);
                
                return () => {
                    window.removeEventListener('devicemotion', handleMotion, true);
                    document.removeEventListener('click', activateOnClick);
                    clearTimeout(motionTimeout);
                };
            }, []);

            // Update heading when deviceHeading changes
            useEffect(() => {
                setSensorData(prev => ({ ...prev, heading: deviceHeading }));
            }, [deviceHeading]);

            // ==========================================
            // ULTRASONIC AUTO-ACTIVATION
            // ==========================================
            useEffect(() => {
                if (!currentUser || users.length === 0) return;
                
                // Verificar si hay usuarios a menos de 5 metros
                const nearbyUsers = users.filter(u => 
                    u.id !== currentUser.id && u.distance > 0 && u.distance < 5
                );
                
                if (nearbyUsers.length > 0 && !ultrasonicActive) {
                    // Activar sistema ultrasónico
                    console.log(`🔊 ${nearbyUsers.length} usuario(s) a <5m, activando ultrasonido...`);
                    startUltrasonicDetector();
                } else if (nearbyUsers.length === 0 && ultrasonicActive) {
                    // Desactivar si no hay nadie cerca
                    console.log('❌ No hay usuarios a <5m, desactivando ultrasonido...');
                    stopUltrasonicDetector();
                }
            }, [users, currentUser, ultrasonicActive]);

            // ==========================================
            // ACTIVE TECHNOLOGY CALCULATOR - Determina qué tech está activa
            // ==========================================
            useEffect(() => {
                // Determinar tecnología activa según modo y condiciones
                let tech = {
                    name: 'GPS',
                    icon: '📍',
                    precision: 5.0
                };

                if (techSettings.mode === 'auto') {
                    // MODO AUTOMÁTICO: Sistema decide según condiciones
                    
                    // Prioridad 1: Ultrasónico si hay usuarios muy cerca
                    if (ultrasonicActive && ultrasonicDetections.nearby) {
                        tech = {
                            name: 'Ultrasónico',
                            icon: '🔊',
                            precision: ultrasonicDetections.nearby < 1 ? 0.5 : parseFloat(ultrasonicDetections.nearby.toFixed(1))
                        };
                    }
                    // Prioridad 2: Dead Reckoning si está en movimiento
                    else if (sensorData.isMoving) {
                        tech = {
                            name: 'Dead Reckoning',
                            icon: '🧠',
                            precision: 3.0
                        };
                    }
                    // Prioridad 3: Kalman Filter si está estático
                    else {
                        tech = {
                            name: 'Kalman Filter',
                            icon: '🎯',
                            precision: 2.5
                        };
                    }
                } else {
                    // MODO MANUAL: Usuario decide qué tecnologías usar
                    
                    // Verificar en orden de precisión
                    if (techSettings.ultrasonic && ultrasonicActive && ultrasonicDetections.nearby) {
                        tech = {
                            name: 'Ultrasónico',
                            icon: '🔊',
                            precision: ultrasonicDetections.nearby < 1 ? 0.5 : parseFloat(ultrasonicDetections.nearby.toFixed(1))
                        };
                    } else if (techSettings.deadReckoning && sensorData.isMoving) {
                        tech = {
                            name: 'Dead Reckoning',
                            icon: '🧠',
                            precision: 3.0
                        };
                    } else if (techSettings.kalman) {
                        tech = {
                            name: 'Kalman Filter',
                            icon: '🎯',
                            precision: 2.5
                        };
                    } else if (techSettings.gps) {
                        tech = {
                            name: 'GPS',
                            icon: '📍',
                            precision: parseFloat(locationAccuracy.toFixed(1))
                        };
                    } else {
                        // Si nada está habilitado, mostrar GPS por defecto
                        tech = {
                            name: 'Ninguno',
                            icon: '❌',
                            precision: 0
                        };
                    }
                }

                setActiveTech(tech);
                console.log(`⚙️ Tecnología activa: ${tech.name} ${tech.icon} ±${tech.precision}m (Modo: ${techSettings.mode})`);
                
            }, [techSettings, ultrasonicActive, ultrasonicDetections.nearby, sensorData.isMoving, locationAccuracy, techRefreshTicker]);

            // ==========================================
            // SOCIAL NOTIFICATIONS - Detectar usuarios nuevos cerca
            // ==========================================
            useEffect(() => {
                // Protección: Verificar que todo existe
                if (!currentUser || !users || !Array.isArray(users) || users.length === 0) {
                    return;
                }

                try {
                    const now = Date.now();
                    const COOLDOWN_TIME = 10 * 60 * 1000; // 10 minutos en milisegundos
                    
                    // Filtrar usuarios cercanos (dentro de 50m)
                    const nearbyUsers = users.filter(u => 
                        u && 
                        u.id !== currentUser.id && 
                        typeof u.distance === 'number' &&
                        u.distance > 0 && 
                        u.distance <= 50 &&
                        u.isOnline
                    );

                    // Detectar nuevos usuarios que acaban de entrar al rango
                    // Y que NO han sido notificados recientemente (cooldown)
                    const newUsers = nearbyUsers.filter(newUser => {
                        // Verificar si no estaba en la lista anterior
                        const wasNearbyBefore = previousNearbyUsers.some(prevUser => prevUser.id === newUser.id);
                        
                        if (wasNearbyBefore) {
                            return false; // Ya estaba cerca, no notificar
                        }
                        
                        // Verificar cooldown: ¿Ya notificamos a este usuario recientemente?
                        const lastNotified = notifiedUsers[newUser.id];
                        if (lastNotified) {
                            const timeSinceLastNotification = now - lastNotified;
                            if (timeSinceLastNotification < COOLDOWN_TIME) {
                                console.log(`⏰ Cooldown activo para ${newUser.name} (${Math.round(timeSinceLastNotification / 1000)}s desde última notificación)`);
                                return false; // Aún en cooldown, no notificar
                            }
                        }
                        
                        return true; // Es nuevo Y no está en cooldown
                    });

                    // Si hay nuevos usuarios, mostrar notificaciones
                    if (newUsers.length > 0) {
                        newUsers.forEach((user, index) => {
                            // Delay escalonado para múltiples notificaciones
                            setTimeout(() => {
                                // Mensajes aleatorios
                                const messages = [
                                    `¡${user.name} está cerca! ${user.distance < 10 ? '¡Muy cerca!' : ''} ¿Por qué no saludas? 👋`,
                                    `${user.name} acaba de aparecer en tu radar. ¡Es un buen momento para conectar! 💬`,
                                    `¡Mira quién está por aquí! ${user.name} está a solo ${Math.round(user.distance)}m. ¿Conversamos? 🎯`,
                                    `${user.name} está cerca (${Math.round(user.distance)}m). ¡Envía un mensaje y rompe el hielo! ❄️`,
                                    `¡Nueva conexión disponible! ${user.name} está en tu área. ¿Te animas a escribir? ✨`
                                ];

                                const randomMessage = messages[Math.floor(Math.random() * messages.length)];

                                const notification = {
                                    id: `notif-${user.id}-${Date.now()}`,
                                    user: user,
                                    message: randomMessage
                                };

                                setSocialNotifications(prev => [...prev, notification]);
                                
                                // Reproducir sonido de conexión
                                playNotificationSound('connection');
                                
                                // Mostrar notificación del sistema
                                showSystemNotification(
                                    `📡 ${user.name} está cerca`,
                                    {
                                        body: `A ${Math.round(user.distance)} metros de distancia`,
                                        tag: 'nearby-' + user.id,
                                        renotify: true,
                                        icon: user.photo
                                    }
                                );
                                
                                // Marcar usuario como notificado
                                setNotifiedUsers(prev => ({
                                    ...prev,
                                    [user.id]: now
                                }));

                                console.log(`📢 Nueva notificación: ${user.name} detectado a ${Math.round(user.distance)}m`);

                                // Auto-remover después de 8 segundos
                                setTimeout(() => {
                                    setSocialNotifications(prev => prev.filter(n => n.id !== notification.id));
                                }, 8000);

                            }, index * 400); // 400ms de delay entre notificaciones
                        });
                    }

                    // Actualizar lista de usuarios cercanos
                    setPreviousNearbyUsers(nearbyUsers);
                    
                } catch (error) {
                    console.error('❌ Error en notificaciones sociales:', error);
                }

            }, [users, currentUser]);

            // ==========================================
            // STORY AUTO-CLOSE - Timer de 5 segundos
            // ==========================================
            useEffect(() => {
                if (!viewingStory) return;
                
                console.log(`👁️ Viendo story de ${viewingStory.name}`);
                
                // Timer de 5 segundos para cerrar automáticamente
                const autoCloseTimer = setTimeout(() => {
                    console.log(`⏱️ Story de ${viewingStory.name} completada - cerrando automáticamente`);
                    
                    // Marcar story como vista
                    setViewedStories(prev => ({
                        ...prev,
                        [viewingStory.id]: Date.now()
                    }));
                    
                    // Cerrar story
                    setViewingStory(null);
                }, 5000); // 5 segundos
                
                // Cleanup: cancelar timer si el usuario cierra manualmente
                return () => {
                    clearTimeout(autoCloseTimer);
                    
                    // Si cierra manualmente, también marcar como vista
                    if (viewingStory) {
                        setViewedStories(prev => ({
                            ...prev,
                            [viewingStory.id]: Date.now()
                        }));
                    }
                };
            }, [viewingStory]);

            // ==========================================
            // WAKE LOCK - Mantener pantalla encendida
            // ==========================================
            useEffect(() => {
                if (wakeLockEnabled) {
                    requestWakeLock();
                } else {
                    releaseWakeLock();
                }
                
                // Cleanup al desmontar
                return () => {
                    releaseWakeLock();
                };
            }, [wakeLockEnabled]);

            // ==========================================
            // AUTO-REFRESH TECNOLOGÍAS - Evitar congelamiento
            // ==========================================
            useEffect(() => {
                // Actualizar ticker cada 3 segundos para refrescar tecnologías
                const refreshInterval = setInterval(() => {
                    setTechRefreshTicker(prev => prev + 1);
                    console.log('🔄 Auto-refresh de tecnologías');
                }, 3000); // 3 segundos
                
                return () => clearInterval(refreshInterval);
            }, []);



            // ==========================================
            // ULTRASONIC EMISSION - Emitir señal periódicamente
            // ==========================================
            useEffect(() => {
                if (!ultrasonicActive || !currentUser || !audioContext) return;
                
                // Emitir señal cada 1 segundo
                const emitInterval = setInterval(() => {
                    emitUltrasonicSignal(currentUser.id);
                }, 1000);
                
                // Emitir inmediatamente al activarse
                emitUltrasonicSignal(currentUser.id);
                
                return () => clearInterval(emitInterval);
            }, [ultrasonicActive, currentUser, audioContext]);

            // ==========================================
            // CLEANUP - Detener ultrasonido al desmontar
            // ==========================================
            useEffect(() => {
                return () => {
                    console.log('🧹 Cleanup: Deteniendo sistema ultrasónico');
                    stopUltrasonicDetector();
                };
            }, []);

            // ==========================================
            // APP VISIBILITY - Apagar audio cuando se sale de la app
            // ==========================================
            useEffect(() => {
                const handleVisibilityChange = () => {
                    if (document.hidden) {
                        // App en background - apagar todo el audio/micrófono
                        console.log('🔇 App en background - desactivando audio/micrófono');
                        
                        // Marcar usuario como OFFLINE
                        if (currentUser) {
                            db.collection('users').doc(currentUser.id).update({
                                isOnline: false,
                                lastSeen: firebase.firestore.FieldValue.serverTimestamp()
                            }).catch(err => console.error('Error marking offline:', err));
                        }
                        
                        // Detener ultrasonido
                        if (ultrasonicActive) {
                            stopUltrasonicDetector();
                        }
                        
                        // Suspender AudioContext
                        if (audioContext && audioContext.state === 'running') {
                            audioContext.suspend().then(() => {
                                console.log('🔇 AudioContext suspendido');
                            });
                        }
                    } else {
                        // App volvió a foreground - reactivar AudioContext
                        console.log('🔊 App en foreground - reactivando audio');
                        
                        // Marcar usuario como ONLINE
                        if (currentUser) {
                            db.collection('users').doc(currentUser.id).update({
                                isOnline: true,
                                lastSeen: firebase.firestore.FieldValue.serverTimestamp()
                            }).catch(err => console.error('Error marking online:', err));
                        }
                        
                        if (audioContext && audioContext.state === 'suspended') {
                            audioContext.resume().then(() => {
                                console.log('🔊 AudioContext reactivado');
                            });
                        }
                        
                        // Re-activar ultrasonido si hay usuarios cerca
                        const nearbyUsers = users.filter(u => 
                            currentUser && u.id !== currentUser.id && u.distance > 0 && u.distance < 5
                        );
                        if (nearbyUsers.length > 0 && !ultrasonicActive) {
                            console.log('🔊 Re-activando ultrasonido (usuarios cerca)');
                            startUltrasonicDetector();
                        }
                    }
                };
                
                const handlePageHide = () => {
                    console.log('🔇 Página cerrada/oculta - limpiando recursos');
                    
                    // Marcar usuario como OFFLINE inmediatamente
                    if (currentUser) {
                        db.collection('users').doc(currentUser.id).update({
                            isOnline: false,
                            lastSeen: firebase.firestore.FieldValue.serverTimestamp()
                        }).catch(err => console.error('Error marking offline:', err));
                    }
                    
                    // Detener ultrasonido completamente
                    if (ultrasonicActive) {
                        stopUltrasonicDetector();
                    }
                    
                    // Cerrar AudioContext
                    if (audioContext) {
                        audioContext.close();
                    }
                };
                
                // Listeners
                document.addEventListener('visibilitychange', handleVisibilityChange);
                window.addEventListener('pagehide', handlePageHide);
                window.addEventListener('beforeunload', handlePageHide);
                
                return () => {
                    document.removeEventListener('visibilitychange', handleVisibilityChange);
                    window.removeEventListener('pagehide', handlePageHide);
                    window.removeEventListener('beforeunload', handlePageHide);
                };
            }, [audioContext, ultrasonicActive, users, currentUser]);

            // ==========================================
            // HEARTBEAT - Mantener isOnline actualizado cada 10 segundos
            // ==========================================
            useEffect(() => {
                if (!currentUser) return;
                
                console.log('💓 Heartbeat iniciado - Actualizando presencia cada 10s');
                
                const heartbeatInterval = setInterval(() => {
                    // Solo actualizar si la app está visible
                    if (!document.hidden) {
                        db.collection('users').doc(currentUser.id).update({
                            isOnline: true,
                            lastSeen: firebase.firestore.FieldValue.serverTimestamp()
                        }).catch(err => console.error('Heartbeat error:', err));
                        
                        console.log('💓 Heartbeat: isOnline = true');
                    }
                }, 10000); // Cada 10 segundos
                
                return () => clearInterval(heartbeatInterval);
            }, [currentUser]);

            // ==========================================
            // BROWSER BACK BUTTON - Prevenir cierre de sesión, solo cerrar chat
            // ==========================================
            useEffect(() => {
                const handlePopState = (e) => {
                    if (selectedUser) {
                        // Si hay chat abierto, solo cerrarlo
                        e.preventDefault();
                        setSelectedUser(null);
                        // Volver a agregar estado al historial
                        window.history.pushState(null, '', window.location.href);
                    }
                };
                
                // Agregar estado inicial al historial
                window.history.pushState(null, '', window.location.href);
                
                // Escuchar el botón "atrás"
                window.addEventListener('popstate', handlePopState);
                
                return () => {
                    window.removeEventListener('popstate', handlePopState);
                };
            }, [selectedUser]);

            // ==========================================
            // REAL-TIME MESSAGES LISTENER
            // ==========================================
            useEffect(() => {
                if (!currentUser) return;
                
                // Escuchar TODOS los mensajes donde el usuario actual es el receptor
                // Sin orderBy para evitar necesidad de índice compuesto
                const unsubscribe = db.collection('messages')
                    .where('receiver', '==', currentUser.id)
                    .where('read', '==', false)
                    .onSnapshot(snapshot => {
                        snapshot.docChanges().forEach(change => {
                            if (change.type === 'added') {
                                const message = change.doc.data();
                                const senderId = message.sender;
                                const messageId = change.doc.id;
                                
                                console.log(`📩 Nuevo mensaje de ${senderId}:`, message.content);
                                
                                // Marcar al remitente como que tiene mensaje nuevo E INCREMENTAR contador
                                setUsers(prevUsers => {
                                    const updatedUsers = prevUsers.map(u => 
                                        u.id === senderId ? { 
                                            ...u, 
                                            hasNewMessage: true,
                                            unreadCount: (u.unreadCount || 0) + 1  // Incrementar contador
                                        } : u
                                    );
                                    
                                    // Obtener info del remitente para notificación
                                    const sender = updatedUsers.find(u => u.id === senderId);
                                    if (sender) {
                                        // Sonido eliminado por preferencia del usuario
                                        // Solo suena cuando el sonar pasa por el avatar
                                        // playNotificationSound('message');
                                        
                                        // Mostrar notificación del sistema
                                        const messagePreview = message.content.length > 50 
                                            ? message.content.substring(0, 50) + '...' 
                                            : message.content;
                                        
                                        showSystemNotification(
                                            `💬 ${sender.name}`,
                                            {
                                                body: messagePreview,
                                                tag: 'message-' + senderId,
                                                renotify: true
                                            }
                                        );
                                        
                                        console.log(`🔔 Notificación enviada para mensaje de ${sender.name}`);
                                    }
                                    
                                    return updatedUsers;
                                });
                                
                                // Agregar mensaje al estado local SOLO si no existe ya
                                const chatKey = [currentUser.id, senderId].sort().join('-');
                                setMessages(prev => {
                                    const existingMessages = prev[chatKey] || [];
                                    
                                    // Verificar si el mensaje ya existe por ID
                                    const messageExists = existingMessages.some(msg => msg.id === messageId);
                                    
                                    if (messageExists) {
                                        console.log(`⚠️ Mensaje ${messageId} ya existe, ignorando duplicado`);
                                        return prev; // No agregar duplicado
                                    }
                                    
                                    // Agregar mensaje nuevo
                                    return {
                                        ...prev,
                                        [chatKey]: [...existingMessages, {
                                            id: messageId,
                                            sender: message.sender,
                                            receiver: message.receiver,
                                            content: message.content,
                                            timestamp: message.timestamp?.toDate() || new Date(),
                                            read: false
                                        }]
                                    };
                                });
                                
                                console.log(`✅ Avatar de ${senderId} marcado con hasNewMessage = true`);
                            }
                        });
                    }, error => {
                        console.error('❌ Error listening to messages:', error);
                        console.log('Índice necesario:', error.message);
                    });
                
                return () => unsubscribe();
            }, [currentUser]);

            // ==========================================
            // LOAD MESSAGE HISTORY - Cargar historial cuando se abre chat
            // ==========================================
            useEffect(() => {
                if (!currentUser || !selectedUser) return;
                
                const loadMessageHistory = async () => {
                    try {
                        const chatKey = [currentUser.id, selectedUser.id].sort().join('-');
                        
                        // Cargar mensajes que YO envié
                        const sentMessages = await db.collection('messages')
                            .where('sender', '==', currentUser.id)
                            .where('receiver', '==', selectedUser.id)
                            .orderBy('timestamp', 'asc')
                            .limit(50)
                            .get();
                        
                        // Cargar mensajes que ME enviaron
                        const receivedMessages = await db.collection('messages')
                            .where('sender', '==', selectedUser.id)
                            .where('receiver', '==', currentUser.id)
                            .orderBy('timestamp', 'asc')
                            .limit(50)
                            .get();
                        
                        // Combinar y ordenar todos los mensajes
                        const allMessages = [
                            ...sentMessages.docs.map(doc => ({
                                id: doc.id,
                                ...doc.data(),
                                timestamp: doc.data().timestamp?.toDate() || new Date()
                            })),
                            ...receivedMessages.docs.map(doc => ({
                                id: doc.id,
                                ...doc.data(),
                                timestamp: doc.data().timestamp?.toDate() || new Date()
                            }))
                        ].sort((a, b) => a.timestamp - b.timestamp);
                        
                        setMessages(prev => ({
                            ...prev,
                            [chatKey]: allMessages
                        }));
                        
                        console.log(`📜 ${allMessages.length} mensajes cargados con ${selectedUser.name}`);
                    } catch (error) {
                        console.error('Error loading message history:', error);
                    }
                };
                
                loadMessageHistory();
            }, [selectedUser, currentUser]);

            // ==========================================
            // AUTO-SCROLL - Ir al final de los mensajes automáticamente
            // ==========================================
            useEffect(() => {
                if (!selectedUser) return;
                
                // Scroll al final cuando se abre el chat o llegan nuevos mensajes
                const scrollToBottom = () => {
                    if (chatMessagesRef.current) {
                        chatMessagesRef.current.scrollTop = chatMessagesRef.current.scrollHeight;
                        console.log('📜 Auto-scroll al último mensaje');
                    }
                };
                
                // Usar setTimeout para asegurar que el DOM se actualice primero
                const timer = setTimeout(scrollToBottom, 100);
                
                return () => clearTimeout(timer);
            }, [selectedUser, messages]);

            // Recalculate distances when user location changes
            useEffect(() => {
                if (!userLocation || !currentUser) return;
                
                // Update distances and angles for all users based on new location
                setUsers(prevUsers => {
                    return prevUsers.map(user => {
                        if (user.id === currentUser.id) {
                            // Current user - just update location
                            return {
                                ...user,
                                latitude: userLocation.latitude,
                                longitude: userLocation.longitude
                            };
                        } else if (user.latitude && user.longitude) {
                            // Other users - recalculate distance and angle
                            const gpsDistance = calculateDistance(
                                userLocation.latitude,
                                userLocation.longitude,
                                user.latitude,
                                user.longitude
                            );
                            
                            // Aplicar Hybrid Precision: GPS + Ultrasonido si está cerca
                            const finalDistance = getFinalDistance(gpsDistance, user.id);
                            
                            const angle = Math.round(
                                calculateBearing(
                                    userLocation.latitude,
                                    userLocation.longitude,
                                    user.latitude,
                                    user.longitude
                                )
                            );
                            
                            return {
                                ...user,
                                distance: Math.round(finalDistance * 10) / 10, // 1 decimal de precisión
                                angle
                            };
                        }
                        return user;
                    });
                });
            }, [userLocation, currentUser]);

            // Calculate direction to point towards closest user with message
            const getDirectionToTarget = () => {
                if (!currentUser) return 0;
                const usersWithMessages = users.filter(u => u.hasNewMessage && u.id !== currentUser.id && u.distance <= radius);
                if (usersWithMessages.length === 0) return 0;
                
                // Get closest user with message
                const closestUser = usersWithMessages.reduce((prev, current) => 
                    prev.distance < current.distance ? prev : current
                );
                
                // The indicator should point to the target's actual world position
                // Since the avatar rotates with deviceHeading to stay upright,
                // and we want the indicator to point to the absolute direction,
                // we just return the target's angle (no adjustment needed)
                return closestUser.angle;
            };

            // Play radar beep with volume based on proximity
            const playRadarBeep = (distance, hasMessage) => {
                if (!audioContext || !hasMessage) return;
                
                // Calculate volume based on how close the person is to current radius
                // If person is at edge of radar or outside: quiet
                // If person is well within radar: louder
                const proximityRatio = distance / radius;
                let volume = 0;
                
                if (proximityRatio <= 1) {
                    // Person is within radar range
                    // Volume increases as they get closer to center
                    volume = Math.max(0.1, (1 - proximityRatio) * 0.6);
                } else {
                    // Person is outside radar range
                    volume = 0;
                }
                
                // Create beep sound (like Dragon Ball scouter)
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 800; // High pitch beep
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.15);
            };

            // Continuous radar beep for users with messages
            useEffect(() => {
                if (!audioContext || !locationPermission) return;
                
                let sweepAngle = 0;
                const sweepSpeed = 360 / 6000; // 360 degrees in 6 seconds (matches CSS animation)
                const lastBeepTime = {}; // Track last beep time for each user
                const BRIGHTEST_OFFSET = 40; // The brightest part of the sweep is at +40 degrees from sweep origin
                
                const checkSweepInterval = setInterval(() => {
                    sweepAngle = (sweepAngle + (sweepSpeed * 50)) % 360; // Update every 50ms
                    
                    users.forEach(user => {
                        if (currentUser && user.hasNewMessage && user.id !== currentUser.id && user.distance <= radius) {
                            const userAngle = user.angle;
                            
                            // Calculate where the brightest part of the sweep is
                            const brightestPartAngle = (sweepAngle + BRIGHTEST_OFFSET) % 360;
                            
                            // Check if the brightest part is passing over this user
                            const angleDiff = Math.abs(brightestPartAngle - userAngle);
                            const normalizedDiff = Math.min(angleDiff, 360 - angleDiff);
                            
                            // Very tight detection window (5 degrees) for precise beeping at brightest point
                            if (normalizedDiff < 5) {
                                // Only beep if we haven't beeped for this user in the last 5.8 seconds
                                const now = Date.now();
                                if (!lastBeepTime[user.id] || now - lastBeepTime[user.id] > 5800) {
                                    playRadarBeep(user.distance, true);
                                    lastBeepTime[user.id] = now;
                                }
                            }
                        }
                    });
                }, 50); // Check every 50ms for smooth detection
                
                return () => clearInterval(checkSweepInterval);
            }, [users, radius, audioContext, locationPermission, currentUser]);

            const handleSliderMouseDown = (e) => {
                e.preventDefault();
                setIsDraggingDial(true);
                handleSliderMove(e);
            };

            const handleSliderMove = (e) => {
                const slider = document.querySelector('.range-slider-track');
                if (!slider) return;
                
                const rect = slider.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                
                // Calculate position relative to slider
                let position = (clientX - rect.left) / rect.width;
                position = Math.max(0, Math.min(1, position)); // Clamp 0-1
                
                // Map 0-1 to 5-100 meters
                const newRadius = Math.round(5 + position * 95);
                setRadius(newRadius);
            };

            const handleSliderMouseMove = (e) => {
                if (!isDraggingDial) return;
                handleSliderMove(e);
            };

            const handleSliderMouseUp = () => {
                setIsDraggingDial(false);
            };

            useEffect(() => {
                if (isDraggingDial) {
                    window.addEventListener('mousemove', handleSliderMouseMove);
                    window.addEventListener('mouseup', handleSliderMouseUp);
                    window.addEventListener('touchmove', handleSliderMouseMove);
                    window.addEventListener('touchend', handleSliderMouseUp);
                    
                    return () => {
                        window.removeEventListener('mousemove', handleSliderMouseMove);
                        window.removeEventListener('mouseup', handleSliderMouseUp);
                        window.removeEventListener('touchmove', handleSliderMouseMove);
                        window.removeEventListener('touchend', handleSliderMouseUp);
                    };
                }
            }, [isDraggingDial]);

            const requestLocation = () => {
                setLocationPermission(true);
            };

            const updateThought = async () => {
                if (currentUser && thought.trim()) {
                    const thoughtData = {
                        text: thought.trim(),
                        timestamp: Date.now()
                    };
                    
                    // Update local state immediately for instant feedback
                    const updatedCurrentUser = { 
                        ...currentUser, 
                        thought: thoughtData.text, 
                        thoughtTimestamp: thoughtData.timestamp 
                    };
                    
                    setCurrentUser(updatedCurrentUser);
                    setUsers(prevUsers => prevUsers.map(u => 
                        u.id === currentUser.id ? updatedCurrentUser : u
                    ));
                    
                    // Clear input immediately
                    setThought('');
                    
                    // Save to Firebase if user is authenticated
                    const user = auth.currentUser;
                    if (user) {
                        try {
                            await db.collection('users').doc(user.uid).set({
                                thought: thoughtData.text,
                                thoughtTimestamp: firebase.firestore.FieldValue.serverTimestamp()
                            }, { merge: true });
                            
                            console.log('✅ Pensamiento publicado:', thoughtData.text);
                        } catch (error) {
                            console.error('Error updating thought:', error);
                        }
                    }
                }
            };
            
            // Check if thought is expired (24 hours)
            const isThoughtExpired = (timestamp) => {
                if (!timestamp) return true;
                const now = Date.now();
                const thoughtTime = timestamp.toMillis ? timestamp.toMillis() : timestamp;
                const hoursPassed = (now - thoughtTime) / (1000 * 60 * 60);
                return hoursPassed >= 24;
            };

            // ==========================================
            // NOTIFICATIONS & SOUNDS SYSTEM
            // ==========================================
            
            // Solicitar permiso de notificaciones
            const requestNotificationPermission = async () => {
                if (!('Notification' in window)) {
                    console.warn('⚠️ Este navegador no soporta notificaciones');
                    return false;
                }
                
                if (Notification.permission === 'granted') {
                    setNotificationsEnabled(true);
                    console.log('✅ Permiso de notificaciones ya concedido');
                    return true;
                }
                
                if (Notification.permission !== 'denied') {
                    const permission = await Notification.requestPermission();
                    if (permission === 'granted') {
                        setNotificationsEnabled(true);
                        console.log('✅ Permiso de notificaciones concedido');
                        return true;
                    }
                }
                
                console.warn('❌ Permiso de notificaciones denegado');
                return false;
            };
            
            // Reproducir sonido de notificación
            const playNotificationSound = (type = 'message') => {
                if (!soundEnabled) return;
                
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    if (type === 'message') {
                        // Sonido de mensaje: Tono doble
                        oscillator.frequency.value = 800;
                        gainNode.gain.value = 0.3;
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.1);
                        
                        setTimeout(() => {
                            const osc2 = audioContext.createOscillator();
                            const gain2 = audioContext.createGain();
                            osc2.connect(gain2);
                            gain2.connect(audioContext.destination);
                            osc2.frequency.value = 1000;
                            gain2.gain.value = 0.3;
                            osc2.start(audioContext.currentTime);
                            osc2.stop(audioContext.currentTime + 0.1);
                        }, 100);
                        
                    } else if (type === 'connection') {
                        // Sonido de conexión: Tono ascendente
                        oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(1200, audioContext.currentTime + 0.2);
                        gainNode.gain.value = 0.2;
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.2);
                    }
                    
                    console.log(`🔊 Sonido reproducido: ${type}`);
                } catch (error) {
                    console.error('❌ Error reproduciendo sonido:', error);
                }
            };
            
            // Mostrar notificación del sistema
            const showSystemNotification = (title, options = {}) => {
                if (!notificationsEnabled || Notification.permission !== 'granted') {
                    console.log('⚠️ Notificaciones no habilitadas');
                    return;
                }
                
                try {
                    const notification = new Notification(title, {
                        icon: '/favicon.ico',
                        badge: '/favicon.ico',
                        vibrate: [200, 100, 200],
                        ...options
                    });
                    
                    // Auto-cerrar después de 5 segundos
                    setTimeout(() => notification.close(), 5000);
                    
                    // Click en notificación enfoca la app
                    notification.onclick = () => {
                        window.focus();
                        notification.close();
                    };
                    
                    console.log('📬 Notificación mostrada:', title);
                } catch (error) {
                    console.error('❌ Error mostrando notificación:', error);
                }
            };
            
            // Wake Lock - Mantener pantalla encendida
            const requestWakeLock = async () => {
                if (!('wakeLock' in navigator)) {
                    console.warn('⚠️ Wake Lock no soportado en este navegador');
                    return false;
                }
                
                try {
                    wakeLockRef.current = await navigator.wakeLock.request('screen');
                    console.log('✅ Wake Lock activado - Pantalla permanecerá encendida');
                    
                    wakeLockRef.current.addEventListener('release', () => {
                        console.log('⚠️ Wake Lock liberado');
                    });
                    
                    return true;
                } catch (error) {
                    console.error('❌ Error activando Wake Lock:', error);
                    return false;
                }
            };
            
            const releaseWakeLock = async () => {
                if (wakeLockRef.current) {
                    await wakeLockRef.current.release();
                    wakeLockRef.current = null;
                    console.log('✅ Wake Lock desactivado');
                }
            };

            // ==========================================
            // GOOGLE SIGN IN - Login con Google
            // ==========================================
            const handleGoogleSignIn = async () => {
                try {
                    console.log('🔐 Iniciando Google Sign In...');
                    
                    const provider = new firebase.auth.GoogleAuthProvider();
                    provider.setCustomParameters({
                        prompt: 'select_account'
                    });
                    
                    const result = await auth.signInWithPopup(provider);
                    const user = result.user;
                    
                    console.log('✅ Login exitoso:', user.displayName);
                    console.log('📧 Email:', user.email);
                    
                    // Ocultar landing page
                    setShowLanding(false);
                    
                    // El resto del flujo (crear usuario, GPS, etc.) lo maneja el onAuthStateChanged
                    
                } catch (error) {
                    console.error('❌ Error en Google Sign In:', error);
                    
                    if (error.code === 'auth/popup-closed-by-user') {
                        console.log('⚠️ Usuario cerró el popup de login');
                    } else if (error.code === 'auth/cancelled-popup-request') {
                        console.log('⚠️ Múltiples popups abiertos');
                    } else {
                        alert('Error al iniciar sesión: ' + error.message);
                    }
                }
            };

            // ==========================================
            // HELPER: Determinar clase del anillo del avatar
            // ==========================================
            const getAvatarRingClass = (user) => {
                // Prioridad 1: Mensaje nuevo
                if (user.hasNewMessage) {
                    return 'new-message';
                }
                
                // Prioridad 2: Story no vista
                if (user.hasStory) {
                    // Verificar si ya fue vista
                    const viewedTimestamp = viewedStories[user.id];
                    
                    if (viewedTimestamp) {
                        // Verificar si la story actual es más reciente que la vista
                        // (en caso de que el usuario haya subido una nueva story)
                        if (user.storyTimestamp && user.storyTimestamp > viewedTimestamp) {
                            return 'has-story'; // Nueva story no vista
                        }
                        return 'viewed-story'; // Story ya vista
                    }
                    
                    return 'has-story'; // Story no vista
                }
                
                // Sin story
                return 'no-story';
            };

            const handleAvatarClick = async (user) => {
                // Lógica mejorada: Si ya viste la story, abre el chat
                if (user.hasStory) {
                    // Verificar si ya viste la story
                    const viewedTimestamp = viewedStories[user.id];
                    const alreadyViewed = viewedTimestamp && (!user.storyTimestamp || user.storyTimestamp <= viewedTimestamp);
                    
                    if (alreadyViewed && currentUser && user.id !== currentUser.id) {
                        // Ya viste la story → Abrir CHAT (no story de nuevo)
                        console.log(`💬 Story ya vista, abriendo chat con ${user.name}`);
                        setSelectedUser(user);
                        
                        // Marcar mensaje como leído localmente
                        setUsers(users.map(u => 
                            u.id === user.id ? { ...u, hasNewMessage: false, unreadCount: 0 } : u
                        ));
                        
                        // Marcar mensajes como leídos en Firestore
                        try {
                            const messagesSnapshot = await db.collection('messages')
                                .where('sender', '==', user.id)
                                .where('receiver', '==', currentUser.id)
                                .where('read', '==', false)
                                .get();
                            
                            const batch = db.batch();
                            messagesSnapshot.docs.forEach(doc => {
                                batch.update(doc.ref, { read: true });
                            });
                            await batch.commit();
                            
                            console.log(`✅ Mensajes de ${user.name} marcados como leídos`);
                        } catch (error) {
                            console.error('Error marking messages as read:', error);
                        }
                    } else {
                        // NO has visto la story (o es tu propia story) → Abrir STORY
                        console.log(`📸 Abriendo story de ${user.name}`);
                        setViewingStory(user);
                    }
                } else if (currentUser && user.id !== currentUser.id) {
                    // No tiene story → Abrir CHAT
                    console.log(`💬 No tiene story, abriendo chat con ${user.name}`);
                    setSelectedUser(user);
                    
                    // Marcar mensaje como leído localmente
                    setUsers(users.map(u => 
                        u.id === user.id ? { ...u, hasNewMessage: false, unreadCount: 0 } : u
                    ));
                    
                    // Marcar mensajes como leídos en Firestore
                    try {
                        const messagesSnapshot = await db.collection('messages')
                            .where('sender', '==', user.id)
                            .where('receiver', '==', currentUser.id)
                            .where('read', '==', false)
                            .get();
                        
                        const batch = db.batch();
                        messagesSnapshot.docs.forEach(doc => {
                            batch.update(doc.ref, { read: true });
                        });
                        await batch.commit();
                        
                        console.log(`✅ Mensajes de ${user.name} marcados como leídos`);
                    } catch (error) {
                        console.error('Error marking messages as read:', error);
                    }
                }
            };

            // ==========================================
            // SANITIZE INPUT - Limpia inputs para prevenir XSS
            // ==========================================
            const sanitizeInput = (input) => {
                if (!input) return '';
                
                return input
                    // Remover tags HTML
                    .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
                    .replace(/<[^>]*>/g, '')
                    // Limitar longitud
                    .substring(0, 500)
                    .trim();
            };

            const sendMessage = async () => {
                if ((!messageInput.trim() && !selectedImage) || !selectedUser || !currentUser) return;

                // RATE LIMITING: Máximo 10 mensajes por minuto
                const now = Date.now();
                const oneMinuteAgo = now - 60000;
                const recentMessages = messageSentTimestamps.filter(t => t > oneMinuteAgo);
                
                if (recentMessages.length >= 10) {
                    alert('⚠️ Espera un momento\n\nEstás enviando mensajes muy rápido. Por favor, espera unos segundos.');
                    return;
                }

                const chatKey = [currentUser.id, selectedUser.id].sort().join('-');
                let imageUrl = null;

                try {
                    // Si hay imagen, subirla primero
                    if (selectedImage) {
                        console.log('📤 Subiendo imagen...', selectedImage.name);
                        
                        const storageRef = storage.ref();
                        const imageRef = storageRef.child(`chat-images/${currentUser.id}/${Date.now()}_${selectedImage.name}`);
                        
                        const uploadTask = await imageRef.put(selectedImage);
                        imageUrl = await uploadTask.ref.getDownloadURL();
                        
                        console.log('✅ Imagen subida:', imageUrl);
                    }

                    const newMessage = {
                        sender: currentUser.id,
                        receiver: selectedUser.id,
                        content: sanitizeInput(messageInput) || (imageUrl ? '📷 Imagen' : ''),
                        imageUrl: imageUrl,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                        read: false
                    };

                    console.log(`📤 Enviando mensaje a ${selectedUser.name} (${selectedUser.id})`);
                    console.log('Contenido:', sanitizeInput(messageInput) || '📷 Imagen');

                    // Guardar mensaje en Firestore
                    const docRef = await db.collection('messages').add(newMessage);
                    
                    console.log(`✅ Mensaje guardado en Firestore con ID: ${docRef.id}`);
                    console.log(`Receptor: ${selectedUser.id}`);
                    
                    // Actualizar estado local inmediatamente para feedback
                    setMessages(prev => ({
                        ...prev,
                        [chatKey]: [...(prev[chatKey] || []), {
                            ...newMessage,
                            id: docRef.id,
                            timestamp: new Date()
                        }]
                    }));

                    setMessageInput('');
                    setSelectedImage(null);
                    
                    // Registrar timestamp para rate limiting
                    setMessageSentTimestamps(prev => [...prev.filter(t => t > oneMinuteAgo), now]);
                } catch (error) {
                    console.error('❌ Error enviando mensaje:', error);
                    alert('Error al enviar mensaje: ' + error.message);
                }
            };

            // ==========================================
            // UPLOAD STORY - Subir historia con imagen
            // ==========================================
            const uploadStory = async () => {
                if (!storyImage || !currentUser) return;

                setUploadingStory(true);
                console.log('📸 Subiendo story...', storyImage.name);

                try {
                    // Subir imagen a Firebase Storage
                    const storageRef = storage.ref();
                    const storyRef = storageRef.child(`stories/${currentUser.id}/${Date.now()}_${storyImage.name}`);
                    
                    const uploadTask = await storyRef.put(storyImage);
                    const storyUrl = await uploadTask.ref.getDownloadURL();
                    
                    console.log('✅ Story subida a Storage:', storyUrl);

                    // Actualizar documento del usuario en Firestore
                    await db.collection('users').doc(currentUser.id).update({
                        storyUrl: storyUrl,
                        storyTimestamp: firebase.firestore.FieldValue.serverTimestamp(),
                        lastSeen: firebase.firestore.FieldValue.serverTimestamp()
                    });

                    console.log('✅ Story guardada en Firestore');

                    // Actualizar usuario local
                    setUsers(prevUsers => prevUsers.map(u => 
                        u.id === currentUser.id ? {
                            ...u,
                            hasStory: true,
                            storyUrl: storyUrl,
                            storyTimestamp: new Date()
                        } : u
                    ));

                    // Cerrar modal
                    setShowStoryUpload(false);
                    setStoryImage(null);
                    setUploadingStory(false);

                    console.log('🎉 Story publicada exitosamente');

                } catch (error) {
                    console.error('❌ Error subiendo story:', error);
                    alert('Error al subir estado: ' + error.message);
                    setUploadingStory(false);
                }
            };

            // ==========================================
            // REACT TO STORY - Reaccionar a una historia
            // ==========================================
            const reactToStory = async (userId, emoji) => {
                if (!currentUser) return;

                try {
                    console.log(`❤️ Reaccionando ${emoji} a story de ${userId}`);
                    
                    // Guardar reacción local
                    setStoryReactions(prev => ({
                        ...prev,
                        [userId]: emoji
                    }));
                    
                    // Guardar reacción en Firestore
                    await db.collection('story_reactions').add({
                        storyOwnerId: userId,
                        reactorId: currentUser.id,
                        reactorName: currentUser.name,
                        reactorAvatar: currentUser.avatar,
                        emoji: emoji,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    
                    // Enviar notificación al dueño de la story
                    if (userId !== currentUser.id) {
                        const user = users.find(u => u.id === userId);
                        if (user) {
                            showSystemNotification(
                                `${emoji} ${currentUser.name}`,
                                {
                                    body: `Reaccionó a tu historia`,
                                    tag: 'reaction-' + userId,
                                    renotify: true
                                }
                            );
                        }
                    }
                    
                    console.log(`✅ Reacción ${emoji} guardada`);
                    
                    // Mostrar feedback visual
                    const feedback = document.createElement('div');
                    feedback.textContent = emoji;
                    feedback.style.cssText = `
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%) scale(0);
                        font-size: 80px;
                        z-index: 10000;
                        animation: reactionPop 0.8s ease-out;
                        pointer-events: none;
                    `;
                    document.body.appendChild(feedback);
                    
                    setTimeout(() => {
                        document.body.removeChild(feedback);
                    }, 800);
                    
                } catch (error) {
                    console.error('❌ Error reaccionando a story:', error);
                }
            };

            // ==========================================
            // CLEAN EXPIRED STORIES - Limpiar stories expirados de Firestore
            // ==========================================
            const cleanExpiredStories = async () => {
                if (!currentUser) return;

                try {
                    console.log('🧹 Verificando stories expirados...');
                    
                    const now = Date.now();
                    const twelveHoursAgo = now - (12 * 60 * 60 * 1000); // 12 horas en ms
                    
                    // Obtener el documento del usuario actual
                    const userDoc = await db.collection('users').doc(currentUser.id).get();
                    
                    if (userDoc.exists) {
                        const userData = userDoc.data();
                        
                        if (userData.storyUrl && userData.storyTimestamp) {
                            const storyTime = userData.storyTimestamp.toMillis ? 
                                userData.storyTimestamp.toMillis() : 
                                userData.storyTimestamp;
                            
                            // Si el story tiene más de 12 horas, borrarlo
                            if (storyTime < twelveHoursAgo) {
                                await db.collection('users').doc(currentUser.id).update({
                                    storyUrl: firebase.firestore.FieldValue.delete(),
                                    storyTimestamp: firebase.firestore.FieldValue.delete()
                                });
                                
                                console.log('✅ Story expirado eliminado de Firestore');
                                
                                // Actualizar estado local
                                setUsers(prevUsers => prevUsers.map(u => 
                                    u.id === currentUser.id ? {
                                        ...u,
                                        hasStory: false,
                                        storyUrl: null,
                                        storyTimestamp: null
                                    } : u
                                ));
                            }
                        }
                    }
                } catch (error) {
                    console.error('❌ Error limpiando stories expirados:', error);
                }
            };

            // Ejecutar limpieza de stories cada 30 minutos
            useEffect(() => {
                if (!currentUser) return;
                
                // Limpiar al inicio
                cleanExpiredStories();
                
                // Limpiar cada 30 minutos
                const cleanupInterval = setInterval(cleanExpiredStories, 30 * 60 * 1000);
                
                return () => clearInterval(cleanupInterval);
            }, [currentUser]);

            // ==========================================
            // APPLY TECH SETTINGS - Aplicar configuración de tecnologías
            // ==========================================
            const applyTechSettings = async () => {
                console.log('⚙️ Aplicando configuración de tecnologías...');
                console.log('Modo:', techSettings.mode);
                console.log('Tecnologías habilitadas:', techSettings);

                try {
                    // ACTIVAR PERMISOS SEGÚN TECNOLOGÍAS SELECCIONADAS
                    
                    // 1. ULTRASÓNICO - Requiere permiso de micrófono
                    if (techSettings.ultrasonic && techSettings.mode === 'manual') {
                        console.log('🔊 Ultrasónico habilitado - Verificando permiso de micrófono...');
                        
                        if (!audioContext) {
                            const ctx = new (window.AudioContext || window.webkitAudioContext)();
                            setAudioContext(ctx);
                        }
                        
                        try {
                            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                            console.log('✅ Permiso de micrófono concedido');
                            // Detener el stream inmediatamente (solo queríamos verificar permiso)
                            stream.getTracks().forEach(track => track.stop());
                        } catch (err) {
                            console.warn('❌ Permiso de micrófono denegado:', err);
                            alert('⚠️ Ultrasonido requiere acceso al micrófono.\n\nPor favor, permite el acceso cuando tu navegador lo solicite.');
                        }
                    }

                    // 2. DEAD RECKONING - Requiere sensores de movimiento
                    if (techSettings.deadReckoning && techSettings.mode === 'manual') {
                        console.log('🧠 Dead Reckoning habilitado - Verificando sensores...');
                        
                        if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                            try {
                                const permission = await DeviceMotionEvent.requestPermission();
                                if (permission === 'granted') {
                                    console.log('✅ Permiso de sensores de movimiento concedido');
                                } else {
                                    console.warn('❌ Permiso de sensores denegado');
                                    alert('⚠️ Dead Reckoning requiere acceso a los sensores de movimiento.\n\nPor favor, permite el acceso cuando iOS lo solicite.');
                                }
                            } catch (err) {
                                console.warn('⚠️ Error solicitando permiso de sensores:', err);
                            }
                        } else {
                            console.log('✅ Sensores de movimiento disponibles (no requiere permiso explícito)');
                        }
                    }

                    // 3. GPS - Ya tiene permiso de ubicación (verificado al inicio)
                    if (techSettings.gps && techSettings.mode === 'manual') {
                        console.log('📍 GPS habilitado - Usando ubicación existente');
                    }

                    // 4. KALMAN FILTER - No requiere permisos adicionales
                    if (techSettings.kalman && techSettings.mode === 'manual') {
                        console.log('🎯 Kalman Filter habilitado');
                    }

                    // FORZAR ACTUALIZACIÓN DEL BADGE DE TECNOLOGÍA
                    // El useEffect de activeTech se recalculará automáticamente
                    // porque techSettings cambió
                    console.log('🔄 Actualizando badge de tecnología...');

                    // Pequeño delay para asegurar que los permisos se procesaron
                    await new Promise(resolve => setTimeout(resolve, 300));

                    // CERRAR PANELES
                    setShowTechSettings(false);
                    setShowSidebar(false);

                    console.log('✅ Configuración aplicada exitosamente');
                    console.log('📊 Tecnología activa actual:', activeTech.name);

                    // Mostrar notificación visual
                    const notification = document.createElement('div');
                    notification.style.cssText = `
                        position: fixed;
                        top: 80px;
                        left: 50%;
                        transform: translateX(-50%);
                        background: rgba(56, 189, 98, 0.95);
                        color: white;
                        padding: 12px 24px;
                        border-radius: 8px;
                        font-size: 14px;
                        font-weight: 600;
                        z-index: 9999;
                        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
                        animation: slideDown 0.3s ease;
                    `;
                    notification.textContent = `✓ Configuración aplicada: ${activeTech.name}`;
                    document.body.appendChild(notification);

                    // Remover notificación después de 2 segundos
                    setTimeout(() => {
                        notification.style.animation = 'slideUp 0.3s ease';
                        setTimeout(() => notification.remove(), 300);
                    }, 2000);

                } catch (error) {
                    console.error('❌ Error aplicando configuración:', error);
                    alert('Error al aplicar configuración: ' + error.message);
                }
            };

            // ==========================================
            // SOCIAL NOTIFICATION ACTIONS
            // ==========================================
            const openChatFromNotification = (user, notificationId) => {
                console.log(`💬 Abriendo chat con ${user.name} desde notificación`);
                
                // Cerrar notificación
                setSocialNotifications(prev => prev.filter(n => n.id !== notificationId));
                
                // Abrir chat
                setSelectedUser(user);
                
                // Marcar mensaje como leído si existe
                setUsers(prevUsers => prevUsers.map(u => 
                    u.id === user.id ? { ...u, hasNewMessage: false, unreadCount: 0 } : u
                ));
            };

            const dismissNotification = (notificationId) => {
                setSocialNotifications(prev => {
                    const updated = prev.filter(n => n.id !== notificationId);
                    return updated;
                });
            };

            if (!locationPermission) {
                return (
                    <div className="location-permission">
                        <div className="permission-card">
                            <svg className="permission-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
                            </svg>
                            <h2>Ubicación Requerida</h2>
                            <p>Radar Social necesita acceso a tu ubicación para mostrarte personas cercanas y conectar con ellas.</p>
                            <button className="permission-btn" onClick={requestLocation}>
                                Permitir Ubicación
                            </button>
                        </div>
                    </div>
                );
            }

            return (
                <>
                    {/* Landing Page - Pantalla de Bienvenida */}
                    {showLanding && (
                        <div className="landing-page">
                            <div className="landing-content">
                                <div className="landing-logo">📡</div>
                                <h1 className="landing-title">RADAR Social</h1>
                                <p className="landing-subtitle">
                                    Descubre personas cerca de ti con precisión militar
                                </p>
                                
                                <button className="google-signin-btn" onClick={handleGoogleSignIn}>
                                    <svg className="google-icon" viewBox="0 0 24 24">
                                        <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                                        <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                                        <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                                        <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                                    </svg>
                                    Continuar con Google
                                </button>
                                
                                <div className="landing-features">
                                    <div className="landing-feature">
                                        <div className="landing-feature-icon">🎯</div>
                                        <div className="landing-feature-text">Precisión ±0.5m</div>
                                    </div>
                                    <div className="landing-feature">
                                        <div className="landing-feature-icon">💬</div>
                                        <div className="landing-feature-text">Chat en tiempo real</div>
                                    </div>
                                    <div className="landing-feature">
                                        <div className="landing-feature-icon">📸</div>
                                        <div className="landing-feature-text">Stories 24h</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}

                    <div className="main-container" style={{ padding: 0, height: '100%' }}>
                        {/* Precision Badge - Top Right Corner */}
                        <div className="tech-badges-container">
                            <div 
                                className={`tech-badge precision ${activeTech.icon === '🔊' ? 'ultrasonic-active' : ''}`}
                                title={`${activeTech.name} - Modo: ${techSettings.mode === 'auto' ? 'Automático' : 'Manual'}`}
                            >
                                {activeTech.icon} ±{activeTech.precision}m
                            </div>
                        </div>
                        
                        <div className="radar-container">
                            {/* Google Maps Container - Pantalla completa */}
                            <div id="google-map" ref={mapRef}></div>
                            
                            {/* Header flotante sobre el mapa */}
                            {/* Header: [☰] [X cerca] [📬] */}
                            <div className="map-header">
                                {/* Menú hamburguesa */}
                                <svg className="header-icon" onClick={() => setShowSidebar(true)} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2.5} d="M4 6h16M4 12h16M4 18h16" />
                                </svg>
                                
                                {/* Contador centrado */}
                                <div className="map-people-counter">
                                    <div className="map-people-counter-number">
                                        {currentUser ? users.filter(u => 
                                            u.id !== currentUser.id && 
                                            u.distance <= radius && 
                                            (u.isOnline || u.hasNewMessage)
                                        ).length : 0}
                                    </div>
                                    <div className="map-people-counter-text">cerca</div>
                                </div>
                                
                                {/* Inbox */}
                                <div style={{ position: 'relative' }}>
                                    <svg className="header-icon" onClick={() => setShowInbox(true)} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
                                    </svg>
                                    {(() => {
                                        const totalUnreadCount = users.reduce((sum, u) => 
                                            sum + (u.unreadCount || 0), 0
                                        );
                                        return totalUnreadCount > 0 ? (
                                            <div style={{
                                                position: 'absolute',
                                                top: -4,
                                                right: -4,
                                                background: '#ef4444',
                                                color: '#fff',
                                                borderRadius: '50%',
                                                minWidth: totalUnreadCount > 99 ? '26px' : '20px',
                                                height: '20px',
                                                display: 'flex',
                                                alignItems: 'center',
                                                justifyContent: 'center',
                                                fontSize: '11px',
                                                fontWeight: '700',
                                                padding: totalUnreadCount > 99 ? '0 5px' : '0',
                                                border: '2px solid #0d1117',
                                                boxShadow: '0 2px 4px rgba(0,0,0,0.4)'
                                            }}>
                                                {totalUnreadCount > 99 ? '99+' : totalUnreadCount}
                                            </div>
                                        ) : null;
                                    })()}
                                </div>
                            </div>
                            
                            {/* ELIMINADO: Radar circular, avatares renderizados manualmente */}
                            {/* Ahora los avatares son markers de Google Maps */}
                            
                            <div className="range-slider-container">
                                <div className="range-slider-label">
                                    <div className="range-slider-title">Radio de Búsqueda</div>
                                    <div className="range-slider-value">{radius}m</div>
                                </div>
                                
                                <div 
                                    className="range-slider-track"
                                    onMouseDown={handleSliderMouseDown}
                                    onTouchStart={handleSliderMouseDown}
                                >
                                    <div 
                                        className="range-slider-progress"
                                        style={{ width: `${((radius - 5) / 95) * 100}%` }}
                                    />
                                    <div 
                                        className="range-slider-thumb"
                                        style={{ left: `${((radius - 5) / 95) * 100}%` }}
                                    />
                                </div>
                                
                                <div className="range-slider-marks">
                                    <div className="range-slider-mark">5m</div>
                                    <div className="range-slider-mark">30m</div>
                                    <div className="range-slider-mark">60m</div>
                                    <div className="range-slider-mark">100m</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    {/* Input de pensamiento flotante */}
                    <div className="thought-input-container">
                        <input
                            type="text"
                            className="thought-input"
                            placeholder="Escribe un pensamiento..."
                            value={thought}
                            onChange={(e) => setThought(e.target.value.slice(0, 50))}
                            onKeyPress={(e) => {
                                if (e.key === 'Enter') {
                                    updateThought();
                                }
                            }}
                            maxLength={50}
                        />
                        <div className="send-button" onClick={updateThought}>
                            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" />
                            </svg>
                        </div>
                    </div>

                    {/* Inbox Overlay - Lista de Mensajes */}
                    {showInbox && (
                        <div className={`inbox-overlay ${showInbox ? 'active' : ''}`}>
                            <div className="inbox-header">
                                <svg onClick={() => setShowInbox(false)} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2.5} d="M15 19l-7-7 7-7" />
                                </svg>
                                <h2>Mensajes</h2>
                            </div>

                            <div className="inbox-list">
                                {(() => {
                                    // Obtener todos los usuarios con los que hay chat
                                    const chatUsers = users.filter(u => {
                                        if (!currentUser || u.id === currentUser.id) return false;
                                        const chatKey = [currentUser.id, u.id].sort().join('-');
                                        return messages[chatKey] && messages[chatKey].length > 0;
                                    });

                                    if (chatUsers.length === 0) {
                                        return (
                                            <div className="inbox-empty">
                                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
                                                </svg>
                                                <p>No tienes mensajes todavía</p>
                                                <p style={{ fontSize: 13, marginTop: 8, opacity: 0.7 }}>
                                                    Toca un avatar en el radar para iniciar un chat
                                                </p>
                                            </div>
                                        );
                                    }

                                    return chatUsers.map(user => {
                                        const chatKey = [currentUser.id, user.id].sort().join('-');
                                        const chatMessages = messages[chatKey] || [];
                                        const lastMessage = chatMessages[chatMessages.length - 1];
                                        
                                        return (
                                            <div
                                                key={user.id}
                                                className={`inbox-item ${user.hasNewMessage ? 'unread' : ''}`}
                                                onClick={async () => {
                                                    console.log(`📬 Abriendo chat desde inbox: ${user.name}`);
                                                    
                                                    // Cerrar inbox
                                                    setShowInbox(false);
                                                    
                                                    // Abrir chat
                                                    setSelectedUser(user);
                                                    
                                                    // Marcar mensaje como leído localmente
                                                    setUsers(prevUsers => prevUsers.map(u => 
                                                        u.id === user.id ? { ...u, hasNewMessage: false, unreadCount: 0 } : u
                                                    ));
                                                    
                                                    // Marcar mensajes como leídos en Firestore
                                                    try {
                                                        const messagesSnapshot = await db.collection('messages')
                                                            .where('sender', '==', user.id)
                                                            .where('receiver', '==', currentUser.id)
                                                            .where('read', '==', false)
                                                            .get();
                                                        
                                                        if (messagesSnapshot.docs.length > 0) {
                                                            const batch = db.batch();
                                                            messagesSnapshot.docs.forEach(doc => {
                                                                batch.update(doc.ref, { read: true });
                                                            });
                                                            await batch.commit();
                                                            
                                                            console.log(`✅ ${messagesSnapshot.docs.length} mensaje(s) de ${user.name} marcados como leídos`);
                                                        }
                                                    } catch (error) {
                                                        console.error('❌ Error marking messages as read:', error);
                                                    }
                                                }}
                                            >
                                                <img src={user.photo} alt={user.name} className="inbox-avatar" />
                                                <div className="inbox-info">
                                                    <div className="inbox-name">
                                                        {user.name}
                                                        {user.unreadCount > 0 && (
                                                            <span className="unread-count-badge">{user.unreadCount}</span>
                                                        )}
                                                    </div>
                                                    <div className="inbox-preview">
                                                        {lastMessage ? lastMessage.content : 'Sin mensajes'}
                                                    </div>
                                                </div>
                                                <div className="inbox-meta">
                                                    <div className="inbox-distance">{Math.round(user.distance)} m</div>
                                                    {user.hasNewMessage && (
                                                        <div className="inbox-unread-badge">{user.unreadCount || 1}</div>
                                                    )}
                                                </div>
                                            </div>
                                        );
                                    });
                                })()}
                            </div>
                        </div>
                    )}

                    {selectedUser && (
                        <div className={`chat-overlay ${selectedUser ? 'active' : ''}`}>
                            <div className="chat-header">
                                <svg onClick={() => setSelectedUser(null)} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2.5} d="M15 19l-7-7 7-7" />
                                </svg>
                                <div className="chat-user-info">
                                    <div 
                                        className="chat-avatar-wrapper"
                                        onClick={() => {
                                            // Si tiene story activo, abrirlo
                                            if (selectedUser.hasStory) {
                                                console.log(`📖 Abriendo story desde chat: ${selectedUser.name}`);
                                                setViewingStory(selectedUser);
                                            }
                                        }}
                                    >
                                        {selectedUser.hasStory && (
                                            <div 
                                                className={`chat-avatar-ring ${
                                                    viewedStories[selectedUser.id] && 
                                                    (!selectedUser.storyTimestamp || selectedUser.storyTimestamp <= viewedStories[selectedUser.id])
                                                    ? 'story-seen' 
                                                    : 'has-story'
                                                }`}
                                            />
                                        )}
                                        <img 
                                            src={selectedUser.photo} 
                                            alt={selectedUser.name} 
                                            className="chat-user-avatar" 
                                            style={{
                                                position: 'relative',
                                                zIndex: 1,
                                                backgroundColor: '#1f2c33',
                                                borderRadius: '50%'
                                            }}
                                        />
                                    </div>
                                    <div className="chat-user-details">
                                        <h3>{selectedUser.name}</h3>
                                        <p>{selectedUser.distance} m de distancia</p>
                                    </div>
                                </div>
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <circle cx="12" cy="12" r="1.5"/>
                                    <circle cx="12" cy="5" r="1.5"/>
                                    <circle cx="12" cy="19" r="1.5"/>
                                </svg>
                            </div>

                            {selectedUser.thought && (
                                <div className="chat-thought-display">
                                    <span style={{ fontSize: '17px' }}>⚡</span>
                                    {selectedUser.thought}
                                </div>
                            )}

                            <div className="chat-content">
                                <div className="chat-messages" ref={chatMessagesRef}>
                                    {(() => {
                                        const chatKey = [currentUser.id, selectedUser.id].sort().join('-');
                                        const chatMessages = messages[chatKey] || [];
                                        
                                        return (
                                            <>
                                                {chatMessages.length === 0 && (
                                                    <div className="chat-info">
                                                        Esta persona está cerca de ti. ¡Envía un mensaje para iniciar una conversación!
                                                    </div>
                                                )}
                                                
                                                {chatMessages.map(msg => {
                                                    const messageTime = msg.timestamp ? 
                                                        new Date(msg.timestamp.seconds ? msg.timestamp.seconds * 1000 : msg.timestamp).toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' }) 
                                                        : '';
                                                    const isSent = msg.sender === currentUser.id;
                                                    
                                                    // Determinar estado del mensaje
                                                    let statusIcon = '';
                                                    let statusClass = '';
                                                    if (isSent) {
                                                        if (msg.read) {
                                                            statusIcon = '✓✓';
                                                            statusClass = 'read';
                                                        } else {
                                                            statusIcon = '✓✓';
                                                            statusClass = 'delivered';
                                                        }
                                                    }
                                                    
                                                    return (
                                                        <div
                                                            key={msg.id}
                                                            className={`message ${isSent ? 'sent' : 'received'}`}
                                                        >
                                                            {msg.imageUrl && (
                                                                <img 
                                                                    src={msg.imageUrl} 
                                                                    alt="Imagen enviada" 
                                                                    style={{
                                                                        maxWidth: '250px',
                                                                        maxHeight: '250px',
                                                                        borderRadius: '8px',
                                                                        marginBottom: msg.content ? '6px' : '0',
                                                                        cursor: 'pointer',
                                                                        display: 'block'
                                                                    }}
                                                                    onClick={() => window.open(msg.imageUrl, '_blank')}
                                                                />
                                                            )}
                                                            {msg.content && (
                                                                <span style={{ 
                                                                    display: 'inline',
                                                                    marginRight: '50px' 
                                                                }}>
                                                                    {msg.content}
                                                                </span>
                                                            )}
                                                            <span className="message-time">
                                                                {messageTime}
                                                                {isSent && statusIcon && (
                                                                    <span className={`message-status ${statusClass}`}>
                                                                        {statusIcon}
                                                                    </span>
                                                                )}
                                                            </span>
                                                        </div>
                                                    );
                                                })}
                                            </>
                                        );
                                    })()}
                                </div>

                                <div className="chat-input-container">
                                    <input
                                        type="file"
                                        accept="image/*"
                                        style={{ display: 'none' }}
                                        id={`image-input-${selectedUser?.id}`}
                                        onChange={(e) => {
                                            const file = e.target.files[0];
                                            if (file) {
                                                // Validar tamaño (máximo 5MB)
                                                const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB
                                                if (file.size > MAX_FILE_SIZE) {
                                                    alert('⚠️ Imagen muy grande. Máximo 5MB.\n\nTamaño actual: ' + (file.size / (1024 * 1024)).toFixed(2) + 'MB');
                                                    e.target.value = ''; // Reset input
                                                    return;
                                                }
                                                setSelectedImage(file);
                                                console.log('📷 Imagen seleccionada:', file.name, '(' + (file.size / 1024).toFixed(0) + 'KB)');
                                            }
                                        }}
                                    />
                                    {selectedImage && (
                                        <div style={{
                                            position: 'absolute',
                                            bottom: '70px',
                                            left: '16px',
                                            right: '16px',
                                            background: 'rgba(22, 27, 34, 0.95)',
                                            borderRadius: '12px',
                                            padding: '12px',
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: '12px',
                                            border: '1px solid rgba(56, 189, 98, 0.3)'
                                        }}>
                                            <div style={{
                                                fontSize: '24px'
                                            }}>📷</div>
                                            <div style={{
                                                flex: 1,
                                                fontSize: '13px',
                                                color: '#c9d1d9'
                                            }}>
                                                {selectedImage?.name}
                                            </div>
                                            <div
                                                onClick={() => setSelectedImage(null)}
                                                style={{
                                                    width: '28px',
                                                    height: '28px',
                                                    borderRadius: '50%',
                                                    background: 'rgba(239, 68, 68, 0.2)',
                                                    display: 'flex',
                                                    alignItems: 'center',
                                                    justifyContent: 'center',
                                                    cursor: 'pointer',
                                                    border: '1px solid rgba(239, 68, 68, 0.3)'
                                                }}
                                            >
                                                <svg width="16" height="16" fill="none" stroke="#ef4444" viewBox="0 0 24 24">
                                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2.5} d="M6 18L18 6M6 6l12 12" />
                                                </svg>
                                            </div>
                                        </div>
                                    )}
                                    <div 
                                        className="btn-round" 
                                        onClick={() => document.getElementById(`image-input-${selectedUser?.id}`).click()}
                                    >
                                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            {selectedImage ? (
                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                                            ) : (
                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
                                            )}
                                        </svg>
                                    </div>
                                    <textarea
                                        className="chat-input"
                                        placeholder={selectedImage ? "💬 Añade un mensaje (opcional)" : "Escribe tu respuesta..."}
                                        value={messageInput}
                                        onChange={(e) => setMessageInput(e.target.value)}
                                        rows="1"
                                    />
                                    <button
                                        className="chat-send-btn"
                                        onClick={sendMessage}
                                        disabled={!messageInput.trim() && !selectedImage}
                                    >
                                        <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" />
                                        </svg>
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Backdrop for sidebar */}
                    <div className={`overlay-backdrop ${showSidebar ? 'active' : ''}`} onClick={() => setShowSidebar(false)}></div>

                    {/* Sidebar */}
                    <div className={`sidebar ${showSidebar ? 'active' : ''}`}>
                        <div className="sidebar-header">
                            <div>
                                <h2>Menú</h2>
                                <div className="online-badge-menu" style={{ marginTop: '8px' }}>
                                    <div className="online-badge-dot"></div>
                                    <span>ONLINE</span>
                                </div>
                            </div>
                            <svg onClick={() => setShowSidebar(false)} style={{ cursor: 'pointer', width: '24px', height: '24px', color: '#8b949e' }} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2.5} d="M6 18L18 6M6 6l12 12" />
                            </svg>
                        </div>
                        <div className="sidebar-content">
                            <div className="sidebar-item" onClick={() => { setShowSidebar(false); setShowProfile(true); }}>
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
                                </svg>
                                <span>Mi Perfil</span>
                            </div>
                            <div className="sidebar-item">
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z" />
                                </svg>
                                <span>Amigos</span>
                            </div>
                            <div className="sidebar-item">
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
                                </svg>
                                <span>Mensajes</span>
                            </div>
                            <div className="sidebar-item" onClick={() => { setShowSidebar(false); setShowTechSettings(true); }}>
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 3v2m6-2v2M9 19v2m6-2v2M5 9H3m2 6H3m18-6h-2m2 6h-2M7 19h10a2 2 0 002-2V7a2 2 0 00-2-2H7a2 2 0 00-2 2v10a2 2 0 002 2zM9 9h6v6H9V9z" />
                                </svg>
                                <span>Tecnologías</span>
                            </div>
                            <div className="sidebar-item" onClick={async () => {
                                setShowSidebar(false);
                                
                                // Mostrar info de permisos
                                const permissionStatus = {
                                    gps: locationPermission ? '✅ Concedido' : '❌ Denegado',
                                    microphone: ultrasonicActive ? '✅ Activo' : '⚠️ Inactivo'
                                };
                                
                                const message = `📍 **Ubicación GPS:** ${permissionStatus.gps}\n🎤 **Micrófono (Ultrasonido):** ${permissionStatus.microphone}\n\n¿Deseas solicitar los permisos necesarios?`;
                                
                                if (confirm(message)) {
                                    // Solicitar permisos
                                    try {
                                        // GPS
                                        if (!locationPermission) {
                                            const result = await navigator.permissions.query({ name: 'geolocation' });
                                            if (result.state === 'prompt' || result.state === 'denied') {
                                                navigator.geolocation.getCurrentPosition(
                                                    () => {
                                                        setLocationPermission(true);
                                                        alert('✅ Permiso de ubicación concedido');
                                                    },
                                                    (error) => {
                                                        alert('❌ Permiso de ubicación denegado. Ve a Configuración del navegador para habilitarlo.');
                                                    }
                                                );
                                            }
                                        }
                                        
                                        // Micrófono
                                        if (!ultrasonicActive) {
                                            try {
                                                await navigator.mediaDevices.getUserMedia({ audio: true });
                                                alert('✅ Permiso de micrófono concedido');
                                            } catch (err) {
                                                alert('❌ Permiso de micrófono denegado');
                                            }
                                        }
                                    } catch (error) {
                                        console.error('Error solicitando permisos:', error);
                                    }
                                }
                            }}>
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" />
                                </svg>
                                <span>Permisos</span>
                            </div>
                            <div className="sidebar-item">
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                                </svg>
                                <span>Configuración</span>
                            </div>
                            <div className="sidebar-item">
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                                </svg>
                                <span>Ayuda</span>
                            </div>
                        </div>
                    </div>

                    {/* Profile */}
                    <div className={`profile-overlay ${showProfile ? 'active' : ''}`}>
                        <div className="profile-header">
                            <svg onClick={() => setShowProfile(false)} style={{ cursor: 'pointer', width: '26px', height: '26px', color: '#8b949e' }} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2.5} d="M15 19l-7-7 7-7" />
                            </svg>
                            <h2 style={{ fontSize: '18px', fontWeight: 600, color: '#f0f6fc' }}>Mi Perfil</h2>
                        </div>
                        <div className="profile-content">
                            <div className="profile-avatar-section">
                                <div style={{ position: 'relative', display: 'inline-block' }}>
                                    <img src={currentUser?.photo || 'https://i.pravatar.cc/150?img=33'} alt="Profile" className="profile-avatar-large" />
                                    {/* Botón para subir estado */}
                                    <div 
                                        className="add-story-btn" 
                                        style={{
                                            position: 'absolute',
                                            bottom: '8px',
                                            right: '8px'
                                        }}
                                        onClick={() => {
                                            setShowProfile(false);
                                            setShowStoryUpload(true);
                                        }}
                                    >
                                        +
                                    </div>
                                </div>
                                <div className="profile-name">{currentUser?.name || 'Usuario'}</div>
                                <div className="profile-bio">{currentUser?.thought || 'Sin estado'}</div>
                            </div>
                            
                            <div className="profile-section">
                                <div className="profile-section-title">Información Personal</div>
                                <div className="profile-field">
                                    <span className="profile-field-label">Nombre</span>
                                    <span className="profile-field-value">{currentUser?.name || 'Usuario'}</span>
                                </div>
                                {currentUser?.email && (
                                    <div className="profile-field">
                                        <span className="profile-field-label">Email</span>
                                        <span className="profile-field-value">{currentUser.email}</span>
                                    </div>
                                )}
                                <div className="profile-field">
                                    <span className="profile-field-label">Edad</span>
                                    <span className="profile-field-value">{currentUser?.age || 25} años</span>
                                </div>
                                <div className="profile-field">
                                    <span className="profile-field-label">Ubicación</span>
                                    <span className="profile-field-value">Panamá, PA</span>
                                </div>
                            </div>

                            <div className="profile-section">
                                <div className="profile-section-title">Estadísticas</div>
                                <div className="profile-field">
                                    <span className="profile-field-label">Conexiones</span>
                                    <span className="profile-field-value">{users.length - 1} personas cercanas</span>
                                </div>
                                <div className="profile-field">
                                    <span className="profile-field-label">Chats activos</span>
                                    <span className="profile-field-value">{Object.keys(chats).length}</span>
                                </div>
                                <div className="profile-field">
                                    <span className="profile-field-label">Estados compartidos</span>
                                    <span className="profile-field-value">3 hoy</span>
                                </div>
                            </div>

                            <div className="profile-section">
                                <h3 style={{ fontSize: '14px', fontWeight: 600, color: '#8b949e', marginBottom: '12px', textTransform: 'uppercase', letterSpacing: '0.5px' }}>
                                    Configuración
                                </h3>
                                
                                {/* Notificaciones y Sonidos */}
                                <button 
                                    onClick={async () => {
                                        setShowProfile(false);
                                        
                                        const status = `
🔔 Notificaciones: ${notificationsEnabled ? '✅ ON' : '❌ OFF'}
🔊 Sonidos: ${soundEnabled ? '✅ ON' : '❌ OFF'}
📱 Pantalla Encendida: ${wakeLockEnabled ? '✅ ON' : '❌ OFF'}

⚠️ LIMITACIÓN:
Solo funcionan con app ABIERTA y pantalla ENCENDIDA.
NO funcionan con pantalla apagada.

¿Configurar?`;
                                        
                                        if (confirm(status)) {
                                            const choice = prompt('1 = Notificaciones\n2 = Sonidos\n3 = Pantalla\n\nEscribe número:');
                                            
                                            if (choice === '1') {
                                                const result = await requestNotificationPermission();
                                                alert(result ? '✅ Notificaciones ON' : '❌ Permiso denegado');
                                            } else if (choice === '2') {
                                                setSoundEnabled(!soundEnabled);
                                                alert(soundEnabled ? '🔇 Sonidos OFF' : '🔊 Sonidos ON');
                                            } else if (choice === '3') {
                                                setWakeLockEnabled(!wakeLockEnabled);
                                                alert(wakeLockEnabled ? '🌙 Pantalla normal' : '📱 Pantalla siempre ON');
                                            }
                                        }
                                    }}
                                    style={{
                                        width: '100%',
                                        padding: '14px',
                                        background: 'rgba(56, 189, 98, 0.1)',
                                        border: '1px solid rgba(56, 189, 98, 0.3)',
                                        borderRadius: '12px',
                                        color: '#38bd62',
                                        fontSize: '15px',
                                        fontWeight: 600,
                                        cursor: 'pointer',
                                        transition: 'all 0.2s ease',
                                        display: 'flex',
                                        alignItems: 'center',
                                        justifyContent: 'center',
                                        gap: '8px',
                                        marginBottom: '12px'
                                    }}
                                >
                                    <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9" />
                                    </svg>
                                    Notificaciones
                                </button>
                                
                                {/* Cerrar Sesión */}
                                <button 
                                    onClick={async () => {
                                        if (confirm('¿Cerrar sesión? Dejarás de aparecer en el radar.')) {
                                            try {
                                                await auth.signOut();
                                                window.location.href = 'auth.html';
                                            } catch (error) {
                                                console.error('Error signing out:', error);
                                            }
                                        }
                                    }}
                                    style={{
                                        width: '100%',
                                        padding: '14px',
                                        background: 'rgba(239, 68, 68, 0.1)',
                                        border: '1px solid rgba(239, 68, 68, 0.3)',
                                        borderRadius: '12px',
                                        color: '#ef4444',
                                        fontSize: '15px',
                                        fontWeight: 600,
                                        cursor: 'pointer',
                                        transition: 'all 0.2s ease',
                                        display: 'flex',
                                        alignItems: 'center',
                                        justifyContent: 'center',
                                        gap: '8px'
                                    }}
                                    onMouseOver={(e) => {
                                        e.target.style.background = 'rgba(239, 68, 68, 0.15)';
                                        e.target.style.borderColor = 'rgba(239, 68, 68, 0.4)';
                                    }}
                                    onMouseOut={(e) => {
                                        e.target.style.background = 'rgba(239, 68, 68, 0.1)';
                                        e.target.style.borderColor = 'rgba(239, 68, 68, 0.3)';
                                    }}
                                >
                                    <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" />
                                    </svg>
                                    Cerrar Sesión
                                </button>
                            </div>
                        </div>
                    </div>

                    {/* Tech Settings Overlay */}
                    <div className={`tech-settings-overlay ${showTechSettings ? 'active' : ''}`}>
                        <div className="tech-settings-header">
                            <svg onClick={() => setShowTechSettings(false)} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2.5} d="M15 19l-7-7 7-7" />
                            </svg>
                            <h2>Configuración de Tecnologías</h2>
                        </div>
                        <div className="tech-settings-content">
                            {/* Mode Selector */}
                            <div className="tech-mode-selector">
                                <h3>Modo de Operación</h3>
                                <div className="tech-mode-options">
                                    <div 
                                        className={`tech-mode-option ${techSettings.mode === 'auto' ? 'active' : ''}`}
                                        onClick={() => setTechSettings({...techSettings, mode: 'auto'})}
                                    >
                                        <div className="icon">🤖</div>
                                        <div className="label">Automático</div>
                                        <div className="description">Combina todas las tecnologías</div>
                                    </div>
                                    <div 
                                        className={`tech-mode-option ${techSettings.mode === 'manual' ? 'active' : ''}`}
                                        onClick={() => setTechSettings({...techSettings, mode: 'manual'})}
                                    >
                                        <div className="icon">⚙️</div>
                                        <div className="label">Manual</div>
                                        <div className="description">Selecciona individualmente</div>
                                    </div>
                                </div>
                            </div>

                            {/* Individual Technologies */}
                            <div className="tech-list">
                                <h3>Tecnologías Disponibles</h3>
                                
                                {/* GPS */}
                                <div className={`tech-item ${techSettings.mode === 'auto' ? 'disabled' : ''}`}>
                                    <div className="tech-item-info">
                                        <div className="tech-item-name">
                                            <span className="tech-item-icon">📍</span>
                                            GPS
                                        </div>
                                        <div className="tech-item-description">
                                            Ubicación satelital precisa. Precisión: ±5-10m en exteriores.
                                        </div>
                                    </div>
                                    <div 
                                        className={`tech-toggle ${techSettings.mode === 'manual' && techSettings.gps ? 'active' : ''}`}
                                        onClick={() => {
                                            if (techSettings.mode === 'manual') {
                                                setTechSettings({...techSettings, gps: !techSettings.gps});
                                            }
                                        }}
                                    ></div>
                                </div>

                                {/* Kalman Filter */}
                                <div className={`tech-item ${techSettings.mode === 'auto' ? 'disabled' : ''}`}>
                                    <div className="tech-item-info">
                                        <div className="tech-item-name">
                                            <span className="tech-item-icon">🎯</span>
                                            Filtro Kalman
                                        </div>
                                        <div className="tech-item-description">
                                            Suaviza datos GPS reduciendo ruido. Mejora precisión cuando estás quieto.
                                        </div>
                                    </div>
                                    <div 
                                        className={`tech-toggle ${techSettings.mode === 'manual' && techSettings.kalman ? 'active' : ''}`}
                                        onClick={() => {
                                            if (techSettings.mode === 'manual') {
                                                setTechSettings({...techSettings, kalman: !techSettings.kalman});
                                            }
                                        }}
                                    ></div>
                                </div>

                                {/* Dead Reckoning */}
                                <div className={`tech-item ${techSettings.mode === 'auto' ? 'disabled' : ''}`}>
                                    <div className="tech-item-info">
                                        <div className="tech-item-name">
                                            <span className="tech-item-icon">🧠</span>
                                            Dead Reckoning
                                        </div>
                                        <div className="tech-item-description">
                                            Usa acelerómetro y giroscopio para estimar movimiento. Útil en interiores.
                                        </div>
                                    </div>
                                    <div 
                                        className={`tech-toggle ${techSettings.mode === 'manual' && techSettings.deadReckoning ? 'active' : ''}`}
                                        onClick={() => {
                                            if (techSettings.mode === 'manual') {
                                                setTechSettings({...techSettings, deadReckoning: !techSettings.deadReckoning});
                                            }
                                        }}
                                    ></div>
                                </div>

                                {/* Ultrasonic */}
                                <div className={`tech-item ${techSettings.mode === 'auto' ? 'disabled' : ''}`}>
                                    <div className="tech-item-info">
                                        <div className="tech-item-name">
                                            <span className="tech-item-icon">🔊</span>
                                            Ultrasonido
                                        </div>
                                        <div className="tech-item-description">
                                            Alta precisión (±0.1-1m) a corta distancia (&lt;5m). Requiere micrófono.
                                        </div>
                                    </div>
                                    <div 
                                        className={`tech-toggle ${techSettings.mode === 'manual' && techSettings.ultrasonic ? 'active' : ''}`}
                                        onClick={() => {
                                            if (techSettings.mode === 'manual') {
                                                setTechSettings({...techSettings, ultrasonic: !techSettings.ultrasonic});
                                            }
                                        }}
                                    ></div>
                                </div>
                            </div>

                            {/* Info Note */}
                            <div className="tech-info-note">
                                <h4>
                                    <svg width="16" height="16" fill="currentColor" viewBox="0 0 24 24">
                                        <path d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                    </svg>
                                    Modo Automático
                                </h4>
                                <p>
                                    En modo automático, el sistema combina todas las tecnologías inteligentemente para darte la mejor precisión posible según tu situación (interiores, exteriores, movimiento, etc.).
                                </p>
                            </div>

                            {/* Apply Button */}
                            <div className="tech-apply-container">
                                <button 
                                    className="tech-apply-btn"
                                    onClick={applyTechSettings}
                                >
                                    <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2.5} d="M5 13l4 4L19 7" />
                                    </svg>
                                    Aplicar Cambios
                                </button>
                            </div>
                        </div>
                    </div>

                    {/* Story Viewer */}
                    {/* Story Viewer - Instagram Style */}
                    {viewingStory && (
                        <div className={`story-viewer ${viewingStory ? 'active' : ''}`} onClick={() => setViewingStory(null)}>
                            <div className="story-container" onClick={(e) => e.stopPropagation()}>
                                {/* Progress Bar */}
                                <div className="story-progress-bar">
                                    <div className="story-progress-fill" style={{ width: '100%' }}></div>
                                </div>
                                
                                {/* Header */}
                                <div className="story-header">
                                    <div className="story-user-info">
                                        <img src={viewingStory.photo} alt={viewingStory.name} className="story-user-avatar" />
                                        <div style={{ display: 'flex', flexDirection: 'column', gap: '2px' }}>
                                            <span className="story-user-name">{viewingStory.name}</span>
                                            {viewingStory.storyTimestamp && (() => {
                                                const now = Date.now();
                                                const storyTime = viewingStory.storyTimestamp;
                                                const hoursAgo = (now - storyTime) / (1000 * 60 * 60);
                                                const hoursLeft = 12 - hoursAgo;
                                                
                                                let timeAgo;
                                                if (hoursAgo < 1) {
                                                    const minutesAgo = Math.floor((now - storyTime) / (1000 * 60));
                                                    timeAgo = minutesAgo < 1 ? 'hace un momento' : `hace ${minutesAgo}m`;
                                                } else {
                                                    timeAgo = `hace ${Math.floor(hoursAgo)}h`;
                                                }
                                                
                                                let timeLeft;
                                                if (hoursLeft < 1) {
                                                    const minutesLeft = Math.floor(hoursLeft * 60);
                                                    timeLeft = `expira en ${minutesLeft}m`;
                                                } else {
                                                    timeLeft = `expira en ${Math.floor(hoursLeft)}h`;
                                                }
                                                
                                                return (
                                                    <span style={{ 
                                                        fontSize: '12px', 
                                                        color: 'rgba(255, 255, 255, 0.7)',
                                                        fontWeight: '400'
                                                    }}>
                                                        {timeAgo} • {timeLeft}
                                                    </span>
                                                );
                                            })()}
                                        </div>
                                    </div>
                                    <div className="story-close" onClick={() => setViewingStory(null)}>
                                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2.5} d="M6 18L18 6M6 6l12 12" />
                                        </svg>
                                    </div>
                                </div>
                                
                                {/* Story Image */}
                                <img 
                                    src={viewingStory.storyUrl || viewingStory.photo} 
                                    alt={`${viewingStory.name}'s story`} 
                                    className="story-image"
                                    onError={(e) => {
                                        console.error('Error cargando story:', viewingStory.storyUrl);
                                        e.target.src = viewingStory.photo; // Fallback a foto de perfil
                                    }}
                                />
                                
                                {/* Botones de reacción (solo si NO es tu propia story) */}
                                {currentUser && viewingStory.id !== currentUser.id && (
                                    <div className="story-reactions">
                                        {['❤️', '😂', '😮', '😢', '🔥'].map(emoji => (
                                            <button
                                                key={emoji}
                                                className="story-reaction-btn"
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    reactToStory(viewingStory.id, emoji);
                                                }}
                                            >
                                                {emoji}
                                            </button>
                                        ))}
                                    </div>
                                )}
                                
                                {/* Botón de mensaje (solo si NO es tu propia story) */}
                                {currentUser && viewingStory.id !== currentUser.id && (
                                    <button 
                                        className="story-message-btn"
                                        onClick={(e) => {
                                            e.stopPropagation();
                                            console.log(`💬 Abriendo chat desde story de ${viewingStory.name}`);
                                            setViewingStory(null);
                                            setSelectedUser(viewingStory);
                                        }}
                                    >
                                        <svg width="18" height="18" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
                                        </svg>
                                        Enviar mensaje
                                    </button>
                                )}
                            </div>
                        </div>
                    )}

                    {/* Social Notifications */}
                    {socialNotifications.map((notification, index) => (
                        <div 
                            key={notification.id} 
                            className="social-notification"
                            style={{
                                top: `${100 + (index * 10)}px`,
                                zIndex: 9998 - index
                            }}
                        >
                            <button 
                                className="social-notification-close"
                                onClick={() => dismissNotification(notification.id)}
                            >
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                                </svg>
                            </button>
                            
                            <div className="social-notification-header">
                                <img 
                                    src={notification.user.photo} 
                                    alt={notification.user.name}
                                    className="social-notification-avatar"
                                />
                                <div className="social-notification-info">
                                    <div className="social-notification-name">
                                        {notification.user.name}
                                    </div>
                                    <div className="social-notification-distance">
                                        <svg width="12" height="12" fill="currentColor" viewBox="0 0 24 24">
                                            <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>
                                        </svg>
                                        {Math.round(notification.user.distance)} metros de distancia
                                    </div>
                                </div>
                            </div>

                            <div className="social-notification-message">
                                {notification.message}
                            </div>

                            <div className="social-notification-actions">
                                <button 
                                    className="social-notification-btn social-notification-btn-primary"
                                    onClick={() => openChatFromNotification(notification.user, notification.id)}
                                >
                                    <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
                                    </svg>
                                    Enviar Mensaje
                                </button>
                                <button 
                                    className="social-notification-btn social-notification-btn-secondary"
                                    onClick={() => dismissNotification(notification.id)}
                                >
                                    Después
                                </button>
                            </div>
                        </div>
                    ))}

                    {/* Story Upload Modal */}
                    <div className={`story-upload-overlay ${showStoryUpload ? 'active' : ''}`}>
                        <div className="story-upload-container">
                            <div className="story-upload-header">
                                <h2>Crear Estado</h2>
                                <div className="story-upload-close" onClick={() => {
                                    setShowStoryUpload(false);
                                    setStoryImage(null);
                                }}>
                                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2.5} d="M6 18L18 6M6 6l12 12" />
                                    </svg>
                                </div>
                            </div>

                            <div className="story-preview-area">
                                {storyImage ? (
                                    <>
                                        <img src={URL.createObjectURL(storyImage)} alt="Story preview" />
                                        <div className="story-remove-btn" onClick={() => setStoryImage(null)}>
                                            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2.5} d="M6 18L18 6M6 6l12 12" />
                                            </svg>
                                        </div>
                                    </>
                                ) : (
                                    <div className="story-preview-placeholder">
                                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                                        </svg>
                                        <p>Selecciona una imagen para tu estado</p>
                                    </div>
                                )}
                            </div>

                            <div className="story-upload-actions">
                                <input
                                    type="file"
                                    accept="image/*"
                                    style={{ display: 'none' }}
                                    id="storyImageInput"
                                    onChange={(e) => {
                                        if (e.target.files && e.target.files[0]) {
                                            const file = e.target.files[0];
                                            // Validar tamaño (máximo 5MB)
                                            const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB
                                            if (file.size > MAX_FILE_SIZE) {
                                                alert('⚠️ Imagen muy grande. Máximo 5MB.\n\nTamaño actual: ' + (file.size / (1024 * 1024)).toFixed(2) + 'MB');
                                                e.target.value = ''; // Reset input
                                                return;
                                            }
                                            setStoryImage(file);
                                            console.log('📸 Story imagen seleccionada:', file.name, '(' + (file.size / 1024).toFixed(0) + 'KB)');
                                        }
                                    }}
                                />
                                <button 
                                    className="story-select-btn"
                                    onClick={() => document.getElementById('storyImageInput').click()}
                                >
                                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style={{width: '20px', height: '20px'}}>
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                                    </svg>
                                    Seleccionar Imagen
                                </button>
                                <button 
                                    className="story-publish-btn"
                                    disabled={!storyImage || uploadingStory}
                                    onClick={uploadStory}
                                >
                                    {uploadingStory ? 'Publicando...' : 'Publicar Estado'}
                                </button>
                            </div>
                        </div>
                    </div>
                </>
            );
        }

        ReactDOM.render(<RadarSocialApp />, document.getElementById('root'));

        // Register Service Worker for PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/service-worker.js')
                    .then(registration => {
                        console.log('Service Worker registrado:', registration);
                    })
                    .catch(error => {
                        console.log('Error al registrar Service Worker:', error);
                    });
            });
        }
    </script>
</body>
</html>
